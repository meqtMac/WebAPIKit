// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptEventLoop
import JavaScriptKit
import SVG
import WebAPIBase

public class BoxQuadOptions: BridgedDictionary {
    public convenience init(box: CSSBoxType, relativeTo: GeometryNode) {
        let object = JSObject.global[.Object].function!.new()
        self.init(unsafelyWrapping: object)
        self.box = box
        self.relativeTo = relativeTo
    }
    
    public var box: CSSBoxType {
        get { jsObject[.box].fromJSValue()! }
        set { jsObject[.box] = newValue.jsValue }
    }
    
    public var relativeTo: GeometryNode {
        get { jsObject[.relativeTo].fromJSValue()! }
        set { jsObject[.relativeTo] = newValue.jsValue }
        
    }
}

public enum CSS {
    @inlinable static var jsObject: JSObject {
        JSObject.global[.CSS].object!
    }
    
    @inlinable public static func escape(ident: String) -> String {
        let this = JSObject.global[.CSS].object!
        return this[.escape].function!(this: this, arguments: [_toJSValue(ident)]).fromJSValue()!
    }
    
    @inlinable public static func number(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.number].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func percent(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.percent].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func em(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.em].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func ex(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.ex].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func ch(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.ch].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func ic(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.ic].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func rem(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.rem].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func lh(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.lh].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func rlh(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.rlh].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func vw(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.vw].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func vh(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.vh].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func vi(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.vi].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func vb(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.vb].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func vmin(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.vmin].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func vmax(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.vmax].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func svw(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.svw].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func svh(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.svh].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func svi(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.svi].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func svb(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.svb].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func svmin(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.svmin].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func svmax(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.svmax].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func lvw(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.lvw].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func lvh(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.lvh].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func lvi(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.lvi].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func lvb(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.lvb].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func lvmin(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.lvmin].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func lvmax(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.lvmax].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func dvw(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.dvw].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func dvh(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.dvh].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func dvi(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.dvi].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func dvb(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.dvb].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func dvmin(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.dvmin].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func dvmax(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.dvmax].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func cqw(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.cqw].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func cqh(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.cqh].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func cqi(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.cqi].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func cqb(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.cqb].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func cqmin(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.cqmin].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func cqmax(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.cqmax].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func cm(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.cm].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func mm(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.mm].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func Q(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.Q].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func `in`(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.in].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func pt(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.pt].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func pc(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.pc].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func px(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.px].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func deg(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.deg].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func grad(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.grad].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func rad(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.rad].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func turn(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.turn].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func s(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.s].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func ms(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.ms].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func Hz(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.Hz].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func kHz(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.kHz].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func dpi(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.dpi].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func dpcm(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.dpcm].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func dppx(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.dppx].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
    
    @inlinable public static func fr(value: Double) -> CSSUnitValue {
        let this = JSObject.global[.CSS].object!
        return this[.fr].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }
}

public enum CSSBoxType: JSString, JSValueCompatible {
    case margin = "margin"
    case border = "border"
    case padding = "padding"
    case content = "content"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CSSColor: CSSColorValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSColor].function }
    
    @inlinable public convenience init(colorSpace: CSSKeywordish, channels: [CSSColorPercent], alpha: CSSNumberish? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(colorSpace), _toJSValue(channels), _toJSValue(alpha)]))
    }
    
    public var colorSpace: CSSKeywordish {
        get { jsObject[.colorSpace].fromJSValue()!}
        set { jsObject[.colorSpace] = newValue.jsValue }
    }
    
    public var channels: [CSSColorPercent] {
        get { jsObject[.channels].fromJSValue()!}
        set { jsObject[.channels] = newValue.jsValue }
    }
    
    public var alpha: CSSNumberish {
        get { jsObject[.alpha].fromJSValue()!}
        set { jsObject[.alpha] = newValue.jsValue }
    }
}

public class CSSColorValue: CSSStyleValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSColorValue].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    // returns CSSStyleValue | CSSColorValue
    @inlinable public class func parse(cssText: String) -> CSSStyleValue {
        let this = constructor!
        return this[.parse].function!(this: this, arguments: [_toJSValue(cssText)]).fromJSValue()!
    }
}

public class CSSGroupingRule: CSSRule {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSGroupingRule].function }
    
    public var cssRules: CSSRuleList {
        jsObject[.cssRules].fromJSValue()!
    }
    
    @inlinable public func insertRule(rule: String, index: UInt32? = nil) -> UInt32 {
        let this = jsObject
        return this[.insertRule].function!(this: this, arguments: [_toJSValue(rule), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func deleteRule(index: UInt32) {
        let this = jsObject
        _ = this[.deleteRule].function!(this: this, arguments: [_toJSValue(index)])
    }
}

public class CSSHSL: CSSColorValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSHSL].function }
    
    
    @inlinable public convenience init(h: CSSColorAngle, s: CSSColorPercent, l: CSSColorPercent, alpha: CSSColorPercent? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(h), _toJSValue(s), _toJSValue(l), _toJSValue(alpha)]))
    }
    
    public var h: CSSColorAngle {
        get { jsObject[.h].fromJSValue()!}
        set { jsObject[.h] = newValue.jsValue }
    }
    
    public var s: CSSColorPercent {
        get { jsObject[.s].fromJSValue()!}
        set { jsObject[.s] = newValue.jsValue }
    }
    
    public var l: CSSColorPercent {
        get { jsObject[.l].fromJSValue()!}
        set { jsObject[.l] = newValue.jsValue }
    }
    
    public var alpha: CSSColorPercent {
        get { jsObject[.alpha].fromJSValue()!}
        set { jsObject[.alpha] = newValue.jsValue }
    }
}

public class CSSHWB: CSSColorValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSHWB].function }
    
    @inlinable public convenience init(h: CSSNumericValue, w: CSSNumberish, b: CSSNumberish, alpha: CSSNumberish? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(h), _toJSValue(w), _toJSValue(b), _toJSValue(alpha)]))
    }
    
    public var h: CSSNumericValue {
        get { jsObject[.h].fromJSValue()!}
        set { jsObject[.h] = newValue.jsValue }
    }
    
    public var w: CSSNumberish {
        get { jsObject[.w].fromJSValue()!}
        set { jsObject[.w] = newValue.jsValue }
    }
    
    public var b: CSSNumberish {
        get { jsObject[.b].fromJSValue()!}
        set { jsObject[.b] = newValue.jsValue }
    }
    
    public var alpha: CSSNumberish {
        get { jsObject[.alpha].fromJSValue()!}
        set { jsObject[.alpha] = newValue.jsValue }
    }
}

public class CSSImageValue: CSSStyleValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSImageValue].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class CSSImportRule: CSSRule {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSImportRule].function }
    
    public var href: String {
        jsObject[.href].fromJSValue()!
    }
    
    public var media: MediaList {
        jsObject[.media].fromJSValue()!
    }
    
    public var styleSheet: CSSStyleSheet? {
        jsObject[.styleSheet].fromJSValue()
    }
    
    public var layerName: String? {
        jsObject[.layerName].fromJSValue()
    }
    
    public var supportsText: String? {
        jsObject[.supportsText].fromJSValue()
    }
}

public class CSSKeywordValue: CSSStyleValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSKeywordValue].function }
    
    @inlinable public convenience init(value: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(value)]))
    }
    
    public var value: String {
        get { jsObject[.value].fromJSValue()!}
        set { jsObject[.value] = newValue.jsValue }
    }
}

public class CSSLCH: CSSColorValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSLCH].function }
    
    @inlinable public convenience init(l: CSSColorPercent, c: CSSColorPercent, h: CSSColorAngle, alpha: CSSColorPercent? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(l), _toJSValue(c), _toJSValue(h), _toJSValue(alpha)]))
    }
    
    public var l: CSSColorPercent {
        get { jsObject[.l].fromJSValue()!}
        set { jsObject[.l] = newValue.jsValue }
    }
    
    public var c: CSSColorPercent {
        get { jsObject[.c].fromJSValue()!}
        set { jsObject[.c] = newValue.jsValue }
    }
    
    public var h: CSSColorAngle {
        get { jsObject[.h].fromJSValue()!}
        set { jsObject[.h] = newValue.jsValue }
    }
    
    public var alpha: CSSColorPercent {
        get { jsObject[.alpha].fromJSValue()!}
        set { jsObject[.alpha] = newValue.jsValue }
    }
}

public class CSSLab: CSSColorValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSLab].function }
    
    @inlinable public convenience init(l: CSSColorPercent, a: CSSColorNumber, b: CSSColorNumber, alpha: CSSColorPercent? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(l), _toJSValue(a), _toJSValue(b), _toJSValue(alpha)]))
    }
    
    public var l: CSSColorPercent {
        get { jsObject[.l].fromJSValue()!}
        set { jsObject[.l] = newValue.jsValue }
    }
    
    public var a: CSSColorNumber {
        get { jsObject[.a].fromJSValue()!}
        set { jsObject[.a] = newValue.jsValue }
    }
    
    public var b: CSSColorNumber {
        get { jsObject[.b].fromJSValue()!}
        set { jsObject[.b] = newValue.jsValue }
    }
    
    public var alpha: CSSColorPercent {
        get { jsObject[.alpha].fromJSValue()!}
        set { jsObject[.alpha] = newValue.jsValue }
    }
}

public class CSSMarginRule: CSSRule {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSMarginRule].function }
    
    public var name: String {
        jsObject[.name].fromJSValue()!
    }
    
    public var style: CSSStyleDeclaration {
        jsObject[.style].fromJSValue()!
    }
}

public class CSSMathClamp: CSSMathValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSMathClamp].function }
    
    
    @inlinable public convenience init(lower: CSSNumberish, value: CSSNumberish, upper: CSSNumberish) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(lower), _toJSValue(value), _toJSValue(upper)]))
    }
    
    public var lower: CSSNumericValue {
        jsObject[.lower].fromJSValue()!
    }
    
    public var value: CSSNumericValue {
        jsObject[.value].fromJSValue()!
    }
    
    public var upper: CSSNumericValue {
        jsObject[.upper].fromJSValue()!
    }
}

public class CSSMathInvert: CSSMathValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSMathInvert].function }
    
    @inlinable public convenience init(arg: CSSNumberish) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(arg)]))
    }
    
    public var value: CSSNumericValue {
        jsObject[.value].fromJSValue()!
    }
}

public class CSSMathMax: CSSMathValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSMathMax].function }
    
    @inlinable public convenience init(args: CSSNumberish...) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: args.map(_toJSValue)))
    }
    
    public var values: CSSNumericArray {
        jsObject[.values].fromJSValue()!
    }
}

public class CSSMathMin: CSSMathValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSMathMin].function }
    
    @inlinable public convenience init(args: CSSNumberish...) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: args.map(_toJSValue)))
    }
    
    public var values: CSSNumericArray {
        jsObject[.values].fromJSValue()!
    }
}

public class CSSMathNegate: CSSMathValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSMathNegate].function }
    
    @inlinable public convenience init(arg: CSSNumberish) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(arg)]))
    }
    
    public var value: CSSNumericValue {
        jsObject[.value].fromJSValue()!
    }
}


public enum CSSMathOperator: JSString, JSValueCompatible {
    case sum = "sum"
    case product = "product"
    case negate = "negate"
    case invert = "invert"
    case min = "min"
    case max = "max"
    case clamp = "clamp"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CSSMathProduct: CSSMathValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSMathProduct].function }
    
    
    @inlinable public convenience init(args: CSSNumberish...) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: args.map(_toJSValue)))
    }
    
    public var values: CSSNumericArray {
        jsObject[.values].fromJSValue()!
    }
}

public class CSSMathSum: CSSMathValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSMathSum].function }
    
    @inlinable public convenience init(args: CSSNumberish...) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: args.map(_toJSValue)))
    }
    
    public var values: CSSNumericArray {
        jsObject[.values].fromJSValue()!
    }
}

public class CSSMathValue: CSSNumericValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSMathValue].function }
    
    public var `operator`: CSSMathOperator {
        jsObject[.operator].fromJSValue()!
    }
}

public class CSSMatrixComponent: CSSTransformComponent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSMatrixComponent].function }
    
    @inlinable public convenience init(matrix: DOMMatrixReadOnly, options: CSSMatrixComponentOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(matrix), _toJSValue(options)]))
    }
    
    public var matrix: DOMMatrix {
        get { jsObject[.matrix].fromJSValue()!}
        set { jsObject[.matrix] = newValue.jsValue }
    }
}

public class CSSMatrixComponentOptions: BridgedDictionary {
    public convenience init(is2D: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.is2D] = _toJSValue(is2D)
        self.init(unsafelyWrapping: object)
    }
    
    public var is2D: Bool {
        get { jsObject[.is2D].fromJSValue()!}
        set { jsObject[.is2D] = newValue.jsValue }
    }
}

public class CSSNamespaceRule: CSSRule {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSNamespaceRule].function }
    
    public var namespaceURI: String {
        jsObject[.namespaceURI].fromJSValue()!
    }
    
    public var prefix: String {
        jsObject[.prefix].fromJSValue()!
    }
}

public class CSSNumericArray: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CSSNumericArray].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public typealias Element = CSSNumericValue
    public func makeIterator() -> ValueIterableIterator<CSSNumericArray> {
        ValueIterableIterator(sequence: self)
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> CSSNumericValue {
        jsObject[key].fromJSValue()!
    }
}

public enum CSSNumericBaseType: JSString, JSValueCompatible {
    case length = "length"
    case angle = "angle"
    case time = "time"
    case frequency = "frequency"
    case resolution = "resolution"
    case flex = "flex"
    case percent = "percent"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CSSNumericType: BridgedDictionary {
    public convenience init(length: Int32, angle: Int32, time: Int32, frequency: Int32, resolution: Int32, flex: Int32, percent: Int32, percentHint: CSSNumericBaseType) {
        let object = JSObject.global[.Object].function!.new()
        object[.length] = _toJSValue(length)
        object[.angle] = _toJSValue(angle)
        object[.time] = _toJSValue(time)
        object[.frequency] = _toJSValue(frequency)
        object[.resolution] = _toJSValue(resolution)
        object[.flex] = _toJSValue(flex)
        object[.percent] = _toJSValue(percent)
        object[.percentHint] = _toJSValue(percentHint)
        self.init(unsafelyWrapping: object)
    }
    
    public var length: Int32 {
        get { jsObject[.length].fromJSValue()!}
        set { jsObject[.length] = newValue.jsValue }
    }
    
    public var angle: Int32 {
        get { jsObject[.angle].fromJSValue()!}
        set { jsObject[.angle] = newValue.jsValue }
    }
    
    public var time: Int32 {
        get { jsObject[.time].fromJSValue()!}
        set { jsObject[.time] = newValue.jsValue }
    }
    
    public var frequency: Int32 {
        get { jsObject[.frequency].fromJSValue()!}
        set { jsObject[.frequency] = newValue.jsValue }
    }
    
    public var resolution: Int32 {
        get { jsObject[.resolution].fromJSValue()!}
        set { jsObject[.resolution] = newValue.jsValue }
    }
    
    public var flex: Int32 {
        get { jsObject[.flex].fromJSValue()!}
        set { jsObject[.flex] = newValue.jsValue }
    }
    
    public var percent: Int32 {
        get { jsObject[.percent].fromJSValue()!}
        set { jsObject[.percent] = newValue.jsValue }
    }
    
    public var percentHint: CSSNumericBaseType {
        get { jsObject[.percentHint].fromJSValue()!}
        set { jsObject[.percentHint] = newValue.jsValue }
    }
}

public class CSSNumericValue: CSSStyleValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSNumericValue].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public func add(values: CSSNumberish...) -> Self {
        let this = jsObject
        return this[.add].function!(this: this, arguments: values.map(_toJSValue)).fromJSValue()!
    }
    
    @inlinable public func sub(values: CSSNumberish...) -> Self {
        let this = jsObject
        return this[.sub].function!(this: this, arguments: values.map(_toJSValue)).fromJSValue()!
    }
    
    @inlinable public func mul(values: CSSNumberish...) -> Self {
        let this = jsObject
        return this[.mul].function!(this: this, arguments: values.map(_toJSValue)).fromJSValue()!
    }
    
    @inlinable public func div(values: CSSNumberish...) -> Self {
        let this = jsObject
        return this[.div].function!(this: this, arguments: values.map(_toJSValue)).fromJSValue()!
    }
    
    @inlinable public func min(values: CSSNumberish...) -> Self {
        let this = jsObject
        return this[.min].function!(this: this, arguments: values.map(_toJSValue)).fromJSValue()!
    }
    
    @inlinable public func max(values: CSSNumberish...) -> Self {
        let this = jsObject
        return this[.max].function!(this: this, arguments: values.map(_toJSValue)).fromJSValue()!
    }
    
    @inlinable public func equals(value: CSSNumberish...) -> Bool {
        let this = jsObject
        return this[.equals].function!(this: this, arguments: value.map(_toJSValue)).fromJSValue()!
    }
    
    @inlinable public func to(unit: String) -> CSSUnitValue {
        let this = jsObject
        return this[.to].function!(this: this, arguments: [_toJSValue(unit)]).fromJSValue()!
    }
    
    @inlinable public func toSum(units: String...) -> CSSMathSum {
        let this = jsObject
        return this[.toSum].function!(this: this, arguments: units.map(_toJSValue)).fromJSValue()!
    }
    
    @inlinable public func type() -> CSSNumericType {
        let this = jsObject
        return this[.type].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public class func parse(cssText: String) -> Self {
        let this = constructor!
        return this[.parse].function!(this: this, arguments: [_toJSValue(cssText)]).fromJSValue()!
    }
}

public class CSSOKLCH: CSSColorValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSOKLCH].function }
    
    @inlinable public convenience init(l: CSSColorPercent, c: CSSColorPercent, h: CSSColorAngle, alpha: CSSColorPercent? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(l), _toJSValue(c), _toJSValue(h), _toJSValue(alpha)]))
    }
    
    public var l: CSSColorPercent {
        get { jsObject[.l].fromJSValue()!}
        set { jsObject[.l] = newValue.jsValue }
    }
    
    public var c: CSSColorPercent {
        get { jsObject[.c].fromJSValue()!}
        set { jsObject[.c] = newValue.jsValue }
    }
    
    public var h: CSSColorAngle {
        get { jsObject[.h].fromJSValue()!}
        set { jsObject[.h] = newValue.jsValue }
    }
    
    public var alpha: CSSColorPercent {
        get { jsObject[.alpha].fromJSValue()!}
        set { jsObject[.alpha] = newValue.jsValue }
    }
}

public class CSSOKLab: CSSColorValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSOKLab].function }
    
    @inlinable public convenience init(l: CSSColorPercent, a: CSSColorNumber, b: CSSColorNumber, alpha: CSSColorPercent? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(l), _toJSValue(a), _toJSValue(b), _toJSValue(alpha)]))
    }
    
    public var l: CSSColorPercent {
        get { jsObject[.l].fromJSValue()!}
        set { jsObject[.l] = newValue.jsValue }
    }
    
    public var a: CSSColorNumber {
        get { jsObject[.a].fromJSValue()!}
        set { jsObject[.a] = newValue.jsValue }
    }
    
    public var b: CSSColorNumber {
        get { jsObject[.b].fromJSValue()!}
        set { jsObject[.b] = newValue.jsValue }
    }
    
    public var alpha: CSSColorPercent {
        get { jsObject[.alpha].fromJSValue()!}
        set { jsObject[.alpha] = newValue.jsValue }
    }
}

public class CSSPageRule: CSSGroupingRule {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSPageRule].function }
    
    public var selectorText: String {
        get { jsObject[.selectorText].fromJSValue()!}
        set { jsObject[.selectorText] = newValue.jsValue }
    }
    
    public var style: CSSStyleDeclaration {
        jsObject[.style].fromJSValue()!
    }
}

public class CSSPerspective: CSSTransformComponent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSPerspective].function }
    
    @inlinable public convenience init(length: CSSPerspectiveValue) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(length)]))
    }
    
    public var length: CSSPerspectiveValue {
        get { jsObject[.length].fromJSValue()!}
        set { jsObject[.length] = newValue.jsValue }
    }
}

public class CSSRGB: CSSColorValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSRGB].function }
    
    @inlinable public convenience init(r: CSSColorRGBComp, g: CSSColorRGBComp, b: CSSColorRGBComp, alpha: CSSColorPercent? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(r), _toJSValue(g), _toJSValue(b), _toJSValue(alpha)]))
    }
    
    public var r: CSSColorRGBComp {
        get { jsObject[.r].fromJSValue()!}
        set { jsObject[.r] = newValue.jsValue }
    }
    
    public var g: CSSColorRGBComp {
        get { jsObject[.g].fromJSValue()!}
        set { jsObject[.g] = newValue.jsValue }
    }
    
    public var b: CSSColorRGBComp {
        get { jsObject[.b].fromJSValue()!}
        set { jsObject[.b] = newValue.jsValue }
    }
    
    public var alpha: CSSColorPercent {
        get { jsObject[.alpha].fromJSValue()!}
        set { jsObject[.alpha] = newValue.jsValue }
    }
}

public class CSSRotate: CSSTransformComponent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSRotate].function }
    
    @inlinable public convenience init(angle: CSSNumericValue) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(angle)]))
    }
    
    @inlinable public convenience init(x: CSSNumberish, y: CSSNumberish, z: CSSNumberish, angle: CSSNumericValue) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z), _toJSValue(angle)]))
    }
    
    public var x: CSSNumberish {
        get { jsObject[.x].fromJSValue()!}
        set { jsObject[.x] = newValue.jsValue }
    }
    
    public var y: CSSNumberish {
        get { jsObject[.y].fromJSValue()!}
        set { jsObject[.y] = newValue.jsValue }
    }
    
    public var z: CSSNumberish {
        get { jsObject[.z].fromJSValue()!}
        set { jsObject[.z] = newValue.jsValue }
    }
    
    public var angle: CSSNumericValue {
        get { jsObject[.angle].fromJSValue()!}
        set { jsObject[.angle] = newValue.jsValue }
    }
}

public class CSSRule: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CSSRule].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var cssText: String {
        get { jsObject[.cssText].fromJSValue()!}
        set { jsObject[.cssText] = newValue.jsValue }
    }
    
    public var parentRule: CSSRule? {
        jsObject[.parentRule].fromJSValue()
    }
    
    public var parentStyleSheet: CSSStyleSheet? {
        jsObject[.parentStyleSheet].fromJSValue()
    }
    
    public var type: UInt16 {
        jsObject[.type].fromJSValue()!
    }
    
    public static let STYLE_RULE: UInt16 = 1
    
    public static let CHARSET_RULE: UInt16 = 2
    
    public static let IMPORT_RULE: UInt16 = 3
    
    public static let MEDIA_RULE: UInt16 = 4
    
    public static let FONT_FACE_RULE: UInt16 = 5
    
    public static let PAGE_RULE: UInt16 = 6
    
    public static let MARGIN_RULE: UInt16 = 9
    
    public static let NAMESPACE_RULE: UInt16 = 10
}

public class CSSRuleList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CSSRuleList].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public subscript(key: Int) -> CSSRule? {
        jsObject[key].fromJSValue()
    }
    
    @inlinable public func item(index: UInt32) -> CSSRule? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
}

public class CSSScale: CSSTransformComponent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSScale].function }
    
    @inlinable public convenience init(x: CSSNumberish, y: CSSNumberish, z: CSSNumberish? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z)]))
    }
    
    public var x: CSSNumberish {
        get { jsObject[.x].fromJSValue()!}
        set { jsObject[.x] = newValue.jsValue }
    }
    
    public var y: CSSNumberish {
        get { jsObject[.y].fromJSValue()!}
        set { jsObject[.y] = newValue.jsValue }
    }
    
    public var z: CSSNumberish {
        get { jsObject[.z].fromJSValue()!}
        set { jsObject[.z] = newValue.jsValue }
    }
}

public class CSSSkew: CSSTransformComponent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSSkew].function }
    
    
    @inlinable public convenience init(ax: CSSNumericValue, ay: CSSNumericValue) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(ax), _toJSValue(ay)]))
    }
    
    public var ax: CSSNumericValue {
        get { jsObject[.ax].fromJSValue()!}
        set { jsObject[.ax] = newValue.jsValue }
    }
    
    public var ay: CSSNumericValue {
        get { jsObject[.ay].fromJSValue()!}
        set { jsObject[.ay] = newValue.jsValue }
    }
}

public class CSSSkewX: CSSTransformComponent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSSkewX].function }
    
    @inlinable public convenience init(ax: CSSNumericValue) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(ax)]))
    }
    
    public var ax: CSSNumericValue {
        get { jsObject[.ax].fromJSValue()!}
        set { jsObject[.ax] = newValue.jsValue }
    }
}

public class CSSSkewY: CSSTransformComponent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSSkewY].function }
    
    @inlinable public convenience init(ay: CSSNumericValue) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(ay)]))
    }
    
    public var ay: CSSNumericValue {
        get { jsObject[.ay].fromJSValue()!}
        set { jsObject[.ay] = newValue.jsValue }
    }
}

public class CSSStyleDeclaration: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CSSStyleDeclaration].function }
    
    public let jsObject: JSObject
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var cssText: String {
        get { jsObject[.cssText].fromJSValue()!}
        set { jsObject[.cssText] = newValue.jsValue }
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> String {
        jsObject[key].fromJSValue()!
    }
    
    @inlinable public func item(index: UInt32) -> String {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func getPropertyValue(property: String) -> String {
        let this = jsObject
        return this[.getPropertyValue].function!(this: this, arguments: [_toJSValue(property)]).fromJSValue()!
    }
    
    @inlinable public func getPropertyPriority(property: String) -> String {
        let this = jsObject
        return this[.getPropertyPriority].function!(this: this, arguments: [_toJSValue(property)]).fromJSValue()!
    }
    
    @inlinable public func setProperty(property: String, value: String, priority: String? = nil) {
        let this = jsObject
        _ = this[.setProperty].function!(this: this, arguments: [_toJSValue(property), _toJSValue(value), _toJSValue(priority)])
    }
    
    @inlinable public func removeProperty(property: String) -> String {
        let this = jsObject
        return this[.removeProperty].function!(this: this, arguments: [_toJSValue(property)]).fromJSValue()!
    }
    
    public var parentRule: CSSRule? {
        jsObject[.parentRule].fromJSValue()
    }
    
    public var cssFloat: String {
        get { jsObject[.cssFloat].fromJSValue()!}
        set { jsObject[.cssFloat] = newValue.jsValue }
    }
}

public class CSSStyleRule: CSSRule {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSStyleRule].function }
    
    public var selectorText: String {
        get { jsObject[.selectorText].fromJSValue()!}
        set { jsObject[.selectorText] = newValue.jsValue }
    }
    
    public var style: CSSStyleDeclaration {
        jsObject[.style].fromJSValue()!
    }
    
    public var styleMap: StylePropertyMap {
        jsObject[.styleMap].fromJSValue()!
    }
}

public class CSSStyleSheet: StyleSheet {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSStyleSheet].function }
    
    @inlinable public convenience init(options: CSSStyleSheetInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(options)]))
    }
    
    public var ownerRule: CSSRule? {
        jsObject[.ownerRule].fromJSValue()
    }
    
    public var cssRules: CSSRuleList {
        jsObject[.cssRules].fromJSValue()!
    }
    
    @inlinable public func insertRule(rule: String, index: UInt32? = nil) -> UInt32 {
        let this = jsObject
        return this[.insertRule].function!(this: this, arguments: [_toJSValue(rule), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func deleteRule(index: UInt32) {
        let this = jsObject
        _ = this[.deleteRule].function!(this: this, arguments: [_toJSValue(index)])
    }
    
    @inlinable public func replace(text: String) -> JSPromise {
        let this = jsObject
        return this[.replace].function!(this: this, arguments: [_toJSValue(text)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func replace(text: String) async throws -> CSSStyleSheet {
        let this = jsObject
        let _promise: JSPromise = this[.replace].function!(this: this, arguments: [_toJSValue(text)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
    
    @inlinable public func replaceSync(text: String) {
        let this = jsObject
        _ = this[.replaceSync].function!(this: this, arguments: [_toJSValue(text)])
    }
    
    public var rules: CSSRuleList {
        jsObject[.rules].fromJSValue()!
    }
    
    @inlinable public func addRule(selector: String? = nil, style: String? = nil, index: UInt32? = nil) -> Int32 {
        let this = jsObject
        return this[.addRule].function!(this: this, arguments: [_toJSValue(selector), _toJSValue(style), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func removeRule(index: UInt32? = nil) {
        let this = jsObject
        _ = this[.removeRule].function!(this: this, arguments: [_toJSValue(index)])
    }
}

public class CSSStyleSheetInit: BridgedDictionary {
    public convenience init(baseURL: String, media: MediaList_or_String, disabled: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.baseURL] = _toJSValue(baseURL)
        object[.media] = _toJSValue(media)
        object[.disabled] = _toJSValue(disabled)
        self.init(unsafelyWrapping: object)
    }
    
    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
    
    public var baseURL: String {
        get { jsObject[.baseURL].fromJSValue()!}
        set { jsObject[.baseURL] = newValue.jsValue }
    }
    
    public var media: MediaList_or_String {
        get { jsObject[.media].fromJSValue()!}
        set { jsObject[.media] = newValue.jsValue }
    }
    
    public var disabled: Bool {
        get { jsObject[.disabled].fromJSValue()!}
        set { jsObject[.disabled] = newValue.jsValue }
    }
}

public class CSSStyleValue: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CSSStyleValue].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public var description: String {
        jsObject[.toString]!().fromJSValue()!
    }
    
    @inlinable public class func parse(property: String, cssText: String) -> Self {
        let this = constructor!
        return this[.parse].function!(this: this, arguments: [_toJSValue(property), _toJSValue(cssText)]).fromJSValue()!
    }
    
    @inlinable public class func parseAll(property: String, cssText: String) -> [CSSStyleValue] {
        let this = constructor!
        return this[.parseAll].function!(this: this, arguments: [_toJSValue(property), _toJSValue(cssText)]).fromJSValue()!
    }
}

public class CSSTransformComponent: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CSSTransformComponent].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public var description: String {
        jsObject[.toString]!().fromJSValue()!
    }
    
    public var is2D: Bool {
        get { jsObject[.is2D].fromJSValue()!}
        set { jsObject[.is2D] = newValue.jsValue }
    }
    
    @inlinable public func toMatrix() -> DOMMatrix {
        let this = jsObject
        return this[.toMatrix].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class CSSTransformValue: CSSStyleValue, Sequence {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSTransformValue].function }
    
    @inlinable public convenience init(transforms: [CSSTransformComponent]) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(transforms)]))
    }
    
    public typealias Element = CSSTransformComponent
    public func makeIterator() -> ValueIterableIterator<CSSTransformValue> {
        ValueIterableIterator(sequence: self)
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> CSSTransformComponent {
        get {
            jsObject[key].fromJSValue()!
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }
    
    public var is2D: Bool {
        jsObject[.is2D].fromJSValue()!
    }
    
    @inlinable public func toMatrix() -> DOMMatrix {
        let this = jsObject
        return this[.toMatrix].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class CSSTranslate: CSSTransformComponent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSTranslate].function }
    
    @inlinable public convenience init(x: CSSNumericValue, y: CSSNumericValue, z: CSSNumericValue? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z)]))
    }
    
    public var x: CSSNumericValue {
        get { jsObject[.x].fromJSValue()!}
        set { jsObject[.x] = newValue.jsValue }
    }
    
    public var y: CSSNumericValue {
        get { jsObject[.y].fromJSValue()!}
        set { jsObject[.y] = newValue.jsValue }
    }
    
    public var z: CSSNumericValue {
        get { jsObject[.z].fromJSValue()!}
        set { jsObject[.z] = newValue.jsValue }
    }
}

public class CSSUnitValue: CSSNumericValue {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSUnitValue].function }
    
    @inlinable public convenience init(value: Double, unit: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(value), _toJSValue(unit)]))
    }
    
    public var value: Double {
        get { jsObject[.value].fromJSValue()!}
        set { jsObject[.value] = newValue.jsValue }
    }
    
    public var unit: String {
        jsObject[.unit].fromJSValue()!
    }
}

public class CSSUnparsedValue: CSSStyleValue, Sequence {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSUnparsedValue].function }
    
    @inlinable public convenience init(members: [CSSUnparsedSegment]) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(members)]))
    }
    
    public typealias Element = CSSUnparsedSegment
    public func makeIterator() -> ValueIterableIterator<CSSUnparsedValue> {
        ValueIterableIterator(sequence: self)
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> CSSUnparsedSegment {
        get {
            jsObject[key].fromJSValue()!
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }
}

public class CSSVariableReferenceValue: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CSSVariableReferenceValue].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public convenience init(variable: String, fallback: CSSUnparsedValue? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(variable), _toJSValue(fallback)]))
    }
    
    public var variable: String {
        get { jsObject[.variable].fromJSValue()!}
        set { jsObject[.variable] = newValue.jsValue }
    }
    
    public var fallback: CSSUnparsedValue? {
        jsObject[.fallback].fromJSValue()
    }
}

public class CaretPosition: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CaretPosition].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var offsetNode: Node {
        jsObject[.offsetNode].fromJSValue()!
    }
    
    public var offset: UInt32 {
        jsObject[.offset].fromJSValue()!
    }
    
    @inlinable public func getClientRect() -> DOMRect? {
        let this = jsObject
        return this[.getClientRect].function!(this: this, arguments: []).fromJSValue()
    }
}

public class CheckVisibilityOptions: BridgedDictionary {
    public convenience init(checkOpacity: Bool, checkVisibilityCSS: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.checkOpacity] = _toJSValue(checkOpacity)
        object[.checkVisibilityCSS] = _toJSValue(checkVisibilityCSS)
        self.init(unsafelyWrapping: object)
    }
    
    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
    
    public var checkOpacity: Bool {
        get { jsObject[.checkOpacity].fromJSValue()!}
        set { jsObject[.checkOpacity] = newValue.jsValue }
    }
    
    public var checkVisibilityCSS: Bool {
        get { jsObject[.checkVisibilityCSS].fromJSValue()!}
        set { jsObject[.checkVisibilityCSS] = newValue.jsValue }
    }
}

public class ConvertCoordinateOptions: BridgedDictionary {
    public convenience init(fromBox: CSSBoxType, toBox: CSSBoxType) {
        let object = JSObject.global[.Object].function!.new()
        object[.fromBox] = _toJSValue(fromBox)
        object[.toBox] = _toJSValue(toBox)
        self.init(unsafelyWrapping: object)
    }
    
    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
    
    public var fromBox: CSSBoxType {
        get { jsObject[.fromBox].fromJSValue()!}
        set { jsObject[.fromBox] = newValue.jsValue }
    }
    
    public var toBox: CSSBoxType {
        get { jsObject[.toBox].fromJSValue()!}
        set { jsObject[.toBox] = newValue.jsValue }
    }
}

public extension DocumentOrShadowRoot {
    @inlinable var styleSheets: StyleSheetList { jsObject[.styleSheets].fromJSValue()! }
    
    @inlinable var adoptedStyleSheets: [CSSStyleSheet] {
        get { jsObject[.adoptedStyleSheets].fromJSValue()! }
        nonmutating set { jsObject[.adoptedStyleSheets] = _toJSValue(newValue) }
    }
}

public protocol ElementCSSInlineStyle: JSBridgedClass {}
public extension ElementCSSInlineStyle {
    @inlinable var style: CSSStyleDeclaration { jsObject[.style].fromJSValue()! }
    
    @inlinable var attributeStyleMap: StylePropertyMap { jsObject[.attributeStyleMap].fromJSValue()! }
}

extension MathMLElement: ElementCSSInlineStyle {}

extension SVGElement: ElementCSSInlineStyle {}

public protocol GeometryUtils: JSBridgedClass {}
public extension GeometryUtils {
    @inlinable func getBoxQuads(options: BoxQuadOptions? = nil) -> [DOMQuad] {
        let this = jsObject
        return this[.getBoxQuads].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }
    
    @inlinable func convertQuadFromNode(quad: DOMQuadInit, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMQuad {
        let this = jsObject
        return this[.convertQuadFromNode].function!(this: this, arguments: [_toJSValue(quad), _toJSValue(from), _toJSValue(options)]).fromJSValue()!
    }
    
    @inlinable func convertRectFromNode(rect: DOMRectReadOnly, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMQuad {
        let this = jsObject
        return this[.convertRectFromNode].function!(this: this, arguments: [_toJSValue(rect), _toJSValue(from), _toJSValue(options)]).fromJSValue()!
    }
    
    @inlinable func convertPointFromNode(point: DOMPointInit, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMPoint {
        let this = jsObject
        return this[.convertPointFromNode].function!(this: this, arguments: [_toJSValue(point), _toJSValue(from), _toJSValue(options)]).fromJSValue()!
    }
}

extension CSSPseudoElement: GeometryUtils {}

extension Text: GeometryUtils {}

public protocol LinkStyle: JSBridgedClass {}
public extension LinkStyle {
    @inlinable var sheet: CSSStyleSheet? { jsObject[.sheet].fromJSValue() }
}

public class MediaList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.MediaList].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var mediaText: String {
        get { jsObject[.mediaText].fromJSValue()!}
        set { jsObject[.mediaText] = newValue.jsValue }
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> String? {
        jsObject[key].fromJSValue()
    }
    
    @inlinable public func item(index: UInt32) -> String? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
    
    @inlinable public func appendMedium(medium: String) {
        let this = jsObject
        _ = this[.appendMedium].function!(this: this, arguments: [_toJSValue(medium)])
    }
    
    @inlinable public func deleteMedium(medium: String) {
        let this = jsObject
        _ = this[.deleteMedium].function!(this: this, arguments: [_toJSValue(medium)])
    }
}

public class MediaQueryList: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaQueryList].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: .onchange)
        super.init(unsafelyWrapping: jsObject)
    }
    
    public var media: String {
        jsObject[.media].fromJSValue()!
    }
    
    public var matches: Bool {
        jsObject[.matches].fromJSValue()!
    }
    
    @inlinable public func addListener(callback: EventListener?) {
        let this = jsObject
        _ = this[.addListener].function!(this: this, arguments: [_toJSValue(callback)])
    }
    
    @inlinable public func removeListener(callback: EventListener?) {
        let this = jsObject
        _ = this[.removeListener].function!(this: this, arguments: [_toJSValue(callback)])
    }
    
    @ClosureAttribute1Optional
    public var onchange: EventHandler
}

public class MediaQueryListEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaQueryListEvent].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public convenience init(type: String, eventInitDict: MediaQueryListEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }
    
    public var media: String {
        jsObject[.media].fromJSValue()!
    }
    
    public var matches: Bool {
        jsObject[.matches].fromJSValue()!
    }
}

public class MediaQueryListEventInit: BridgedDictionary {
    public convenience init(media: String, matches: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.media] = _toJSValue(media)
        object[.matches] = _toJSValue(matches)
        self.init(unsafelyWrapping: object)
    }
    
    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
    
    public var media: String {
        get { jsObject[.media].fromJSValue()!}
        set { jsObject[.media] = newValue.jsValue }
    }
    
    public var matches: Bool {
        get { jsObject[.matches].fromJSValue()!}
        set { jsObject[.matches] = newValue.jsValue }
    }
}

public class Screen: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Screen].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var availWidth: Int32 {
        jsObject[.availWidth].fromJSValue()!
    }
    
    public var availHeight: Int32 {
        jsObject[.availHeight].fromJSValue()!
    }
    
    public var width: Int32 {
        jsObject[.width].fromJSValue()!
    }
    
    public var height: Int32 {
        jsObject[.height].fromJSValue()!
    }
    
    public var colorDepth: UInt32 {
        jsObject[.colorDepth].fromJSValue()!
    }
    
    public var pixelDepth: UInt32 {
        jsObject[.pixelDepth].fromJSValue()!
    }
}

public enum ScrollBehavior: JSString, JSValueCompatible {
    case auto = "auto"
    case instant = "instant"
    case smooth = "smooth"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ScrollIntoViewOptions: BridgedDictionary {
    public convenience init(block: ScrollLogicalPosition, inline: ScrollLogicalPosition) {
        let object = JSObject.global[.Object].function!.new()
        object[.block] = _toJSValue(block)
        object[.inline] = _toJSValue(inline)
        self.init(unsafelyWrapping: object)
    }
    
    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
    
    public var block: ScrollLogicalPosition {
        get { jsObject[.block].fromJSValue()!}
        set { jsObject[.block] = newValue.jsValue }
    }
    
    public var inline: ScrollLogicalPosition {
        get { jsObject[.inline].fromJSValue()!}
        set { jsObject[.inline] = newValue.jsValue }
    }
}

public enum ScrollLogicalPosition: JSString, JSValueCompatible {
    case start = "start"
    case center = "center"
    case end = "end"
    case nearest = "nearest"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ScrollOptions: BridgedDictionary {
    public convenience init(behavior: ScrollBehavior) {
        let object = JSObject.global[.Object].function!.new()
        object[.behavior] = _toJSValue(behavior)
        self.init(unsafelyWrapping: object)
    }
    
    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
    
    public var behavior: ScrollBehavior {
        get { jsObject[.behavior].fromJSValue()!}
        set { jsObject[.behavior] = newValue.jsValue }
    }
}

public class ScrollToOptions: BridgedDictionary {
    public convenience init(left: Double, top: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.left] = _toJSValue(left)
        object[.top] = _toJSValue(top)
        self.init(unsafelyWrapping: object)
    }
    
    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
    
    public var left: Double {
        get { jsObject[.left].fromJSValue()!}
        set { jsObject[.left] = newValue.jsValue }
    }
    
    public var top: Double {
        get { jsObject[.top].fromJSValue()!}
        set { jsObject[.top] = newValue.jsValue }
    }
}

public class StylePropertyMap: StylePropertyMapReadOnly {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.StylePropertyMap].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public func set(property: String, values: CSSStyleValue_or_String...) {
        let this = jsObject
        _ = this[.set].function!(this: this, arguments: [_toJSValue(property)] + values.map(_toJSValue))
    }
    
    @inlinable public func append(property: String, values: CSSStyleValue_or_String...) {
        let this = jsObject
        _ = this[.append].function!(this: this, arguments: [_toJSValue(property)] + values.map(_toJSValue))
    }
    
    @inlinable public func delete(property: String) {
        let this = jsObject
        _ = this[.delete].function!(this: this, arguments: [_toJSValue(property)])
    }
    
    @inlinable public func clear() {
        let this = jsObject
        _ = this[.clear].function!(this: this, arguments: [])
    }
}

public class StylePropertyMapReadOnly: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.StylePropertyMapReadOnly].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public typealias Element = String
    public func makeIterator() -> ValueIterableIterator<StylePropertyMapReadOnly> {
        ValueIterableIterator(sequence: self)
    }
    
    // TODO: remove patch once https://github.com/w3c/css-houdini-drafts/issues/1095 is fixed
    @inlinable public func get(property: String) -> CSSStyleValue? {
        let this = jsObject
        return this[.get].function!(this: this, arguments: [_toJSValue(property)]).fromJSValue()
    }
    
    @inlinable public func getAll(property: String) -> [CSSStyleValue] {
        let this = jsObject
        return this[.getAll].function!(this: this, arguments: [_toJSValue(property)]).fromJSValue()!
    }
    
    @inlinable public func has(property: String) -> Bool {
        let this = jsObject
        return this[.has].function!(this: this, arguments: [_toJSValue(property)]).fromJSValue()!
    }
    
    public var size: UInt32 {
        jsObject[.size].fromJSValue()!
    }
}

public class StyleSheet: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.StyleSheet].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var type: String {
        jsObject[.type].fromJSValue()!
    }
    
    public var href: String? {
        jsObject[.href].fromJSValue()
    }
    
    public var ownerNode: Element_or_ProcessingInstruction? {
        jsObject[.ownerNode].fromJSValue()
    }
    
    public var parentStyleSheet: CSSStyleSheet? {
        jsObject[.parentStyleSheet].fromJSValue()
    }
    
    public var title: String? {
        jsObject[.title].fromJSValue()
    }
    
    public var media: MediaList {
        jsObject[.media].fromJSValue()!
    }
    
    public var disabled: Bool {
        get { jsObject[.disabled].fromJSValue()!}
        set { jsObject[.disabled] = newValue.jsValue }
    }
}

public class StyleSheetList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.StyleSheetList].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public subscript(key: Int) -> CSSStyleSheet? {
        jsObject[key].fromJSValue()
    }
    
    @inlinable public func item(index: UInt32) -> CSSStyleSheet? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
}

public typealias CSSColorPercent = CSSColorRGBComp
public typealias CSSColorNumber = CSSColorRGBComp
public typealias CSSColorAngle = CSSColorRGBComp
public class VisualViewport: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.VisualViewport].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _onresize = ClosureAttribute1Optional(jsObject: jsObject, name: .onresize)
        _onscroll = ClosureAttribute1Optional(jsObject: jsObject, name:.onscroll)
        _onscrollend = ClosureAttribute1Optional(jsObject: jsObject, name: .onscrollend)
        super.init(unsafelyWrapping: jsObject)
    }
    
    public var offsetLeft: Double {
        jsObject[.offsetLeft].fromJSValue()!
    }
    
    public var offsetTop: Double {
         jsObject[.offsetTop].fromJSValue()!
    }
    
    public var pageLeft: Double {
        jsObject[.pageLeft].fromJSValue()!
    }
    
    public var pageTop: Double {
        jsObject[.pageTop].fromJSValue()!
    }
    
    public var width: Double {
        jsObject[.width].fromJSValue()!
    }
    
    public var height: Double {
        jsObject[.height].fromJSValue()!
    }
    
    public var scale: Double {
        jsObject[.scale].fromJSValue()!
    }
    
    @ClosureAttribute1Optional
    public var onresize: EventHandler
    
    @ClosureAttribute1Optional
    public var onscroll: EventHandler
    
    @ClosureAttribute1Optional
    public var onscrollend: EventHandler
}


public protocol Any_CSSColorRGBComp: ConvertibleToJSValue {}
extension CSSKeywordish: Any_CSSColorRGBComp {}
extension CSSNumberish: Any_CSSColorRGBComp {}

public enum CSSColorRGBComp: JSValueCompatible, Any_CSSColorRGBComp {
    case cssKeywordish(CSSKeywordish)
    case cssNumberish(CSSNumberish)
    
    init(_ cssKeywordish: CSSKeywordish) {
        let val: CSSColorRGBComp = .cssKeywordish(cssKeywordish)
        self = val
    }
    
    init(_ cssKeywordValue: CSSKeywordValue) {
        let val: CSSKeywordish = .cssKeywordValue(cssKeywordValue)
        self = .init(val)
    }
    
    init(_ string: String) {
        let val: CSSKeywordish = .string(string)
        self = .init(val)
    }
    
    init(_ cssNumberish: CSSNumberish) {
        let val: CSSColorRGBComp = .cssNumberish(cssNumberish)
        self = val
    }
    
    init(_ cssNumericValue: CSSNumericValue) {
        let val: CSSNumberish = .cssNumericValue(cssNumericValue)
        self = .init(val)
    }
    
    init(_ double: Double) {
        let val: CSSNumberish = .double(double)
        self = .init(val)
    }
    
    public var cssKeywordish: CSSKeywordish? {
        switch self {
        case let .cssKeywordish(cssKeywordish): return cssKeywordish
        default: return nil
        }
    }
    
    public var cssNumberish: CSSNumberish? {
        switch self {
        case let .cssNumberish(cssNumberish): return cssNumberish
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let cssKeywordish: CSSKeywordish = value.fromJSValue() {
            return .cssKeywordish(cssKeywordish)
        }
        if let cssNumberish: CSSNumberish = value.fromJSValue() {
            return .cssNumberish(cssNumberish)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .cssKeywordish(cssKeywordish):
            return cssKeywordish.jsValue
        case let .cssNumberish(cssNumberish):
            return cssNumberish.jsValue
        }
    }
}

public protocol Any_CSSKeywordish: ConvertibleToJSValue {}
extension CSSKeywordValue: Any_CSSKeywordish {}
extension String: Any_CSSKeywordish {}

public enum CSSKeywordish: JSValueCompatible, Any_CSSKeywordish {
    case cssKeywordValue(CSSKeywordValue)
    case string(String)
    
    init(_ cssKeywordValue: CSSKeywordValue) {
        let val: CSSKeywordish = .cssKeywordValue(cssKeywordValue)
        self = val
    }
    
    init(_ string: String) {
        let val: CSSKeywordish = .string(string)
        self = val
    }
    
    public var cssKeywordValue: CSSKeywordValue? {
        switch self {
        case let .cssKeywordValue(cssKeywordValue): return cssKeywordValue
        default: return nil
        }
    }
    
    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let cssKeywordValue: CSSKeywordValue = value.fromJSValue() {
            return .cssKeywordValue(cssKeywordValue)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .cssKeywordValue(cssKeywordValue):
            return cssKeywordValue.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_CSSNumberish: ConvertibleToJSValue {}
extension CSSNumericValue: Any_CSSNumberish {}
extension Double: Any_CSSNumberish {}

public enum CSSNumberish: JSValueCompatible, Any_CSSNumberish {
    case cssNumericValue(CSSNumericValue)
    case double(Double)
    
    init(_ cssNumericValue: CSSNumericValue) {
        let val: CSSNumberish = .cssNumericValue(cssNumericValue)
        self = val
    }
    
    init(_ double: Double) {
        let val: CSSNumberish = .double(double)
        self = val
    }
    
    public var cssNumericValue: CSSNumericValue? {
        switch self {
        case let .cssNumericValue(cssNumericValue): return cssNumericValue
        default: return nil
        }
    }
    
    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let cssNumericValue: CSSNumericValue = value.fromJSValue() {
            return .cssNumericValue(cssNumericValue)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .cssNumericValue(cssNumericValue):
            return cssNumericValue.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}

public protocol Any_CSSPerspectiveValue: ConvertibleToJSValue {}
extension CSSKeywordish: Any_CSSPerspectiveValue {}
extension CSSNumericValue: Any_CSSPerspectiveValue {}

public enum CSSPerspectiveValue: JSValueCompatible, Any_CSSPerspectiveValue {
    case cssKeywordish(CSSKeywordish)
    case cssNumericValue(CSSNumericValue)
    
    init(_ cssKeywordish: CSSKeywordish) {
        let val: CSSPerspectiveValue = .cssKeywordish(cssKeywordish)
        self = val
    }
    
    init(_ cssKeywordValue: CSSKeywordValue) {
        let val: CSSKeywordish = .cssKeywordValue(cssKeywordValue)
        self = .init(val)
    }
    
    init(_ string: String) {
        let val: CSSKeywordish = .string(string)
        self = .init(val)
    }
    
    init(_ cssNumericValue: CSSNumericValue) {
        let val: CSSPerspectiveValue = .cssNumericValue(cssNumericValue)
        self = val
    }
    
    public var cssKeywordish: CSSKeywordish? {
        switch self {
        case let .cssKeywordish(cssKeywordish): return cssKeywordish
        default: return nil
        }
    }
    
    public var cssNumericValue: CSSNumericValue? {
        switch self {
        case let .cssNumericValue(cssNumericValue): return cssNumericValue
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let cssKeywordish: CSSKeywordish = value.fromJSValue() {
            return .cssKeywordish(cssKeywordish)
        }
        if let cssNumericValue: CSSNumericValue = value.fromJSValue() {
            return .cssNumericValue(cssNumericValue)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .cssKeywordish(cssKeywordish):
            return cssKeywordish.jsValue
        case let .cssNumericValue(cssNumericValue):
            return cssNumericValue.jsValue
        }
    }
}

public protocol Any_CSSStyleValue_or_String: ConvertibleToJSValue {}
extension CSSStyleValue: Any_CSSStyleValue_or_String {}
extension String: Any_CSSStyleValue_or_String {}

public enum CSSStyleValue_or_String: JSValueCompatible, Any_CSSStyleValue_or_String {
    case cssStyleValue(CSSStyleValue)
    case string(String)
    
    init(_ cssStyleValue: CSSStyleValue) {
        let val: CSSStyleValue_or_String = .cssStyleValue(cssStyleValue)
        self = val
    }
    
    init(_ string: String) {
        let val: CSSStyleValue_or_String = .string(string)
        self = val
    }
    
    public var cssStyleValue: CSSStyleValue? {
        switch self {
        case let .cssStyleValue(cssStyleValue): return cssStyleValue
        default: return nil
        }
    }
    
    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let cssStyleValue: CSSStyleValue = value.fromJSValue() {
            return .cssStyleValue(cssStyleValue)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .cssStyleValue(cssStyleValue):
            return cssStyleValue.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_CSSUnparsedSegment: ConvertibleToJSValue {}
extension CSSVariableReferenceValue: Any_CSSUnparsedSegment {}
extension String: Any_CSSUnparsedSegment {}

public enum CSSUnparsedSegment: JSValueCompatible, Any_CSSUnparsedSegment {
    case cssVariableReferenceValue(CSSVariableReferenceValue)
    case string(String)
    
    init(_ cssVariableReferenceValue: CSSVariableReferenceValue) {
        let val: CSSUnparsedSegment = .cssVariableReferenceValue(cssVariableReferenceValue)
        self = val
    }
    
    init(_ string: String) {
        let val: CSSUnparsedSegment = .string(string)
        self = val
    }
    
    public var cssVariableReferenceValue: CSSVariableReferenceValue? {
        switch self {
        case let .cssVariableReferenceValue(cssVariableReferenceValue): return cssVariableReferenceValue
        default: return nil
        }
    }
    
    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let cssVariableReferenceValue: CSSVariableReferenceValue = value.fromJSValue() {
            return .cssVariableReferenceValue(cssVariableReferenceValue)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .cssVariableReferenceValue(cssVariableReferenceValue):
            return cssVariableReferenceValue.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Element_or_ProcessingInstruction: ConvertibleToJSValue {}
extension Element: Any_Element_or_ProcessingInstruction {}
extension ProcessingInstruction: Any_Element_or_ProcessingInstruction {}

public enum Element_or_ProcessingInstruction: JSValueCompatible, Any_Element_or_ProcessingInstruction {
    case element(Element)
    case processingInstruction(ProcessingInstruction)
    
    init(_ element: Element) {
        let val: Element_or_ProcessingInstruction = .element(element)
        self = val
    }
    
    init(_ processingInstruction: ProcessingInstruction) {
        let val: Element_or_ProcessingInstruction = .processingInstruction(processingInstruction)
        self = val
    }
    
    public var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }
    
    public var processingInstruction: ProcessingInstruction? {
        switch self {
        case let .processingInstruction(processingInstruction): return processingInstruction
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let processingInstruction: ProcessingInstruction = value.fromJSValue() {
            return .processingInstruction(processingInstruction)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .processingInstruction(processingInstruction):
            return processingInstruction.jsValue
        }
    }
}

public enum GeometryNode: JSValueCompatible {
    case cssPseudoElement(CSSPseudoElement)
    case document(Document)
    case element(Element)
    case text(Text)
    
    public static func construct(from value: JSValue) -> Self? {
        if let cssPseudoElement: CSSPseudoElement = value.fromJSValue() {
            return .cssPseudoElement(cssPseudoElement)
        }
        if let document: Document = value.fromJSValue() {
            return .document(document)
        }
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let text: Text = value.fromJSValue() {
            return .text(text)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .cssPseudoElement(cssPseudoElement):
            return cssPseudoElement.jsValue
        case let .document(document):
            return document.jsValue
        case let .element(element):
            return element.jsValue
        case let .text(text):
            return text.jsValue
        }
    }
}

public protocol Any_MediaList_or_String: ConvertibleToJSValue {}
extension MediaList: Any_MediaList_or_String {}
extension String: Any_MediaList_or_String {}

public enum MediaList_or_String: JSValueCompatible, Any_MediaList_or_String {
    case mediaList(MediaList)
    case string(String)
    
    init(_ mediaList: MediaList) {
        let val: MediaList_or_String = .mediaList(mediaList)
        self = val
    }
    
    init(_ string: String) {
        let val: MediaList_or_String = .string(string)
        self = val
    }
    
    public var mediaList: MediaList? {
        switch self {
        case let .mediaList(mediaList): return mediaList
        default: return nil
        }
    }
    
    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let mediaList: MediaList = value.fromJSValue() {
            return .mediaList(mediaList)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .mediaList(mediaList):
            return mediaList.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}
