// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptEventLoop
import JavaScriptKit
import WebAPIBase

public protocol GetSVGDocument: JSBridgedClass {}
public extension GetSVGDocument {
    @inlinable func getSVGDocument() -> Document {
        let this = jsObject
        return this[.getSVGDocument].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class SVGAElement: SVGGraphicsElement, SVGURIReference {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGAElement].function }
    
    public var target: SVGAnimatedString {
        jsObject[.target].fromJSValue()!
    }
    
    public var download: String {
        get { jsObject[.download].fromJSValue()!}
        set { jsObject[.download] = newValue.jsValue }
    }
    
    public var ping: String {
        get { jsObject[.ping].fromJSValue()!}
        set { jsObject[.ping] = newValue.jsValue }
    }
    
    public var rel: String {
        get { jsObject[.rel].fromJSValue()!}
        set { jsObject[.rel] = newValue.jsValue }
    }
    
    public var relList: DOMTokenList {
        jsObject[.relList].fromJSValue()!
    }
    
    public var hreflang: String {
        get { jsObject[.hreflang].fromJSValue()!}
        set { jsObject[.hreflang] = newValue.jsValue }
    }
    
    public var type: String {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
    
    public var text: String {
        get { jsObject[.text].fromJSValue()!}
        set { jsObject[.text] = newValue.jsValue }
    }
    
    public var referrerPolicy: String {
        get { jsObject[.referrerPolicy].fromJSValue()!}
        set { jsObject[.referrerPolicy] = newValue.jsValue }
    }
    
    public var origin: String {
        jsObject[.origin].fromJSValue()!
    }
    
    public var `protocol`: String {
        get { jsObject[.`protocol`].fromJSValue()!}
        set { jsObject[.`protocol`] = newValue.jsValue }
    }
    
    public var username: String {
        get { jsObject[.username].fromJSValue()!}
        set { jsObject[.username] = newValue.jsValue }
    }
    
    public var password: String {
        get { jsObject[.password].fromJSValue()!}
        set { jsObject[.password] = newValue.jsValue }
    }
    
    public var host: String {
        get { jsObject[.host].fromJSValue()!}
        set { jsObject[.host] = newValue.jsValue }
    }
    
    public var hostname: String {
        get { jsObject[.hostname].fromJSValue()!}
        set { jsObject[.hostname] = newValue.jsValue }
    }
    
    public var port: String {
        get { jsObject[.port].fromJSValue()!}
        set { jsObject[.port] = newValue.jsValue }
    }
    
    public var pathname: String {
        get { jsObject[.pathname].fromJSValue()!}
        set { jsObject[.pathname] = newValue.jsValue }
    }
    
    public var search: String {
        get { jsObject[.search].fromJSValue()!}
        set { jsObject[.search] = newValue.jsValue }
    }
    
    public var hash: String {
        get { jsObject[.hash].fromJSValue()!}
        set { jsObject[.hash] = newValue.jsValue }
    }
}

public class SVGAngle: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAngle].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public static let SVG_ANGLETYPE_UNKNOWN: UInt16 = 0
    
    public static let SVG_ANGLETYPE_UNSPECIFIED: UInt16 = 1
    
    public static let SVG_ANGLETYPE_DEG: UInt16 = 2
    
    public static let SVG_ANGLETYPE_RAD: UInt16 = 3
    
    public static let SVG_ANGLETYPE_GRAD: UInt16 = 4
    
    public var unitType: UInt16 {
        jsObject[.unitType].fromJSValue()!
    }
    
    public var value: Float {
        get { jsObject[.value].fromJSValue()!}
        set { jsObject[.value] = newValue.jsValue }
    }
    
    public var valueInSpecifiedUnits: Float {
        get { jsObject[.valueInSpecifiedUnits].fromJSValue()!}
        set { jsObject[.valueInSpecifiedUnits] = newValue.jsValue }
    }
    
    public var valueAsString: String {
        get { jsObject[.valueAsString].fromJSValue()!}
        set { jsObject[.valueAsString] = newValue.jsValue }
    }
    
    @inlinable public func newValueSpecifiedUnits(unitType: UInt16, valueInSpecifiedUnits: Float) {
        let this = jsObject
        _ = this[.newValueSpecifiedUnits].function!(this: this, arguments: [_toJSValue(unitType), _toJSValue(valueInSpecifiedUnits)])
    }
    
    @inlinable public func convertToSpecifiedUnits(unitType: UInt16) {
        let this = jsObject
        _ = this[.convertToSpecifiedUnits].function!(this: this, arguments: [_toJSValue(unitType)])
    }
}

public class SVGAnimateElement: SVGAnimationElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGAnimateElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGAnimateMotionElement: SVGAnimationElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGAnimateMotionElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGAnimateTransformElement: SVGAnimationElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGAnimateTransformElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGAnimatedAngle: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedAngle].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: SVGAngle {
        jsObject[.baseVal].fromJSValue()!
    }
    
    public var animVal: SVGAngle {
        jsObject[.animVal].fromJSValue()!
    }
}

public class SVGAnimatedBoolean: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedBoolean].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: Bool {
        get { jsObject[.baseVal].fromJSValue()!}
        set { jsObject[.baseVal] = newValue.jsValue }
    }
    
    public var animVal: Bool {
        jsObject[.animVal].fromJSValue()!
    }
}

public class SVGAnimatedEnumeration: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedEnumeration].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: UInt16 {
        get { jsObject[.baseVal].fromJSValue()!}
        set { jsObject[.baseVal] = newValue.jsValue }
    }
    
    public var animVal: UInt16 {
        jsObject[.animVal].fromJSValue()!
    }
}

public class SVGAnimatedInteger: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedInteger].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: Int32 {
        get { jsObject[.baseVal].fromJSValue()!}
        set { jsObject[.baseVal] = newValue.jsValue }
    }
    
    public var animVal: Int32 {
        jsObject[.animVal].fromJSValue()!
    }
}

public class SVGAnimatedLength: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedLength].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: SVGLength {
        jsObject[.baseVal].fromJSValue()!
    }
    
    public var animVal: SVGLength {
        jsObject[.animVal].fromJSValue()!
    }
}

public class SVGAnimatedLengthList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedLengthList].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: SVGLengthList {
        jsObject[.baseVal].fromJSValue()!
    }
    
    public var animVal: SVGLengthList {
        jsObject[.animVal].fromJSValue()!
    }
}

public class SVGAnimatedNumber: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedNumber].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: Float {
        get { jsObject[.baseVal].fromJSValue()!}
        set { jsObject[.baseVal] = newValue.jsValue }
    }
    
    public var animVal: Float {
        jsObject[.animVal].fromJSValue()!
    }
}

public class SVGAnimatedNumberList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedNumberList].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: SVGNumberList {
        jsObject[.baseVal].fromJSValue()!
    }
    
    public var animVal: SVGNumberList {
        jsObject[.animVal].fromJSValue()!
    }
}

public protocol SVGAnimatedPoints: JSBridgedClass {}
public extension SVGAnimatedPoints {
    @inlinable var points: SVGPointList { jsObject[.points].fromJSValue()! }
    
    @inlinable var animatedPoints: SVGPointList { jsObject[.animatedPoints].fromJSValue()! }
}

public class SVGAnimatedPreserveAspectRatio: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedPreserveAspectRatio].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: SVGPreserveAspectRatio {
        jsObject[.baseVal].fromJSValue()!
    }
    
    public var animVal: SVGPreserveAspectRatio {
        jsObject[.animVal].fromJSValue()!
    }
}

public class SVGAnimatedRect: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedRect].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: DOMRect {
        jsObject[.baseVal].fromJSValue()!
    }
    
    public var animVal: DOMRectReadOnly {
        jsObject[.animVal].fromJSValue()!
    }
}

public class SVGAnimatedString: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedString].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: String {
        get { jsObject[.baseVal].fromJSValue()!}
        set { jsObject[.baseVal] = newValue.jsValue }
    }
    
    public var animVal: String {
        jsObject[.animVal].fromJSValue()!
    }
}

public class SVGAnimatedTransformList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGAnimatedTransformList].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var baseVal: SVGTransformList {
        jsObject[.baseVal].fromJSValue()!
    }
    
    public var animVal: SVGTransformList {
        jsObject[.animVal].fromJSValue()!
    }
}

public class SVGAnimationElement: SVGElement, SVGTests {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGAnimationElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _onbegin = ClosureAttribute1Optional(jsObject: jsObject, name: .onbegin)
        _onend = ClosureAttribute1Optional(jsObject: jsObject, name: .onend)
        _onrepeat = ClosureAttribute1Optional(jsObject: jsObject, name: .onrepeat)
        super.init(unsafelyWrapping: jsObject)
    }
    
    public var targetElement: SVGElement? {
        jsObject[.targetElement].fromJSValue()
    }
    
    @ClosureAttribute1Optional
    public var onbegin: EventHandler
    
    @ClosureAttribute1Optional
    public var onend: EventHandler
    
    @ClosureAttribute1Optional
    public var onrepeat: EventHandler
    
    @inlinable public func getStartTime() -> Float {
        let this = jsObject
        return this[.getStartTime].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func getCurrentTime() -> Float {
        let this = jsObject
        return this[.getCurrentTime].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func getSimpleDuration() -> Float {
        let this = jsObject
        return this[.getSimpleDuration].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func beginElement() {
        let this = jsObject
        _ = this[.beginElement].function!(this: this, arguments: [])
    }
    
    @inlinable public func beginElementAt(offset: Float) {
        let this = jsObject
        _ = this[.beginElementAt].function!(this: this, arguments: [_toJSValue(offset)])
    }
    
    @inlinable public func endElement() {
        let this = jsObject
        _ = this[.endElement].function!(this: this, arguments: [])
    }
    
    @inlinable public func endElementAt(offset: Float) {
        let this = jsObject
        _ = this[.endElementAt].function!(this: this, arguments: [_toJSValue(offset)])
    }
}

public class SVGBoundingBoxOptions: BridgedDictionary {
    public convenience init(fill: Bool, stroke: Bool, markers: Bool, clipped: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.fill] = _toJSValue(fill)
        object[.stroke] = _toJSValue(stroke)
        object[.markers] = _toJSValue(markers)
        object[.clipped] = _toJSValue(clipped)
        self.init(unsafelyWrapping: object)
    }
    
    public var fill: Bool {
        get { jsObject[.fill].fromJSValue()!}
        set { jsObject[.fill] = newValue.jsValue }
    }
    
    public var stroke: Bool {
        get { jsObject[.stroke].fromJSValue()!}
        set { jsObject[.stroke] = newValue.jsValue }
    }
    
    public var markers: Bool {
        get { jsObject[.markers].fromJSValue()!}
        set { jsObject[.markers] = newValue.jsValue }
    }
    
    public var clipped: Bool {
        get { jsObject[.clipped].fromJSValue()!}
        set { jsObject[.clipped] = newValue.jsValue }
    }
}

public class SVGCircleElement: SVGGeometryElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGCircleElement].function }
    
    public var cx: SVGAnimatedLength {
        jsObject[.cx].fromJSValue()!
    }
    
    public var cy: SVGAnimatedLength {
        jsObject[.cy].fromJSValue()!
    }
    
    public var r: SVGAnimatedLength {
        jsObject[.r].fromJSValue()!
    }
}

public class SVGClipPathElement: SVGElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGClipPathElement].function }
    
    public var clipPathUnits: SVGAnimatedEnumeration {
        jsObject[.clipPathUnits].fromJSValue()!
    }
    
    public var transform: SVGAnimatedTransformList {
        jsObject[.transform].fromJSValue()!
    }
}

public class SVGDefsElement: SVGGraphicsElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGDefsElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGDescElement: SVGElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGDescElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGDiscardElement: SVGAnimationElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGDiscardElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGElement: Element,
                            GlobalEventHandlers,
                         SVGElementInstance,
                         HTMLOrSVGElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGElement].function }
    
    // Renamed because superclass has a `className` property of type `String`
    // NOTE! Accessing `className` on an SVGElement will crash your app
    public var svgClassName: SVGAnimatedString {
        jsObject[.className].fromJSValue()!
    }
    
    public var ownerSVGElement: SVGSVGElement? {
        jsObject[.ownerSVGElement].fromJSValue()
    }
    
    public var viewportElement: SVGElement? {
        jsObject[.viewportElement].fromJSValue()
    }
}

public protocol SVGElementInstance: JSBridgedClass {}
public extension SVGElementInstance {
    @inlinable var correspondingElement: SVGElement? { jsObject[.correspondingElement].fromJSValue() }
    
    @inlinable var correspondingUseElement: SVGUseElement? { jsObject[.correspondingUseElement].fromJSValue() }
}

public class SVGEllipseElement: SVGGeometryElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGEllipseElement].function }
    
    public var cx: SVGAnimatedLength {
        jsObject[.cx].fromJSValue()!
    }
    
    public var cy: SVGAnimatedLength {
        jsObject[.cy].fromJSValue()!
    }
    
    public var rx: SVGAnimatedLength {
        jsObject[.rx].fromJSValue()!
    }
    
    public var ry: SVGAnimatedLength {
        jsObject[.ry].fromJSValue()!
    }
}

public protocol SVGFitToViewBox: JSBridgedClass {}
public extension SVGFitToViewBox {
    @inlinable var viewBox: SVGAnimatedRect { jsObject[.viewBox].fromJSValue()! }
    
    @inlinable var preserveAspectRatio: SVGAnimatedPreserveAspectRatio { jsObject[.preserveAspectRatio].fromJSValue()! }
}

public class SVGForeignObjectElement: SVGGraphicsElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGForeignObjectElement].function }
    
    public var x: SVGAnimatedLength {
        jsObject[.x].fromJSValue()!
    }
    
    public var y: SVGAnimatedLength {
        jsObject[.y].fromJSValue()!
    }
    
    public var width: SVGAnimatedLength {
        jsObject[.width].fromJSValue()!
    }
    
    public var height: SVGAnimatedLength {
        jsObject[.height].fromJSValue()!
    }
}

public class SVGGElement: SVGGraphicsElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGGElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGGeometryElement: SVGGraphicsElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGGeometryElement].function }
    
    public var pathLength: SVGAnimatedNumber {
        jsObject[.pathLength].fromJSValue()!
    }
    
    @inlinable public func isPointInFill(point: DOMPointInit? = nil) -> Bool {
        let this = jsObject
        return this[.isPointInFill].function!(this: this, arguments: [_toJSValue(point)]).fromJSValue()!
    }
    
    @inlinable public func isPointInStroke(point: DOMPointInit? = nil) -> Bool {
        let this = jsObject
        return this[.isPointInStroke].function!(this: this, arguments: [_toJSValue(point)]).fromJSValue()!
    }
    
    @inlinable public func getTotalLength() -> Float {
        let this = jsObject
        return this[.getTotalLength].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func getPointAtLength(distance: Float) -> DOMPoint {
        let this = jsObject
        return this[.getPointAtLength].function!(this: this, arguments: [_toJSValue(distance)]).fromJSValue()!
    }
}

public class SVGGradientElement: SVGElement, SVGURIReference {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGGradientElement].function }
    
    public static let SVG_SPREADMETHOD_UNKNOWN: UInt16 = 0
    
    public static let SVG_SPREADMETHOD_PAD: UInt16 = 1
    
    public static let SVG_SPREADMETHOD_REFLECT: UInt16 = 2
    
    public static let SVG_SPREADMETHOD_REPEAT: UInt16 = 3
    
    public var gradientUnits: SVGAnimatedEnumeration {
        jsObject[.gradientUnits].fromJSValue()!
    }
    
    public var gradientTransform: SVGAnimatedTransformList {
        jsObject[.gradientTransform].fromJSValue()!
    }
    
    public var spreadMethod: SVGAnimatedEnumeration {
        jsObject[.spreadMethod].fromJSValue()!
    }
}

public class SVGGraphicsElement: SVGElement, SVGTests {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGGraphicsElement].function }
    
    public var transform: SVGAnimatedTransformList {
        jsObject[.transform].fromJSValue()!
    }
    
    @inlinable public func getBBox(options: SVGBoundingBoxOptions? = nil) -> DOMRect {
        let this = jsObject
        return this[.getBBox].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }
    
    @inlinable public func getCTM() -> DOMMatrix? {
        let this = jsObject
        return this[.getCTM].function!(this: this, arguments: []).fromJSValue()
    }
    
    @inlinable public func getScreenCTM() -> DOMMatrix? {
        let this = jsObject
        return this[.getScreenCTM].function!(this: this, arguments: []).fromJSValue()
    }
}

public class SVGImageElement: SVGGraphicsElement, SVGURIReference {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGImageElement].function }
    
    public var x: SVGAnimatedLength {
        jsObject[.x].fromJSValue()!
    }
    
    public var y: SVGAnimatedLength {
        jsObject[.y].fromJSValue()!
    }
    
    public var width: SVGAnimatedLength {
        jsObject[.width].fromJSValue()!
    }
    
    public var height: SVGAnimatedLength {
        jsObject[.height].fromJSValue()!
    }
    
    public var preserveAspectRatio: SVGAnimatedPreserveAspectRatio {
        jsObject[.preserveAspectRatio].fromJSValue()!
    }
    
    public var crossOrigin: String? {
        get { jsObject[.crossOrigin].fromJSValue()}
        set { jsObject[.crossOrigin] = newValue.jsValue }
    }
}

public class SVGLength: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGLength].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public static let SVG_LENGTHTYPE_UNKNOWN: UInt16 = 0
    
    public static let SVG_LENGTHTYPE_NUMBER: UInt16 = 1
    
    public static let SVG_LENGTHTYPE_PERCENTAGE: UInt16 = 2
    
    public static let SVG_LENGTHTYPE_EMS: UInt16 = 3
    
    public static let SVG_LENGTHTYPE_EXS: UInt16 = 4
    
    public static let SVG_LENGTHTYPE_PX: UInt16 = 5
    
    public static let SVG_LENGTHTYPE_CM: UInt16 = 6
    
    public static let SVG_LENGTHTYPE_MM: UInt16 = 7
    
    public static let SVG_LENGTHTYPE_IN: UInt16 = 8
    
    public static let SVG_LENGTHTYPE_PT: UInt16 = 9
    
    public static let SVG_LENGTHTYPE_PC: UInt16 = 10
    
    public var unitType: UInt16 {
        jsObject[.unitType].fromJSValue()!
    }
    
    public var value: Float {
        get { jsObject[.value].fromJSValue()!}
        set { jsObject[.value] = newValue.jsValue }
    }
    
    public var valueInSpecifiedUnits: Float {
        get { jsObject[.valueInSpecifiedUnits].fromJSValue()!}
        set { jsObject[.valueInSpecifiedUnits] = newValue.jsValue }
    }
    
    public var valueAsString: String {
        get { jsObject[.valueAsString].fromJSValue()!}
        set { jsObject[.valueAsString] = newValue.jsValue }
    }
    
    @inlinable public func newValueSpecifiedUnits(unitType: UInt16, valueInSpecifiedUnits: Float) {
        let this = jsObject
        _ = this[.newValueSpecifiedUnits].function!(this: this, arguments: [_toJSValue(unitType), _toJSValue(valueInSpecifiedUnits)])
    }
    
    @inlinable public func convertToSpecifiedUnits(unitType: UInt16) {
        let this = jsObject
        _ = this[.convertToSpecifiedUnits].function!(this: this, arguments: [_toJSValue(unitType)])
    }
}

public class SVGLengthList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGLengthList].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    public var numberOfItems: UInt32 {
        jsObject[.numberOfItems].fromJSValue()!
    }
    
    @inlinable public func clear() {
        let this = jsObject
        _ = this[.clear].function!(this: this, arguments: [])
    }
    
    @inlinable public func initialize(newItem: SVGLength) -> SVGLength {
        let this = jsObject
        return this[.initialize].function!(this: this, arguments: [_toJSValue(newItem)]).fromJSValue()!
    }
    
    @inlinable public func getItem(index: UInt32) -> SVGLength {
        let this = jsObject
        return this[.getItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func insertItemBefore(newItem: SVGLength, index: UInt32) -> SVGLength {
        let this = jsObject
        return this[.insertItemBefore].function!(this: this, arguments: [_toJSValue(newItem), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func replaceItem(newItem: SVGLength, index: UInt32) -> SVGLength {
        let this = jsObject
        return this[.replaceItem].function!(this: this, arguments: [_toJSValue(newItem), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func removeItem(index: UInt32) -> SVGLength {
        let this = jsObject
        return this[.removeItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func appendItem(newItem: SVGLength) -> SVGLength {
        let this = jsObject
        return this[.appendItem].function!(this: this, arguments: [_toJSValue(newItem)]).fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> SVGLength {
        get {
            jsObject[key].fromJSValue()!
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }
}

public class SVGLineElement: SVGGeometryElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGLineElement].function }
    
    public var x1: SVGAnimatedLength {
        jsObject[.x1].fromJSValue()!
    }
    
    public var y1: SVGAnimatedLength {
        jsObject[.y1].fromJSValue()!
    }
    
    public var x2: SVGAnimatedLength {
        jsObject[.x2].fromJSValue()!
    }
    
    public var y2: SVGAnimatedLength {
        jsObject[.y2].fromJSValue()!
    }
}

public class SVGLinearGradientElement: SVGGradientElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGLinearGradientElement].function }
    
    public var x1: SVGAnimatedLength {
        jsObject[.x1].fromJSValue()!
    }
    
    public var y1: SVGAnimatedLength {
        jsObject[.y1].fromJSValue()!
    }
    
    public var x2: SVGAnimatedLength {
        jsObject[.x2].fromJSValue()!
    }
    
    public var y2: SVGAnimatedLength {
        jsObject[.y2].fromJSValue()!
    }
}

public class SVGMPathElement: SVGElement, SVGURIReference {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGMPathElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGMarkerElement: SVGElement, SVGFitToViewBox {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGMarkerElement].function }
    
    public static let SVG_MARKERUNITS_UNKNOWN: UInt16 = 0
    
    public static let SVG_MARKERUNITS_USERSPACEONUSE: UInt16 = 1
    
    public static let SVG_MARKERUNITS_STROKEWIDTH: UInt16 = 2
    
    public static let SVG_MARKER_ORIENT_UNKNOWN: UInt16 = 0
    
    public static let SVG_MARKER_ORIENT_AUTO: UInt16 = 1
    
    public static let SVG_MARKER_ORIENT_ANGLE: UInt16 = 2
    
    public var refX: SVGAnimatedLength {
        jsObject[.refX].fromJSValue()!
    }
    
    public var refY: SVGAnimatedLength {
        jsObject[.refY].fromJSValue()!
    }
    
    public var markerUnits: SVGAnimatedEnumeration {
        jsObject[.markerUnits].fromJSValue()!
    }
    
    public var markerWidth: SVGAnimatedLength {
        jsObject[.markerWidth].fromJSValue()!
    }
    
    public var markerHeight: SVGAnimatedLength {
        jsObject[.markerHeight].fromJSValue()!
    }
    
    public var orientType: SVGAnimatedEnumeration {
        jsObject[.orientType].fromJSValue()!
    }
    
    public var orientAngle: SVGAnimatedAngle {
        jsObject[.orientAngle].fromJSValue()!
    }
    
    public var orient: String {
        get { jsObject[.orient].fromJSValue()!}
        set { jsObject[.orient] = newValue.jsValue }
    }
    
    @inlinable public func setOrientToAuto() {
        let this = jsObject
        _ = this[.setOrientToAuto].function!(this: this, arguments: [])
    }
    
    @inlinable public func setOrientToAngle(angle: SVGAngle) {
        let this = jsObject
        _ = this[.setOrientToAngle].function!(this: this, arguments: [_toJSValue(angle)])
    }
}

public class SVGMaskElement: SVGElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGMaskElement].function }
    
    public var maskUnits: SVGAnimatedEnumeration {
        jsObject[.maskUnits].fromJSValue()!
    }
    
    public var maskContentUnits: SVGAnimatedEnumeration {
        jsObject[.maskContentUnits].fromJSValue()!
    }
    
    public var x: SVGAnimatedLength {
        jsObject[.x].fromJSValue()!
    }
    
    public var y: SVGAnimatedLength {
        jsObject[.y].fromJSValue()!
    }
    
    public var width: SVGAnimatedLength {
        jsObject[.width].fromJSValue()!
    }
    
    public var height: SVGAnimatedLength {
        jsObject[.height].fromJSValue()!
    }
}

public class SVGMetadataElement: SVGElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGMetadataElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGNumber: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGNumber].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var value: Float {
        get { jsObject[.value].fromJSValue()!}
        set { jsObject[.value] = newValue.jsValue }
    }
}

public class SVGNumberList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGNumberList].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    public var numberOfItems: UInt32 {
        jsObject[.numberOfItems].fromJSValue()!
    }
    
    @inlinable public func clear() {
        let this = jsObject
        _ = this[.clear].function!(this: this, arguments: [])
    }
    
    @inlinable public func initialize(newItem: SVGNumber) -> SVGNumber {
        let this = jsObject
        return this[.initialize].function!(this: this, arguments: [_toJSValue(newItem)]).fromJSValue()!
    }
    
    @inlinable public func getItem(index: UInt32) -> SVGNumber {
        let this = jsObject
        return this[.getItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func insertItemBefore(newItem: SVGNumber, index: UInt32) -> SVGNumber {
        let this = jsObject
        return this[.insertItemBefore].function!(this: this, arguments: [_toJSValue(newItem), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func replaceItem(newItem: SVGNumber, index: UInt32) -> SVGNumber {
        let this = jsObject
        return this[.replaceItem].function!(this: this, arguments: [_toJSValue(newItem), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func removeItem(index: UInt32) -> SVGNumber {
        let this = jsObject
        return this[.removeItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func appendItem(newItem: SVGNumber) -> SVGNumber {
        let this = jsObject
        return this[.appendItem].function!(this: this, arguments: [_toJSValue(newItem)]).fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> SVGNumber {
        get {
            jsObject[key].fromJSValue()!
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }
}

public class SVGPathElement: SVGGeometryElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGPathElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGPatternElement: SVGElement, SVGFitToViewBox, SVGURIReference {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGPatternElement].function }
    
    public var patternUnits: SVGAnimatedEnumeration {
        jsObject[.patternUnits].fromJSValue()!
    }
    
    public var patternContentUnits: SVGAnimatedEnumeration {
        jsObject[.patternContentUnits].fromJSValue()!
    }
    
    public var patternTransform: SVGAnimatedTransformList {
        jsObject[.patternTransform].fromJSValue()!
    }
    
    public var x: SVGAnimatedLength {
        jsObject[.x].fromJSValue()!
    }
    
    public var y: SVGAnimatedLength {
        jsObject[.y].fromJSValue()!
    }
    
    public var width: SVGAnimatedLength {
        jsObject[.width].fromJSValue()!
    }
    
    public var height: SVGAnimatedLength {
        jsObject[.height].fromJSValue()!
    }
}

public class SVGPointList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGPointList].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    public var numberOfItems: UInt32 {
        jsObject[.numberOfItems].fromJSValue()!
    }
    
    @inlinable public func clear() {
        let this = jsObject
        _ = this[.clear].function!(this: this, arguments: [])
    }
    
    @inlinable public func initialize(newItem: DOMPoint) -> DOMPoint {
        let this = jsObject
        return this[.initialize].function!(this: this, arguments: [_toJSValue(newItem)]).fromJSValue()!
    }
    
    @inlinable public func getItem(index: UInt32) -> DOMPoint {
        let this = jsObject
        return this[.getItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func insertItemBefore(newItem: DOMPoint, index: UInt32) -> DOMPoint {
        let this = jsObject
        return this[.insertItemBefore].function!(this: this, arguments: [_toJSValue(newItem), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func replaceItem(newItem: DOMPoint, index: UInt32) -> DOMPoint {
        let this = jsObject
        return this[.replaceItem].function!(this: this, arguments: [_toJSValue(newItem), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func removeItem(index: UInt32) -> DOMPoint {
        let this = jsObject
        return this[.removeItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func appendItem(newItem: DOMPoint) -> DOMPoint {
        let this = jsObject
        return this[.appendItem].function!(this: this, arguments: [_toJSValue(newItem)]).fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> DOMPoint {
        get {
            jsObject[key].fromJSValue()!
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }
}

public class SVGPolygonElement: SVGGeometryElement, SVGAnimatedPoints {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGPolygonElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGPolylineElement: SVGGeometryElement, SVGAnimatedPoints {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGPolylineElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGPreserveAspectRatio: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGPreserveAspectRatio].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public static let SVG_PRESERVEASPECTRATIO_UNKNOWN: UInt16 = 0
    
    public static let SVG_PRESERVEASPECTRATIO_NONE: UInt16 = 1
    
    public static let SVG_PRESERVEASPECTRATIO_XMINYMIN: UInt16 = 2
    
    public static let SVG_PRESERVEASPECTRATIO_XMIDYMIN: UInt16 = 3
    
    public static let SVG_PRESERVEASPECTRATIO_XMAXYMIN: UInt16 = 4
    
    public static let SVG_PRESERVEASPECTRATIO_XMINYMID: UInt16 = 5
    
    public static let SVG_PRESERVEASPECTRATIO_XMIDYMID: UInt16 = 6
    
    public static let SVG_PRESERVEASPECTRATIO_XMAXYMID: UInt16 = 7
    
    public static let SVG_PRESERVEASPECTRATIO_XMINYMAX: UInt16 = 8
    
    public static let SVG_PRESERVEASPECTRATIO_XMIDYMAX: UInt16 = 9
    
    public static let SVG_PRESERVEASPECTRATIO_XMAXYMAX: UInt16 = 10
    
    public static let SVG_MEETORSLICE_UNKNOWN: UInt16 = 0
    
    public static let SVG_MEETORSLICE_MEET: UInt16 = 1
    
    public static let SVG_MEETORSLICE_SLICE: UInt16 = 2
    
    public var align: UInt16 {
        get { jsObject[.align].fromJSValue()!}
        set { jsObject[.align] = newValue.jsValue }
    }
    
    public var meetOrSlice: UInt16 {
        get { jsObject[.meetOrSlice].fromJSValue()!}
        set { jsObject[.meetOrSlice] = newValue.jsValue }
    }
}

public class SVGRadialGradientElement: SVGGradientElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGRadialGradientElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    public var cx: SVGAnimatedLength {
        jsObject[.cx].fromJSValue()!
    }
    
    public var cy: SVGAnimatedLength {
        jsObject[.cy].fromJSValue()!
    }
    
    public var r: SVGAnimatedLength {
        jsObject[.r].fromJSValue()!
    }
    
    public var fx: SVGAnimatedLength {
        jsObject[.fx].fromJSValue()!
    }
    
    public var fy: SVGAnimatedLength {
        jsObject[.fy].fromJSValue()!
    }
    
    public var fr: SVGAnimatedLength {
        jsObject[.fr].fromJSValue()!
    }
}

public class SVGRectElement: SVGGeometryElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGRectElement].function }
    
    public var x: SVGAnimatedLength {
        jsObject[.x].fromJSValue()!
    }
    
    public var y: SVGAnimatedLength {
        jsObject[.y].fromJSValue()!
    }
    
    public var width: SVGAnimatedLength {
        jsObject[.width].fromJSValue()!
    }
    
    public var height: SVGAnimatedLength {
        jsObject[.height].fromJSValue()!
    }
    
    public var rx: SVGAnimatedLength {
        jsObject[.rx].fromJSValue()!
    }
    
    public var ry: SVGAnimatedLength {
        jsObject[.ry].fromJSValue()!
    }
}

public class SVGSVGElement: SVGGraphicsElement, SVGFitToViewBox, WindowEventHandlers {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGSVGElement].function }
    
    public var x: SVGAnimatedLength {
        jsObject[.x].fromJSValue()!
    }
    
    public var y: SVGAnimatedLength {
        jsObject[.y].fromJSValue()!
    }
    
    public var width: SVGAnimatedLength {
        jsObject[.width].fromJSValue()!
    }
    
    public var height: SVGAnimatedLength {
        jsObject[.height].fromJSValue()!
    }
    
    public var currentScale: Float {
        get { jsObject[.currentScale].fromJSValue()!}
        set { jsObject[.currentScale] = newValue.jsValue }
    }
    
    public var currentTranslate: DOMPointReadOnly {
        jsObject[.currentTranslate].fromJSValue()!
    }
    
    @inlinable public func getIntersectionList(rect: DOMRectReadOnly, referenceElement: SVGElement?) -> NodeList {
        let this = jsObject
        return this[.getIntersectionList].function!(this: this, arguments: [_toJSValue(rect), _toJSValue(referenceElement)]).fromJSValue()!
    }
    
    @inlinable public func getEnclosureList(rect: DOMRectReadOnly, referenceElement: SVGElement?) -> NodeList {
        let this = jsObject
        return this[.getEnclosureList].function!(this: this, arguments: [_toJSValue(rect), _toJSValue(referenceElement)]).fromJSValue()!
    }
    
    @inlinable public func checkIntersection(element: SVGElement, rect: DOMRectReadOnly) -> Bool {
        let this = jsObject
        return this[.checkIntersection].function!(this: this, arguments: [_toJSValue(element), _toJSValue(rect)]).fromJSValue()!
    }
    
    @inlinable public func checkEnclosure(element: SVGElement, rect: DOMRectReadOnly) -> Bool {
        let this = jsObject
        return this[.checkEnclosure].function!(this: this, arguments: [_toJSValue(element), _toJSValue(rect)]).fromJSValue()!
    }
    
    @inlinable public func deselectAll() {
        let this = jsObject
        _ = this[.deselectAll].function!(this: this, arguments: [])
    }
    
    @inlinable public func createSVGNumber() -> SVGNumber {
        let this = jsObject
        return this[.createSVGNumber].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createSVGLength() -> SVGLength {
        let this = jsObject
        return this[.createSVGLength].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createSVGAngle() -> SVGAngle {
        let this = jsObject
        return this[.createSVGAngle].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createSVGPoint() -> DOMPoint {
        let this = jsObject
        return this[.createSVGPoint].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createSVGMatrix() -> DOMMatrix {
        let this = jsObject
        return this[.createSVGMatrix].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createSVGRect() -> DOMRect {
        let this = jsObject
        return this[.createSVGRect].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createSVGTransform() -> SVGTransform {
        let this = jsObject
        return this[.createSVGTransform].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createSVGTransformFromMatrix(matrix: DOMMatrix2DInit? = nil) -> SVGTransform {
        let this = jsObject
        return this[.createSVGTransformFromMatrix].function!(this: this, arguments: [_toJSValue(matrix)]).fromJSValue()!
    }
    
    @inlinable public func getElementById(elementId: String) -> Element {
        let this = jsObject
        return this[.getElementById].function!(this: this, arguments: [_toJSValue(elementId)]).fromJSValue()!
    }
    
    @inlinable public func suspendRedraw(maxWaitMilliseconds: UInt32) -> UInt32 {
        let this = jsObject
        return this[.suspendRedraw].function!(this: this, arguments: [_toJSValue(maxWaitMilliseconds)]).fromJSValue()!
    }
    
    @inlinable public func unsuspendRedraw(suspendHandleID: UInt32) {
        let this = jsObject
        _ = this[.unsuspendRedraw].function!(this: this, arguments: [_toJSValue(suspendHandleID)])
    }
    
    @inlinable public func unsuspendRedrawAll() {
        let this = jsObject
        _ = this[.unsuspendRedrawAll].function!(this: this, arguments: [])
    }
    
    @inlinable public func forceRedraw() {
        let this = jsObject
        _ = this[.forceRedraw].function!(this: this, arguments: [])
    }
    
    @inlinable public func pauseAnimations() {
        let this = jsObject
        _ = this[.pauseAnimations].function!(this: this, arguments: [])
    }
    
    @inlinable public func unpauseAnimations() {
        let this = jsObject
        _ = this[.unpauseAnimations].function!(this: this, arguments: [])
    }
    
    @inlinable public func animationsPaused() -> Bool {
        let this = jsObject
        return this[.animationsPaused].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func getCurrentTime() -> Float {
        let this = jsObject
        return this[.getCurrentTime].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func setCurrentTime(seconds: Float) {
        let this = jsObject
        _ = this[.setCurrentTime].function!(this: this, arguments: [_toJSValue(seconds)])
    }
}

public class SVGScriptElement: SVGElement, SVGURIReference {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGScriptElement].function }
    
    public var type: String {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
    
    public var crossOrigin: String? {
        get { jsObject[.crossOrigin].fromJSValue()}
        set { jsObject[.crossOrigin] = newValue.jsValue }
    }
}

public class SVGSetElement: SVGAnimationElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGSetElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGStopElement: SVGElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGStopElement].function }
    
    public var offset: SVGAnimatedNumber {
        jsObject[.offset].fromJSValue()!
    }
}

public class SVGStringList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGStringList].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    public var numberOfItems: UInt32 {
        jsObject[.numberOfItems].fromJSValue()!
    }
    
    @inlinable public func clear() {
        let this = jsObject
        _ = this[.clear].function!(this: this, arguments: [])
    }
    
    @inlinable public func initialize(newItem: String) -> String {
        let this = jsObject
        return this[.initialize].function!(this: this, arguments: [_toJSValue(newItem)]).fromJSValue()!
    }
    
    @inlinable public func getItem(index: UInt32) -> String {
        let this = jsObject
        return this[.getItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func insertItemBefore(newItem: String, index: UInt32) -> String {
        let this = jsObject
        return this[.insertItemBefore].function!(this: this, arguments: [_toJSValue(newItem), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func replaceItem(newItem: String, index: UInt32) -> String {
        let this = jsObject
        return this[.replaceItem].function!(this: this, arguments: [_toJSValue(newItem), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func removeItem(index: UInt32) -> String {
        let this = jsObject
        return this[.removeItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func appendItem(newItem: String) -> String {
        let this = jsObject
        return this[.appendItem].function!(this: this, arguments: [_toJSValue(newItem)]).fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> String {
        get {
            jsObject[key].fromJSValue()!
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }
}

public class SVGStyleElement: SVGElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGStyleElement].function }
    
    public var type: String {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
    
    public var media: String {
        get { jsObject[.media].fromJSValue()!}
        set { jsObject[.media] = newValue.jsValue }
    }
    
    public var title: String {
        get { jsObject[.title].fromJSValue()!}
        set { jsObject[.title] = newValue.jsValue }
    }
}

public class SVGSwitchElement: SVGGraphicsElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGSwitchElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGSymbolElement: SVGGraphicsElement, SVGFitToViewBox {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGSymbolElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGTSpanElement: SVGTextPositioningElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGTSpanElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public protocol SVGTests: JSBridgedClass {}
public extension SVGTests {
    @inlinable var requiredExtensions: SVGStringList { jsObject[.requiredExtensions].fromJSValue()! }
    
    @inlinable var systemLanguage: SVGStringList { jsObject[.systemLanguage].fromJSValue()! }
}

public class SVGTextContentElement: SVGGraphicsElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGTextContentElement].function }
    
    public static let LENGTHADJUST_UNKNOWN: UInt16 = 0
    
    public static let LENGTHADJUST_SPACING: UInt16 = 1
    
    public static let LENGTHADJUST_SPACINGANDGLYPHS: UInt16 = 2
    
    public var textLength: SVGAnimatedLength {
        jsObject[.textLength].fromJSValue()!
    }
    
    public var lengthAdjust: SVGAnimatedEnumeration {
        jsObject[.lengthAdjust].fromJSValue()!
    }
    
    @inlinable public func getNumberOfChars() -> Int32 {
        let this = jsObject
        return this[.getNumberOfChars].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func getComputedTextLength() -> Float {
        let this = jsObject
        return this[.getComputedTextLength].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func getSubStringLength(charnum: UInt32, nchars: UInt32) -> Float {
        let this = jsObject
        return this[.getSubStringLength].function!(this: this, arguments: [_toJSValue(charnum), _toJSValue(nchars)]).fromJSValue()!
    }
    
    @inlinable public func getStartPositionOfChar(charnum: UInt32) -> DOMPoint {
        let this = jsObject
        return this[.getStartPositionOfChar].function!(this: this, arguments: [_toJSValue(charnum)]).fromJSValue()!
    }
    
    @inlinable public func getEndPositionOfChar(charnum: UInt32) -> DOMPoint {
        let this = jsObject
        return this[.getEndPositionOfChar].function!(this: this, arguments: [_toJSValue(charnum)]).fromJSValue()!
    }
    
    @inlinable public func getExtentOfChar(charnum: UInt32) -> DOMRect {
        let this = jsObject
        return this[.getExtentOfChar].function!(this: this, arguments: [_toJSValue(charnum)]).fromJSValue()!
    }
    
    @inlinable public func getRotationOfChar(charnum: UInt32) -> Float {
        let this = jsObject
        return this[.getRotationOfChar].function!(this: this, arguments: [_toJSValue(charnum)]).fromJSValue()!
    }
    
    @inlinable public func getCharNumAtPosition(point: DOMPointInit? = nil) -> Int32 {
        let this = jsObject
        return this[.getCharNumAtPosition].function!(this: this, arguments: [_toJSValue(point)]).fromJSValue()!
    }
    
    @inlinable public func selectSubString(charnum: UInt32, nchars: UInt32) {
        let this = jsObject
        _ = this[.selectSubString].function!(this: this, arguments: [_toJSValue(charnum), _toJSValue(nchars)])
    }
}

public class SVGTextElement: SVGTextPositioningElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGTextElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGTextPathElement: SVGTextContentElement, SVGURIReference {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGTextPathElement].function }
    
    public static let TEXTPATH_METHODTYPE_UNKNOWN: UInt16 = 0
    
    public static let TEXTPATH_METHODTYPE_ALIGN: UInt16 = 1
    
    public static let TEXTPATH_METHODTYPE_STRETCH: UInt16 = 2
    
    public static let TEXTPATH_SPACINGTYPE_UNKNOWN: UInt16 = 0
    
    public static let TEXTPATH_SPACINGTYPE_AUTO: UInt16 = 1
    
    public static let TEXTPATH_SPACINGTYPE_EXACT: UInt16 = 2
    
    public var startOffset: SVGAnimatedLength {
        jsObject[.startOffset].fromJSValue()!
    }
    
    public var method: SVGAnimatedEnumeration {
        jsObject[.method].fromJSValue()!
    }
    
    public var spacing: SVGAnimatedEnumeration {
        jsObject[.spacing].fromJSValue()!
    }
}

public class SVGTextPositioningElement: SVGTextContentElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGTextPositioningElement].function }
    
    public var x: SVGAnimatedLengthList {
        jsObject[.x].fromJSValue()!
    }
    
    public var y: SVGAnimatedLengthList {
        jsObject[.y].fromJSValue()!
    }
    
    public var dx: SVGAnimatedLengthList {
        jsObject[.dx].fromJSValue()!
    }
    
    public var dy: SVGAnimatedLengthList {
        jsObject[.dy].fromJSValue()!
    }
    
    public var rotate: SVGAnimatedNumberList {
        jsObject[.rotate].fromJSValue()!
    }
}

public class SVGTitleElement: SVGElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGTitleElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGTransform: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGTransform].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public static let SVG_TRANSFORM_UNKNOWN: UInt16 = 0
    
    public static let SVG_TRANSFORM_MATRIX: UInt16 = 1
    
    public static let SVG_TRANSFORM_TRANSLATE: UInt16 = 2
    
    public static let SVG_TRANSFORM_SCALE: UInt16 = 3
    
    public static let SVG_TRANSFORM_ROTATE: UInt16 = 4
    
    public static let SVG_TRANSFORM_SKEWX: UInt16 = 5
    
    public static let SVG_TRANSFORM_SKEWY: UInt16 = 6
    
    public var type: UInt16 {
        jsObject[.type].fromJSValue()!
    }
    
    public var matrix: DOMMatrix {
        jsObject[.matrix].fromJSValue()!
    }
    
    public var angle: Float {
        jsObject[.angle].fromJSValue()!
    }
    
    @inlinable public func setMatrix(matrix: DOMMatrix2DInit? = nil) {
        let this = jsObject
        _ = this[.setMatrix].function!(this: this, arguments: [_toJSValue(matrix)])
    }
    
    @inlinable public func setTranslate(tx: Float, ty: Float) {
        let this = jsObject
        _ = this[.setTranslate].function!(this: this, arguments: [_toJSValue(tx), _toJSValue(ty)])
    }
    
    @inlinable public func setScale(sx: Float, sy: Float) {
        let this = jsObject
        _ = this[.setScale].function!(this: this, arguments: [_toJSValue(sx), _toJSValue(sy)])
    }
    
    @inlinable public func setRotate(angle: Float, cx: Float, cy: Float) {
        let this = jsObject
        _ = this[.setRotate].function!(this: this, arguments: [_toJSValue(angle), _toJSValue(cx), _toJSValue(cy)])
    }
    
    @inlinable public func setSkewX(angle: Float) {
        let this = jsObject
        _ = this[.setSkewX].function!(this: this, arguments: [_toJSValue(angle)])
    }
    
    @inlinable public func setSkewY(angle: Float) {
        let this = jsObject
        _ = this[.setSkewY].function!(this: this, arguments: [_toJSValue(angle)])
    }
}

public class SVGTransformList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGTransformList].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    public var numberOfItems: UInt32 {
        jsObject[.numberOfItems].fromJSValue()!
    }
    
    @inlinable public func clear() {
        let this = jsObject
        _ = this[.clear].function!(this: this, arguments: [])
    }
    
    @inlinable public func initialize(newItem: SVGTransform) -> SVGTransform {
        let this = jsObject
        return this[.initialize].function!(this: this, arguments: [_toJSValue(newItem)]).fromJSValue()!
    }
    
    @inlinable public func getItem(index: UInt32) -> SVGTransform {
        let this = jsObject
        return this[.getItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func insertItemBefore(newItem: SVGTransform, index: UInt32) -> SVGTransform {
        let this = jsObject
        return this[.insertItemBefore].function!(this: this, arguments: [_toJSValue(newItem), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func replaceItem(newItem: SVGTransform, index: UInt32) -> SVGTransform {
        let this = jsObject
        return this[.replaceItem].function!(this: this, arguments: [_toJSValue(newItem), _toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func removeItem(index: UInt32) -> SVGTransform {
        let this = jsObject
        return this[.removeItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
    
    @inlinable public func appendItem(newItem: SVGTransform) -> SVGTransform {
        let this = jsObject
        return this[.appendItem].function!(this: this, arguments: [_toJSValue(newItem)]).fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> SVGTransform {
        get {
            jsObject[key].fromJSValue()!
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }
    
    @inlinable public func createSVGTransformFromMatrix(matrix: DOMMatrix2DInit? = nil) -> SVGTransform {
        let this = jsObject
        return this[.createSVGTransformFromMatrix].function!(this: this, arguments: [_toJSValue(matrix)]).fromJSValue()!
    }
    
    @inlinable public func consolidate() -> SVGTransform? {
        let this = jsObject
        return this[.consolidate].function!(this: this, arguments: []).fromJSValue()
    }
}

public protocol SVGURIReference: JSBridgedClass {}
public extension SVGURIReference {
    @inlinable var href: SVGAnimatedString { jsObject[.href].fromJSValue()! }
}

public class SVGUnitTypes: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.SVGUnitTypes].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public static let SVG_UNIT_TYPE_UNKNOWN: UInt16 = 0
    
    public static let SVG_UNIT_TYPE_USERSPACEONUSE: UInt16 = 1
    
    public static let SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: UInt16 = 2
}

public class SVGUseElement: SVGGraphicsElement, SVGURIReference {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGUseElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    public var x: SVGAnimatedLength {
        jsObject[.x].fromJSValue()!
    }
    
    public var y: SVGAnimatedLength {
        jsObject[.y].fromJSValue()!
    }
    
    public var width: SVGAnimatedLength {
        jsObject[.width].fromJSValue()!
    }
    
    public var height: SVGAnimatedLength {
        jsObject[.height].fromJSValue()!
    }
    
    public var instanceRoot: SVGElement? {
        jsObject[.instanceRoot].fromJSValue()
    }
    
    public var animatedInstanceRoot: SVGElement? {
        jsObject[.animatedInstanceRoot].fromJSValue()
    }
}

public class SVGUseElementShadowRoot: ShadowRoot {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGUseElementShadowRoot].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class SVGViewElement: SVGElement, SVGFitToViewBox {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SVGViewElement].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class TimeEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.TimeEvent].function }
    
    public var view: WindowProxy? {
        jsObject[.view].fromJSValue()
    }
    
    public var detail: Int32 {
        jsObject[.detail].fromJSValue()!
    }
    
    @inlinable public func initTimeEvent(typeArg: String, viewArg: Window?, detailArg: Int32) {
        let this = jsObject
        _ = this[.initTimeEvent].function!(this: this, arguments: [_toJSValue(typeArg), _toJSValue(viewArg), _toJSValue(detailArg)])
    }
}
