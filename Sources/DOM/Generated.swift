// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import ECMAScript
import JavaScriptBigIntSupport
import JavaScriptEventLoop
import JavaScriptKit
import WebAPIBase

public protocol ARIAMixin: JSBridgedClass {}
public extension ARIAMixin {
    @inlinable var role: String? {
        get { jsObject[.role].fromJSValue() }
        nonmutating set { jsObject[.role] = _toJSValue(newValue) }
    }

    @inlinable var ariaActiveDescendantElement: Element? {
        get { jsObject[.ariaActiveDescendantElement].fromJSValue() }
        nonmutating set { jsObject[.ariaActiveDescendantElement] = _toJSValue(newValue) }
    }

    @inlinable var ariaAtomic: String? {
        get { jsObject[.ariaAtomic].fromJSValue() }
        nonmutating set { jsObject[.ariaAtomic] = _toJSValue(newValue) }
    }

    @inlinable var ariaAutoComplete: String? {
        get { jsObject[.ariaAutoComplete].fromJSValue() }
        nonmutating set { jsObject[.ariaAutoComplete] = _toJSValue(newValue) }
    }

    @inlinable var ariaBusy: String? {
        get { jsObject[.ariaBusy].fromJSValue() }
        nonmutating set { jsObject[.ariaBusy] = _toJSValue(newValue) }
    }

    @inlinable var ariaChecked: String? {
        get { jsObject[.ariaChecked].fromJSValue() }
        nonmutating set { jsObject[.ariaChecked] = _toJSValue(newValue) }
    }

    @inlinable var ariaColCount: String? {
        get { jsObject[.ariaColCount].fromJSValue() }
        nonmutating set { jsObject[.ariaColCount] = _toJSValue(newValue) }
    }

    @inlinable var ariaColIndex: String? {
        get { jsObject[.ariaColIndex].fromJSValue() }
        nonmutating set { jsObject[.ariaColIndex] = _toJSValue(newValue) }
    }

    @inlinable var ariaColIndexText: String? {
        get { jsObject[.ariaColIndexText].fromJSValue() }
        nonmutating set { jsObject[.ariaColIndexText] = _toJSValue(newValue) }
    }

    @inlinable var ariaColSpan: String? {
        get { jsObject[.ariaColSpan].fromJSValue() }
        nonmutating set { jsObject[.ariaColSpan] = _toJSValue(newValue) }
    }

    @inlinable var ariaControlsElements: [Element]? {
        get { jsObject[.ariaControlsElements].fromJSValue() }
        nonmutating set { jsObject[.ariaControlsElements] = _toJSValue(newValue) }
    }

    @inlinable var ariaCurrent: String? {
        get { jsObject[.ariaCurrent].fromJSValue() }
        nonmutating set { jsObject[.ariaCurrent] = _toJSValue(newValue) }
    }

    @inlinable var ariaDescribedByElements: [Element]? {
        get { jsObject[.ariaDescribedByElements].fromJSValue() }
        nonmutating set { jsObject[.ariaDescribedByElements] = _toJSValue(newValue) }
    }

    @inlinable var ariaDescription: String? {
        get { jsObject[.ariaDescription].fromJSValue() }
        nonmutating set { jsObject[.ariaDescription] = _toJSValue(newValue) }
    }

    @inlinable var ariaDetailsElements: [Element]? {
        get { jsObject[.ariaDetailsElements].fromJSValue() }
        nonmutating set { jsObject[.ariaDetailsElements] = _toJSValue(newValue) }
    }

    @inlinable var ariaDisabled: String? {
        get { jsObject[.ariaDisabled].fromJSValue() }
        nonmutating set { jsObject[.ariaDisabled] = _toJSValue(newValue) }
    }

    @inlinable var ariaErrorMessageElements: [Element]? {
        get { jsObject[.ariaErrorMessageElements].fromJSValue() }
        nonmutating set { jsObject[.ariaErrorMessageElements] = _toJSValue(newValue) }
    }

    @inlinable var ariaExpanded: String? {
        get { jsObject[.ariaExpanded].fromJSValue() }
        nonmutating set { jsObject[.ariaExpanded] = _toJSValue(newValue) }
    }

    @inlinable var ariaFlowToElements: [Element]? {
        get { jsObject[.ariaFlowToElements].fromJSValue() }
        nonmutating set { jsObject[.ariaFlowToElements] = _toJSValue(newValue) }
    }

    @inlinable var ariaHasPopup: String? {
        get { jsObject[.ariaHasPopup].fromJSValue() }
        nonmutating set { jsObject[.ariaHasPopup] = _toJSValue(newValue) }
    }

    @inlinable var ariaHidden: String? {
        get { jsObject[.ariaHidden].fromJSValue() }
        nonmutating set { jsObject[.ariaHidden] = _toJSValue(newValue) }
    }

    @inlinable var ariaInvalid: String? {
        get { jsObject[.ariaInvalid].fromJSValue() }
        nonmutating set { jsObject[.ariaInvalid] = _toJSValue(newValue) }
    }

    @inlinable var ariaKeyShortcuts: String? {
        get { jsObject[.ariaKeyShortcuts].fromJSValue() }
        nonmutating set { jsObject[.ariaKeyShortcuts] = _toJSValue(newValue) }
    }

    @inlinable var ariaLabel: String? {
        get { jsObject[.ariaLabel].fromJSValue() }
        nonmutating set { jsObject[.ariaLabel] = _toJSValue(newValue) }
    }

    @inlinable var ariaLabelledByElements: [Element]? {
        get { jsObject[.ariaLabelledByElements].fromJSValue() }
        nonmutating set { jsObject[.ariaLabelledByElements] = _toJSValue(newValue) }
    }

    @inlinable var ariaLevel: String? {
        get { jsObject[.ariaLevel].fromJSValue() }
        nonmutating set { jsObject[.ariaLevel] = _toJSValue(newValue) }
    }

    @inlinable var ariaLive: String? {
        get { jsObject[.ariaLive].fromJSValue() }
        nonmutating set { jsObject[.ariaLive] = _toJSValue(newValue) }
    }

    @inlinable var ariaModal: String? {
        get { jsObject[.ariaModal].fromJSValue() }
        nonmutating set { jsObject[.ariaModal] = _toJSValue(newValue) }
    }

    @inlinable var ariaMultiLine: String? {
        get { jsObject[.ariaMultiLine].fromJSValue() }
        nonmutating set { jsObject[.ariaMultiLine] = _toJSValue(newValue) }
    }

    @inlinable var ariaMultiSelectable: String? {
        get { jsObject[.ariaMultiSelectable].fromJSValue() }
        nonmutating set { jsObject[.ariaMultiSelectable] = _toJSValue(newValue) }
    }

    @inlinable var ariaOrientation: String? {
        get { jsObject[.ariaOrientation].fromJSValue() }
        nonmutating set { jsObject[.ariaOrientation] = _toJSValue(newValue) }
    }

    @inlinable var ariaOwnsElements: [Element]? {
        get { jsObject[.ariaOwnsElements].fromJSValue() }
        nonmutating set { jsObject[.ariaOwnsElements] = _toJSValue(newValue) }
    }

    @inlinable var ariaPlaceholder: String? {
        get { jsObject[.ariaPlaceholder].fromJSValue() }
        nonmutating set { jsObject[.ariaPlaceholder] = _toJSValue(newValue) }
    }

    @inlinable var ariaPosInSet: String? {
        get { jsObject[.ariaPosInSet].fromJSValue() }
        nonmutating set { jsObject[.ariaPosInSet] = _toJSValue(newValue) }
    }

    @inlinable var ariaPressed: String? {
        get { jsObject[.ariaPressed].fromJSValue() }
        nonmutating set { jsObject[.ariaPressed] = _toJSValue(newValue) }
    }

    @inlinable var ariaReadOnly: String? {
        get { jsObject[.ariaReadOnly].fromJSValue() }
        nonmutating set { jsObject[.ariaReadOnly] = _toJSValue(newValue) }
    }

    @inlinable var ariaRequired: String? {
        get { jsObject[.ariaRequired].fromJSValue() }
        nonmutating set { jsObject[.ariaRequired] = _toJSValue(newValue) }
    }

    @inlinable var ariaRoleDescription: String? {
        get { jsObject[.ariaRoleDescription].fromJSValue() }
        nonmutating set { jsObject[.ariaRoleDescription] = _toJSValue(newValue) }
    }

    @inlinable var ariaRowCount: String? {
        get { jsObject[.ariaRowCount].fromJSValue() }
        nonmutating set { jsObject[.ariaRowCount] = _toJSValue(newValue) }
    }

    @inlinable var ariaRowIndex: String? {
        get { jsObject[.ariaRowIndex].fromJSValue() }
        nonmutating set { jsObject[.ariaRowIndex] = _toJSValue(newValue) }
    }

    @inlinable var ariaRowIndexText: String? {
        get { jsObject[.ariaRowIndexText].fromJSValue() }
        nonmutating set { jsObject[.ariaRowIndexText] = _toJSValue(newValue) }
    }

    @inlinable var ariaRowSpan: String? {
        get { jsObject[.ariaRowSpan].fromJSValue() }
        nonmutating set { jsObject[.ariaRowSpan] = _toJSValue(newValue) }
    }

    @inlinable var ariaSelected: String? {
        get { jsObject[.ariaSelected].fromJSValue() }
        nonmutating set { jsObject[.ariaSelected] = _toJSValue(newValue) }
    }

    @inlinable var ariaSetSize: String? {
        get { jsObject[.ariaSetSize].fromJSValue() }
        nonmutating set { jsObject[.ariaSetSize] = _toJSValue(newValue) }
    }

    @inlinable var ariaSort: String? {
        get { jsObject[.ariaSort].fromJSValue() }
        nonmutating set { jsObject[.ariaSort] = _toJSValue(newValue) }
    }

    @inlinable var ariaValueMax: String? {
        get { jsObject[.ariaValueMax].fromJSValue() }
        nonmutating set { jsObject[.ariaValueMax] = _toJSValue(newValue) }
    }

    @inlinable var ariaValueMin: String? {
        get { jsObject[.ariaValueMin].fromJSValue() }
        nonmutating set { jsObject[.ariaValueMin] = _toJSValue(newValue) }
    }

    @inlinable var ariaValueNow: String? {
        get { jsObject[.ariaValueNow].fromJSValue() }
        nonmutating set { jsObject[.ariaValueNow] = _toJSValue(newValue) }
    }

    @inlinable var ariaValueText: String? {
        get { jsObject[.ariaValueText].fromJSValue() }
        nonmutating set { jsObject[.ariaValueText] = _toJSValue(newValue) }
    }
}

public class AbortController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.AbortController].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _signal = ReadonlyAttribute(jsObject: jsObject, name: .signal)
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var signal: AbortSignal

    @inlinable public func abort(reason: JSValue? = nil) {
        let this = jsObject
        _ = this[.abort].function!(this: this, arguments: [_toJSValue(reason)])
    }
}

public class AbortSignal: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AbortSignal].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _aborted = ReadonlyAttribute(jsObject: jsObject, name: .aborted)
        _reason = ReadonlyAttribute(jsObject: jsObject, name: .reason)
        _onabort = ClosureAttribute1Optional(jsObject: jsObject, name: .onabort)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public class func abort(reason: JSValue? = nil) -> Self {
        let this = constructor!
        return this[.abort].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
    }

    @inlinable public class func timeout(milliseconds: UInt64) -> Self {
        let this = constructor!
        return this[.timeout].function!(this: this, arguments: [_toJSValue(milliseconds)]).fromJSValue()!
    }

    @inlinable public class func any(signals: [AbortSignal]) -> Self {
        let this = constructor!
        return this[.any].function!(this: this, arguments: [_toJSValue(signals)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var aborted: Bool

    @ReadonlyAttribute
    public var reason: JSValue

    @inlinable public func throwIfAborted() {
        let this = jsObject
        _ = this[.throwIfAborted].function!(this: this, arguments: [])
    }

    @ClosureAttribute1Optional
    public var onabort: EventHandler
}

public class AbstractRange: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.AbstractRange].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _startContainer = ReadonlyAttribute(jsObject: jsObject, name: .startContainer)
        _startOffset = ReadonlyAttribute(jsObject: jsObject, name: .startOffset)
        _endContainer = ReadonlyAttribute(jsObject: jsObject, name: .endContainer)
        _endOffset = ReadonlyAttribute(jsObject: jsObject, name: .endOffset)
        _collapsed = ReadonlyAttribute(jsObject: jsObject, name: .collapsed)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var startContainer: Node

    @ReadonlyAttribute
    public var startOffset: UInt32

    @ReadonlyAttribute
    public var endContainer: Node

    @ReadonlyAttribute
    public var endOffset: UInt32

    @ReadonlyAttribute
    public var collapsed: Bool
}

public protocol AbstractWorker: JSBridgedClass {}
public extension AbstractWorker {
    @inlinable var onerror: EventHandler {
        get { ClosureAttribute1Optional[.onerror, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onerror, in: jsObject] = newValue }
    }
}

public class AddEventListenerOptions: BridgedDictionary {
    public convenience init(passive: Bool, once: Bool, signal: AbortSignal) {
        let object = JSObject.global[.Object].function!.new()
        object[.passive] = _toJSValue(passive)
        object[.once] = _toJSValue(once)
        object[.signal] = _toJSValue(signal)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _passive = ReadWriteAttribute(jsObject: object, name: .passive)
        _once = ReadWriteAttribute(jsObject: object, name: .once)
        _signal = ReadWriteAttribute(jsObject: object, name: .signal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var passive: Bool

    @ReadWriteAttribute
    public var once: Bool

    @ReadWriteAttribute
    public var signal: AbortSignal
}

public enum AlphaOption: JSString, JSValueCompatible {
    case keep = "keep"
    case discard = "discard"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol AnimationFrameProvider: JSBridgedClass {}
public extension AnimationFrameProvider {
    @inlinable func requestAnimationFrame(callback: @escaping FrameRequestCallback) -> UInt32 {
        let this = jsObject
        return this[.requestAnimationFrame].function!(this: this, arguments: [_toJSValue(callback)]).fromJSValue()!
    }

    @inlinable func cancelAnimationFrame(handle: UInt32) {
        let this = jsObject
        _ = this[.cancelAnimationFrame].function!(this: this, arguments: [_toJSValue(handle)])
    }
}

public enum AppendMode: JSString, JSValueCompatible {
    case segments = "segments"
    case sequence = "sequence"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AssignedNodesOptions: BridgedDictionary {
    public convenience init(flatten: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.flatten] = _toJSValue(flatten)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _flatten = ReadWriteAttribute(jsObject: object, name: .flatten)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var flatten: Bool
}

public class Attr: Node {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.Attr].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _namespaceURI = ReadonlyAttribute(jsObject: jsObject, name: .namespaceURI)
        _prefix = ReadonlyAttribute(jsObject: jsObject, name: .prefix)
        _localName = ReadonlyAttribute(jsObject: jsObject, name: .localName)
        _name = ReadonlyAttribute(jsObject: jsObject, name: .name)
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        _ownerElement = ReadonlyAttribute(jsObject: jsObject, name: .ownerElement)
        _specified = ReadonlyAttribute(jsObject: jsObject, name: .specified)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var namespaceURI: String?

    @ReadonlyAttribute
    public var prefix: String?

    @ReadonlyAttribute
    public var localName: String

    @ReadonlyAttribute
    public var name: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var ownerElement: Element?

    @ReadonlyAttribute
    public var specified: Bool
}

public class AudioData: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.AudioData].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _format = ReadonlyAttribute(jsObject: jsObject, name: .format)
        _sampleRate = ReadonlyAttribute(jsObject: jsObject, name: .sampleRate)
        _numberOfFrames = ReadonlyAttribute(jsObject: jsObject, name: .numberOfFrames)
        _numberOfChannels = ReadonlyAttribute(jsObject: jsObject, name: .numberOfChannels)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: .duration)
        _timestamp = ReadonlyAttribute(jsObject: jsObject, name: .timestamp)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: AudioDataInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var format: AudioSampleFormat?

    @ReadonlyAttribute
    public var sampleRate: Float

    @ReadonlyAttribute
    public var numberOfFrames: UInt32

    @ReadonlyAttribute
    public var numberOfChannels: UInt32

    @ReadonlyAttribute
    public var duration: UInt64

    @ReadonlyAttribute
    public var timestamp: Int64

    @inlinable public func allocationSize(options: AudioDataCopyToOptions) -> UInt32 {
        let this = jsObject
        return this[.allocationSize].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func copyTo(destination: AllowSharedBufferSource, options: AudioDataCopyToOptions) {
        let this = jsObject
        _ = this[.copyTo].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(options)])
    }

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }
}

public class AudioDataCopyToOptions: BridgedDictionary {
    public convenience init(planeIndex: UInt32, frameOffset: UInt32, frameCount: UInt32, format: AudioSampleFormat) {
        let object = JSObject.global[.Object].function!.new()
        object[.planeIndex] = _toJSValue(planeIndex)
        object[.frameOffset] = _toJSValue(frameOffset)
        object[.frameCount] = _toJSValue(frameCount)
        object[.format] = _toJSValue(format)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _planeIndex = ReadWriteAttribute(jsObject: object, name: .planeIndex)
        _frameOffset = ReadWriteAttribute(jsObject: object, name: .frameOffset)
        _frameCount = ReadWriteAttribute(jsObject: object, name: .frameCount)
        _format = ReadWriteAttribute(jsObject: object, name: .format)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var planeIndex: UInt32

    @ReadWriteAttribute
    public var frameOffset: UInt32

    @ReadWriteAttribute
    public var frameCount: UInt32

    @ReadWriteAttribute
    public var format: AudioSampleFormat
}

public class AudioDataInit: BridgedDictionary {
    public convenience init(format: AudioSampleFormat, sampleRate: Float, numberOfFrames: UInt32, numberOfChannels: UInt32, timestamp: Int64, data: BufferSource, transfer: [ArrayBuffer]) {
        let object = JSObject.global[.Object].function!.new()
        object[.format] = _toJSValue(format)
        object[.sampleRate] = _toJSValue(sampleRate)
        object[.numberOfFrames] = _toJSValue(numberOfFrames)
        object[.numberOfChannels] = _toJSValue(numberOfChannels)
        object[.timestamp] = _toJSValue(timestamp)
        object[.data] = _toJSValue(data)
        object[.transfer] = _toJSValue(transfer)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: .format)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: .sampleRate)
        _numberOfFrames = ReadWriteAttribute(jsObject: object, name: .numberOfFrames)
        _numberOfChannels = ReadWriteAttribute(jsObject: object, name: .numberOfChannels)
        _timestamp = ReadWriteAttribute(jsObject: object, name: .timestamp)
        _data = ReadWriteAttribute(jsObject: object, name: .data)
        _transfer = ReadWriteAttribute(jsObject: object, name: .transfer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: AudioSampleFormat

    @ReadWriteAttribute
    public var sampleRate: Float

    @ReadWriteAttribute
    public var numberOfFrames: UInt32

    @ReadWriteAttribute
    public var numberOfChannels: UInt32

    @ReadWriteAttribute
    public var timestamp: Int64

    @ReadWriteAttribute
    public var data: BufferSource

    @ReadWriteAttribute
    public var transfer: [ArrayBuffer]
}

public class AudioDecoder: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioDecoder].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: .state)
        _decodeQueueSize = ReadonlyAttribute(jsObject: jsObject, name: .decodeQueueSize)
        _ondequeue = ClosureAttribute1Optional(jsObject: jsObject, name: .ondequeue)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(init: AudioDecoderInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var state: CodecState

    @ReadonlyAttribute
    public var decodeQueueSize: UInt32

    @ClosureAttribute1Optional
    public var ondequeue: EventHandler

    @inlinable public func configure(config: AudioDecoderConfig) {
        let this = jsObject
        _ = this[.configure].function!(this: this, arguments: [_toJSValue(config)])
    }

    @inlinable public func decode(chunk: EncodedAudioChunk) {
        let this = jsObject
        _ = this[.decode].function!(this: this, arguments: [_toJSValue(chunk)])
    }

    @inlinable public func flush() -> JSPromise {
        let this = jsObject
        return this[.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func flush() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.flush].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[.reset].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }

    @inlinable public class func isConfigSupported(config: AudioDecoderConfig) -> JSPromise {
        let this = constructor!
        return this[.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public class func isConfigSupported(config: AudioDecoderConfig) async throws -> AudioDecoderSupport {
        let this = constructor!
        let _promise: JSPromise = this[.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class AudioDecoderConfig: BridgedDictionary {
    public convenience init(codec: String, sampleRate: UInt32, numberOfChannels: UInt32, description: BufferSource) {
        let object = JSObject.global[.Object].function!.new()
        object[.codec] = _toJSValue(codec)
        object[.sampleRate] = _toJSValue(sampleRate)
        object[.numberOfChannels] = _toJSValue(numberOfChannels)
        object[.description] = _toJSValue(description)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _codec = ReadWriteAttribute(jsObject: object, name: .codec)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: .sampleRate)
        _numberOfChannels = ReadWriteAttribute(jsObject: object, name: .numberOfChannels)
        _description = ReadWriteAttribute(jsObject: object, name: .description)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var codec: String

    @ReadWriteAttribute
    public var sampleRate: UInt32

    @ReadWriteAttribute
    public var numberOfChannels: UInt32

    @ReadWriteAttribute
    public var description: BufferSource
}

public class AudioDecoderInit: BridgedDictionary {
    public convenience init(output: @escaping AudioDataOutputCallback, error: @escaping WebCodecsErrorCallback) {
        let object = JSObject.global[.Object].function!.new()
        ClosureAttribute1Void[.output, in: object] = output
        ClosureAttribute1Void[.error, in: object] = error
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _output = ClosureAttribute1Void(jsObject: object, name: .output)
        _error = ClosureAttribute1Void(jsObject: object, name: .error)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute1Void
    public var output: AudioDataOutputCallback

    @ClosureAttribute1Void
    public var error: WebCodecsErrorCallback
}

public class AudioDecoderSupport: BridgedDictionary {
    public convenience init(supported: Bool, config: AudioDecoderConfig) {
        let object = JSObject.global[.Object].function!.new()
        object[.supported] = _toJSValue(supported)
        object[.config] = _toJSValue(config)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _supported = ReadWriteAttribute(jsObject: object, name: .supported)
        _config = ReadWriteAttribute(jsObject: object, name: .config)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var supported: Bool

    @ReadWriteAttribute
    public var config: AudioDecoderConfig
}

public class AudioEncoder: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioEncoder].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: .state)
        _encodeQueueSize = ReadonlyAttribute(jsObject: jsObject, name: .encodeQueueSize)
        _ondequeue = ClosureAttribute1Optional(jsObject: jsObject, name: .ondequeue)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(init: AudioEncoderInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var state: CodecState

    @ReadonlyAttribute
    public var encodeQueueSize: UInt32

    @ClosureAttribute1Optional
    public var ondequeue: EventHandler

    @inlinable public func configure(config: AudioEncoderConfig) {
        let this = jsObject
        _ = this[.configure].function!(this: this, arguments: [_toJSValue(config)])
    }

    @inlinable public func encode(data: AudioData) {
        let this = jsObject
        _ = this[.encode].function!(this: this, arguments: [_toJSValue(data)])
    }

    @inlinable public func flush() -> JSPromise {
        let this = jsObject
        return this[.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func flush() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.flush].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[.reset].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }

    @inlinable public class func isConfigSupported(config: AudioEncoderConfig) -> JSPromise {
        let this = constructor!
        return this[.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public class func isConfigSupported(config: AudioEncoderConfig) async throws -> AudioEncoderSupport {
        let this = constructor!
        let _promise: JSPromise = this[.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class AudioEncoderConfig: BridgedDictionary {
    public convenience init(codec: String, sampleRate: UInt32, numberOfChannels: UInt32, bitrate: UInt64, bitrateMode: BitrateMode) {
        let object = JSObject.global[.Object].function!.new()
        object[.codec] = _toJSValue(codec)
        object[.sampleRate] = _toJSValue(sampleRate)
        object[.numberOfChannels] = _toJSValue(numberOfChannels)
        object[.bitrate] = _toJSValue(bitrate)
        object[.bitrateMode] = _toJSValue(bitrateMode)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _codec = ReadWriteAttribute(jsObject: object, name: .codec)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: .sampleRate)
        _numberOfChannels = ReadWriteAttribute(jsObject: object, name: .numberOfChannels)
        _bitrate = ReadWriteAttribute(jsObject: object, name: .bitrate)
        _bitrateMode = ReadWriteAttribute(jsObject: object, name: .bitrateMode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var codec: String

    @ReadWriteAttribute
    public var sampleRate: UInt32

    @ReadWriteAttribute
    public var numberOfChannels: UInt32

    @ReadWriteAttribute
    public var bitrate: UInt64

    @ReadWriteAttribute
    public var bitrateMode: BitrateMode
}

public class AudioEncoderInit: BridgedDictionary {
    public convenience init(output: @escaping EncodedAudioChunkOutputCallback, error: @escaping WebCodecsErrorCallback) {
        let object = JSObject.global[.Object].function!.new()
        ClosureAttribute2Void[.output, in: object] = output
        ClosureAttribute1Void[.error, in: object] = error
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _output = ClosureAttribute2Void(jsObject: object, name: .output)
        _error = ClosureAttribute1Void(jsObject: object, name: .error)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute2Void
    public var output: EncodedAudioChunkOutputCallback

    @ClosureAttribute1Void
    public var error: WebCodecsErrorCallback
}

public class AudioEncoderSupport: BridgedDictionary {
    public convenience init(supported: Bool, config: AudioEncoderConfig) {
        let object = JSObject.global[.Object].function!.new()
        object[.supported] = _toJSValue(supported)
        object[.config] = _toJSValue(config)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _supported = ReadWriteAttribute(jsObject: object, name: .supported)
        _config = ReadWriteAttribute(jsObject: object, name: .config)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var supported: Bool

    @ReadWriteAttribute
    public var config: AudioEncoderConfig
}

public enum AudioSampleFormat: JSString, JSValueCompatible {
    case u8 = "u8"
    case s16 = "s16"
    case s32 = "s32"
    case f32 = "f32"
    case u8Planar = "u8-planar"
    case s16Planar = "s16-planar"
    case s32Planar = "s32-planar"
    case f32Planar = "f32-planar"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AudioTrack: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.AudioTrack].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _id = ReadonlyAttribute(jsObject: jsObject, name: .id)
        _kind = ReadonlyAttribute(jsObject: jsObject, name: .kind)
        _label = ReadonlyAttribute(jsObject: jsObject, name: .label)
        _language = ReadonlyAttribute(jsObject: jsObject, name: .language)
        _enabled = ReadWriteAttribute(jsObject: jsObject, name: .enabled)
        _sourceBuffer = ReadonlyAttribute(jsObject: jsObject, name: .sourceBuffer)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var kind: String

    @ReadonlyAttribute
    public var label: String

    @ReadonlyAttribute
    public var language: String

    @ReadWriteAttribute
    public var enabled: Bool

    @ReadonlyAttribute
    public var sourceBuffer: SourceBuffer?
}

public class AudioTrackList: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioTrackList].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: .onchange)
        _onaddtrack = ClosureAttribute1Optional(jsObject: jsObject, name: .onaddtrack)
        _onremovetrack = ClosureAttribute1Optional(jsObject: jsObject, name: .onremovetrack)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> AudioTrack {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getTrackById(id: String) -> AudioTrack? {
        let this = jsObject
        return this[.getTrackById].function!(this: this, arguments: [_toJSValue(id)]).fromJSValue()
    }

    @ClosureAttribute1Optional
    public var onchange: EventHandler

    @ClosureAttribute1Optional
    public var onaddtrack: EventHandler

    @ClosureAttribute1Optional
    public var onremovetrack: EventHandler
}

public class BarProp: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.BarProp].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _visible = ReadonlyAttribute(jsObject: jsObject, name: .visible)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var visible: Bool
}

public class BeforeUnloadEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.BeforeUnloadEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _returnValue = ReadWriteAttribute(jsObject: jsObject, name: .returnValue)
        super.init(unsafelyWrapping: jsObject)
    }

    @available(*, unavailable)
    override public var returnValue: Bool {
        get { !_returnValue.wrappedValue.isEmpty }
        set {}
    }

    @usableFromInline let _returnValue: ReadWriteAttribute<String>
    // renamed because `String` is not compatible with `Bool`
    @inlinable public var returnValueAsString: String {
        get { _returnValue.wrappedValue }
        set { _returnValue.wrappedValue = newValue }
    }
}

public enum BitrateMode: JSString, JSValueCompatible {
    case constant = "constant"
    case variable = "variable"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Blob: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Blob].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _size = ReadonlyAttribute(jsObject: jsObject, name: .size)
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(blobParts: [BlobPart]? = nil, options: BlobPropertyBag? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(blobParts), _toJSValue(options)]))
    }

    @ReadonlyAttribute
    public var size: UInt64

    @ReadonlyAttribute
    public var type: String

    @inlinable public func slice(start: Int64? = nil, end: Int64? = nil, contentType: String? = nil) -> Self {
        let this = jsObject
        return this[.slice].function!(this: this, arguments: [_toJSValue(start), _toJSValue(end), _toJSValue(contentType)]).fromJSValue()!
    }

    @inlinable public func stream() -> ReadableStream {
        let this = jsObject
        return this[.stream].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func text() -> JSPromise {
        let this = jsObject
        return this[.text].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func text() async throws -> String {
        let this = jsObject
        let _promise: JSPromise = this[.text].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func arrayBuffer() -> JSPromise {
        let this = jsObject
        return this[.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func arrayBuffer() async throws -> ArrayBuffer {
        let this = jsObject
        let _promise: JSPromise = this[.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class BlobEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.BlobEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadonlyAttribute(jsObject: jsObject, name: .data)
        _timecode = ReadonlyAttribute(jsObject: jsObject, name: .timecode)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: BlobEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var data: Blob

    @ReadonlyAttribute
    public var timecode: DOMHighResTimeStamp
}

public class BlobEventInit: BridgedDictionary {
    public convenience init(data: Blob, timecode: DOMHighResTimeStamp) {
        let object = JSObject.global[.Object].function!.new()
        object[.data] = _toJSValue(data)
        object[.timecode] = _toJSValue(timecode)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _data = ReadWriteAttribute(jsObject: object, name: .data)
        _timecode = ReadWriteAttribute(jsObject: object, name: .timecode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var data: Blob

    @ReadWriteAttribute
    public var timecode: DOMHighResTimeStamp
}

public class BlobPropertyBag: BridgedDictionary {
    public convenience init(type: String, endings: EndingType) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.endings] = _toJSValue(endings)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        _endings = ReadWriteAttribute(jsObject: object, name: .endings)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var endings: EndingType
}

public protocol Body: JSBridgedClass {}
public extension Body {
    @inlinable var body: ReadableStream? { jsObject[.body].fromJSValue() }

    @inlinable var bodyUsed: Bool { jsObject[.bodyUsed].fromJSValue()! }

    @inlinable func arrayBuffer() -> JSPromise {
        let this = jsObject
        return this[.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func arrayBuffer() async throws -> ArrayBuffer {
        let this = jsObject
        let _promise: JSPromise = this[.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func blob() -> JSPromise {
        let this = jsObject
        return this[.blob].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func blob() async throws -> Blob {
        let this = jsObject
        let _promise: JSPromise = this[.blob].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func formData() -> JSPromise {
        let this = jsObject
        return this[.formData].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func formData() async throws -> FormData {
        let this = jsObject
        let _promise: JSPromise = this[.formData].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func json() -> JSPromise {
        let this = jsObject
        return this[.json].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func json() async throws -> JSValue {
        let this = jsObject
        let _promise: JSPromise = this[.json].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable func text() -> JSPromise {
        let this = jsObject
        return this[.text].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func text() async throws -> String {
        let this = jsObject
        let _promise: JSPromise = this[.text].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class BoxQuadOptions: BridgedDictionary {
    public convenience init(box: CSSBoxType, relativeTo: GeometryNode) {
        let object = JSObject.global[.Object].function!.new()
        object[.box] = _toJSValue(box)
        object[.relativeTo] = _toJSValue(relativeTo)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _box = ReadWriteAttribute(jsObject: object, name: .box)
        _relativeTo = ReadWriteAttribute(jsObject: object, name: .relativeTo)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var box: CSSBoxType

    @ReadWriteAttribute
    public var relativeTo: GeometryNode
}

public class BroadcastChannel: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.BroadcastChannel].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: .name)
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: .onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(name: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(name)]))
    }

    @ReadonlyAttribute
    public var name: String

    @inlinable public func postMessage(message: JSValue) {
        let this = jsObject
        _ = this[.postMessage].function!(this: this, arguments: [_toJSValue(message)])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public class ByteLengthQueuingStrategy: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ByteLengthQueuingStrategy].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _highWaterMark = ReadonlyAttribute(jsObject: jsObject, name: .highWaterMark)
        _size = ReadonlyAttribute(jsObject: jsObject, name: .size)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: QueuingStrategyInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var highWaterMark: Double

    @ReadonlyAttribute
    public var size: JSFunction
}

public class CDATASection: Text {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CDATASection].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public enum CSSBoxType: JSString, JSValueCompatible {
    case margin = "margin"
    case border = "border"
    case padding = "padding"
    case content = "content"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CSSPseudoElement: EventTarget, GeometryUtils {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSPseudoElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _element = ReadonlyAttribute(jsObject: jsObject, name: .element)
        _parent = ReadonlyAttribute(jsObject: jsObject, name: .parent)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var element: Element

    @ReadonlyAttribute
    public var parent: CSSPseudoElement_or_Element

    @inlinable public func pseudo(type: String) -> CSSPseudoElement? {
        let this = jsObject
        return this[.pseudo].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()
    }
}

public class Cache: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Cache].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func match(request: RequestInfo, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.match].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func match(request: RequestInfo, options: CacheQueryOptions? = nil) async throws -> Response? {
        let this = jsObject
        let _promise: JSPromise = this[.match].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func matchAll(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.matchAll].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func matchAll(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) async throws -> [Response] {
        let this = jsObject
        let _promise: JSPromise = this[.matchAll].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func add(request: RequestInfo) -> JSPromise {
        let this = jsObject
        return this[.add].function!(this: this, arguments: [_toJSValue(request)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func add(request: RequestInfo) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.add].function!(this: this, arguments: [_toJSValue(request)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func addAll(requests: [RequestInfo]) -> JSPromise {
        let this = jsObject
        return this[.addAll].function!(this: this, arguments: [_toJSValue(requests)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func addAll(requests: [RequestInfo]) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.addAll].function!(this: this, arguments: [_toJSValue(requests)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func put(request: RequestInfo, response: Response) -> JSPromise {
        let this = jsObject
        return this[.put].function!(this: this, arguments: [_toJSValue(request), _toJSValue(response)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func put(request: RequestInfo, response: Response) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.put].function!(this: this, arguments: [_toJSValue(request), _toJSValue(response)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func delete(request: RequestInfo, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.delete].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func delete(request: RequestInfo, options: CacheQueryOptions? = nil) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[.delete].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func keys(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.keys].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func keys(request: RequestInfo? = nil, options: CacheQueryOptions? = nil) async throws -> [Request] {
        let this = jsObject
        let _promise: JSPromise = this[.keys].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class CacheQueryOptions: BridgedDictionary {
    public convenience init(ignoreSearch: Bool, ignoreMethod: Bool, ignoreVary: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.ignoreSearch] = _toJSValue(ignoreSearch)
        object[.ignoreMethod] = _toJSValue(ignoreMethod)
        object[.ignoreVary] = _toJSValue(ignoreVary)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _ignoreSearch = ReadWriteAttribute(jsObject: object, name: .ignoreSearch)
        _ignoreMethod = ReadWriteAttribute(jsObject: object, name: .ignoreMethod)
        _ignoreVary = ReadWriteAttribute(jsObject: object, name: .ignoreVary)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var ignoreSearch: Bool

    @ReadWriteAttribute
    public var ignoreMethod: Bool

    @ReadWriteAttribute
    public var ignoreVary: Bool
}

public class CacheStorage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CacheStorage].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func match(request: RequestInfo, options: MultiCacheQueryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.match].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func match(request: RequestInfo, options: MultiCacheQueryOptions? = nil) async throws -> Response? {
        let this = jsObject
        let _promise: JSPromise = this[.match].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func has(cacheName: String) -> JSPromise {
        let this = jsObject
        return this[.has].function!(this: this, arguments: [_toJSValue(cacheName)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func has(cacheName: String) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[.has].function!(this: this, arguments: [_toJSValue(cacheName)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func open(cacheName: String) -> JSPromise {
        let this = jsObject
        return this[.open].function!(this: this, arguments: [_toJSValue(cacheName)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func open(cacheName: String) async throws -> Cache {
        let this = jsObject
        let _promise: JSPromise = this[.open].function!(this: this, arguments: [_toJSValue(cacheName)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func delete(cacheName: String) -> JSPromise {
        let this = jsObject
        return this[.delete].function!(this: this, arguments: [_toJSValue(cacheName)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func delete(cacheName: String) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[.delete].function!(this: this, arguments: [_toJSValue(cacheName)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func keys() -> JSPromise {
        let this = jsObject
        return this[.keys].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func keys() async throws -> [String] {
        let this = jsObject
        let _promise: JSPromise = this[.keys].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class CameraDevicePermissionDescriptor: BridgedDictionary {
    public convenience init(panTiltZoom: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.panTiltZoom] = _toJSValue(panTiltZoom)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _panTiltZoom = ReadWriteAttribute(jsObject: object, name: .panTiltZoom)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var panTiltZoom: Bool
}

public enum CanPlayTypeResult: JSString, JSValueCompatible {
    case _empty = ""
    case maybe = "maybe"
    case probably = "probably"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}



public class CanvasRenderingContext2DSettings: BridgedDictionary {
    public convenience init(alpha: Bool, desynchronized: Bool, colorSpace: PredefinedColorSpace, willReadFrequently: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.alpha] = _toJSValue(alpha)
        object[.desynchronized] = _toJSValue(desynchronized)
        object[.colorSpace] = _toJSValue(colorSpace)
        object[.willReadFrequently] = _toJSValue(willReadFrequently)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _alpha = ReadWriteAttribute(jsObject: object, name: .alpha)
        _desynchronized = ReadWriteAttribute(jsObject: object, name: .desynchronized)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: .colorSpace)
        _willReadFrequently = ReadWriteAttribute(jsObject: object, name: .willReadFrequently)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var alpha: Bool

    @ReadWriteAttribute
    public var desynchronized: Bool

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace

    @ReadWriteAttribute
    public var willReadFrequently: Bool
}



public class CaretPosition: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CaretPosition].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _offsetNode = ReadonlyAttribute(jsObject: jsObject, name: .offsetNode)
        _offset = ReadonlyAttribute(jsObject: jsObject, name: .offset)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var offsetNode: Node

    @ReadonlyAttribute
    public var offset: UInt32

    @inlinable public func getClientRect() -> DOMRect? {
        let this = jsObject
        return this[.getClientRect].function!(this: this, arguments: []).fromJSValue()
    }
}

public class CharacterData: Node, NonDocumentTypeChildNode, ChildNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CharacterData].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadWriteAttribute(jsObject: jsObject, name: .data)
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadWriteAttribute
    public var data: String

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public func substringData(offset: UInt32, count: UInt32) -> String {
        let this = jsObject
        return this[.substringData].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(count)]).fromJSValue()!
    }

    @inlinable public func appendData(data: String) {
        let this = jsObject
        _ = this[.appendData].function!(this: this, arguments: [_toJSValue(data)])
    }

    @inlinable public func insertData(offset: UInt32, data: String) {
        let this = jsObject
        _ = this[.insertData].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(data)])
    }

    @inlinable public func deleteData(offset: UInt32, count: UInt32) {
        let this = jsObject
        _ = this[.deleteData].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(count)])
    }

    @inlinable public func replaceData(offset: UInt32, count: UInt32, data: String) {
        let this = jsObject
        _ = this[.replaceData].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(count), _toJSValue(data)])
    }
}

public class CheckVisibilityOptions: BridgedDictionary {
    public convenience init(checkOpacity: Bool, checkVisibilityCSS: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.checkOpacity] = _toJSValue(checkOpacity)
        object[.checkVisibilityCSS] = _toJSValue(checkVisibilityCSS)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _checkOpacity = ReadWriteAttribute(jsObject: object, name: .checkOpacity)
        _checkVisibilityCSS = ReadWriteAttribute(jsObject: object, name: .checkVisibilityCSS)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var checkOpacity: Bool

    @ReadWriteAttribute
    public var checkVisibilityCSS: Bool
}

public protocol ChildNode: JSBridgedClass {}
public extension ChildNode {
    @inlinable func before(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[.before].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable func after(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[.after].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable func replaceWith(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[.replaceWith].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable func remove() {
        let this = jsObject
        _ = this[.remove].function!(this: this, arguments: [])
    }
}

public class ClientQueryOptions: BridgedDictionary {
    public convenience init(includeUncontrolled: Bool, type: ClientType) {
        let object = JSObject.global[.Object].function!.new()
        object[.includeUncontrolled] = _toJSValue(includeUncontrolled)
        object[.type] = _toJSValue(type)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _includeUncontrolled = ReadWriteAttribute(jsObject: object, name: .includeUncontrolled)
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var includeUncontrolled: Bool

    @ReadWriteAttribute
    public var type: ClientType
}

public enum ClientType: JSString, JSValueCompatible {
    case window = "window"
    case worker = "worker"
    case sharedworker = "sharedworker"
    case all = "all"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CodecState: JSString, JSValueCompatible {
    case unconfigured = "unconfigured"
    case configured = "configured"
    case closed = "closed"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ColorSpaceConversion: JSString, JSValueCompatible {
    case none = "none"
    case `default` = "default"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Comment: CharacterData {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.Comment].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(data: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(data)]))
    }
}

public class CompositionEvent: UIEvent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CompositionEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadonlyAttribute(jsObject: jsObject, name: .data)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: CompositionEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var data: String

    @inlinable public func initCompositionEvent(typeArg: String, bubblesArg: Bool? = nil, cancelableArg: Bool? = nil, viewArg: WindowProxy? = nil, dataArg: String? = nil) {
        let this = jsObject
        _ = this[.initCompositionEvent].function!(this: this, arguments: [_toJSValue(typeArg), _toJSValue(bubblesArg), _toJSValue(cancelableArg), _toJSValue(viewArg), _toJSValue(dataArg)])
    }
}

public class CompositionEventInit: BridgedDictionary {
    public convenience init(data: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.data] = _toJSValue(data)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _data = ReadWriteAttribute(jsObject: object, name: .data)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var data: String
}

public class ConstrainBooleanParameters: BridgedDictionary {
    public convenience init(exact: Bool, ideal: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.exact] = _toJSValue(exact)
        object[.ideal] = _toJSValue(ideal)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _exact = ReadWriteAttribute(jsObject: object, name: .exact)
        _ideal = ReadWriteAttribute(jsObject: object, name: .ideal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var exact: Bool

    @ReadWriteAttribute
    public var ideal: Bool
}

public class ConstrainDOMStringParameters: BridgedDictionary {
    public convenience init(exact: String_or_seq_of_String, ideal: String_or_seq_of_String) {
        let object = JSObject.global[.Object].function!.new()
        object[.exact] = _toJSValue(exact)
        object[.ideal] = _toJSValue(ideal)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _exact = ReadWriteAttribute(jsObject: object, name: .exact)
        _ideal = ReadWriteAttribute(jsObject: object, name: .ideal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var exact: String_or_seq_of_String

    @ReadWriteAttribute
    public var ideal: String_or_seq_of_String
}

public class ConstrainDoubleRange: BridgedDictionary {
    public convenience init(exact: Double, ideal: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.exact] = _toJSValue(exact)
        object[.ideal] = _toJSValue(ideal)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _exact = ReadWriteAttribute(jsObject: object, name: .exact)
        _ideal = ReadWriteAttribute(jsObject: object, name: .ideal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var exact: Double

    @ReadWriteAttribute
    public var ideal: Double
}

public class ConstrainULongRange: BridgedDictionary {
    public convenience init(exact: UInt32, ideal: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.exact] = _toJSValue(exact)
        object[.ideal] = _toJSValue(ideal)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _exact = ReadWriteAttribute(jsObject: object, name: .exact)
        _ideal = ReadWriteAttribute(jsObject: object, name: .ideal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var exact: UInt32

    @ReadWriteAttribute
    public var ideal: UInt32
}

public class ConvertCoordinateOptions: BridgedDictionary {
    public convenience init(fromBox: CSSBoxType, toBox: CSSBoxType) {
        let object = JSObject.global[.Object].function!.new()
        object[.fromBox] = _toJSValue(fromBox)
        object[.toBox] = _toJSValue(toBox)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _fromBox = ReadWriteAttribute(jsObject: object, name: .fromBox)
        _toBox = ReadWriteAttribute(jsObject: object, name: .toBox)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var fromBox: CSSBoxType

    @ReadWriteAttribute
    public var toBox: CSSBoxType
}

public class CountQueuingStrategy: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CountQueuingStrategy].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _highWaterMark = ReadonlyAttribute(jsObject: jsObject, name: .highWaterMark)
        _size = ReadonlyAttribute(jsObject: jsObject, name: .size)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: QueuingStrategyInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var highWaterMark: Double

    @ReadonlyAttribute
    public var size: JSFunction
}

public class CustomElementRegistry: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CustomElementRegistry].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func define(name: String, constructor: CustomElementConstructor, options: ElementDefinitionOptions? = nil) {
        let this = jsObject
        _ = this[.define].function!(this: this, arguments: [_toJSValue(name), _toJSValue(constructor), _toJSValue(options)])
    }

    @inlinable public func get(name: String) -> CustomElementConstructor? {
        let this = jsObject
        return this[.get].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()!
    }

    @inlinable public func getName(constructor: CustomElementConstructor) -> String? {
        let this = jsObject
        return this[.getName].function!(this: this, arguments: [_toJSValue(constructor)]).fromJSValue()
    }

    @inlinable public func whenDefined(name: String) -> JSPromise {
        let this = jsObject
        return this[.whenDefined].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func whenDefined(name: String) async throws -> CustomElementConstructor {
        let this = jsObject
        let _promise: JSPromise = this[.whenDefined].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func upgrade(root: Node) {
        let this = jsObject
        _ = this[.upgrade].function!(this: this, arguments: [_toJSValue(root)])
    }
}

public class CustomEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CustomEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _detail = ReadonlyAttribute(jsObject: jsObject, name: .detail)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: CustomEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var detail: JSValue

    @inlinable public func initCustomEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil, detail: JSValue? = nil) {
        let this = jsObject
        _ = this[.initCustomEvent].function!(this: this, arguments: [_toJSValue(type), _toJSValue(bubbles), _toJSValue(cancelable), _toJSValue(detail)])
    }
}

public class CustomEventInit: BridgedDictionary {
    public convenience init(detail: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        object[.detail] = _toJSValue(detail)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _detail = ReadWriteAttribute(jsObject: object, name: .detail)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var detail: JSValue
}

public class DOMImplementation: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DOMImplementation].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func createDocumentType(qualifiedName: String, publicId: String, systemId: String) -> DocumentType {
        let this = jsObject
        return this[.createDocumentType].function!(this: this, arguments: [_toJSValue(qualifiedName), _toJSValue(publicId), _toJSValue(systemId)]).fromJSValue()!
    }

    @inlinable public func createDocument(namespace: String?, qualifiedName: String, doctype: DocumentType? = nil) -> XMLDocument {
        let this = jsObject
        return this[.createDocument].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(qualifiedName), _toJSValue(doctype)]).fromJSValue()!
    }

    @inlinable public func createHTMLDocument(title: String? = nil) -> Document {
        let this = jsObject
        return this[.createHTMLDocument].function!(this: this, arguments: [_toJSValue(title)]).fromJSValue()!
    }

    @inlinable public func hasFeature() -> Bool {
        let this = jsObject
        return this[.hasFeature].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMMatrix: DOMMatrixReadOnly {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.DOMMatrix].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _a = ReadWriteAttribute(jsObject: jsObject, name: .a)
        _b = ReadWriteAttribute(jsObject: jsObject, name: .b)
        _c = ReadWriteAttribute(jsObject: jsObject, name: .c)
        _d = ReadWriteAttribute(jsObject: jsObject, name: .d)
        _e = ReadWriteAttribute(jsObject: jsObject, name: .e)
        _f = ReadWriteAttribute(jsObject: jsObject, name: .f)
        _m11 = ReadWriteAttribute(jsObject: jsObject, name: .m11)
        _m12 = ReadWriteAttribute(jsObject: jsObject, name: .m12)
        _m13 = ReadWriteAttribute(jsObject: jsObject, name: .m13)
        _m14 = ReadWriteAttribute(jsObject: jsObject, name: .m14)
        _m21 = ReadWriteAttribute(jsObject: jsObject, name: .m21)
        _m22 = ReadWriteAttribute(jsObject: jsObject, name: .m22)
        _m23 = ReadWriteAttribute(jsObject: jsObject, name: .m23)
        _m24 = ReadWriteAttribute(jsObject: jsObject, name: .m24)
        _m31 = ReadWriteAttribute(jsObject: jsObject, name: .m31)
        _m32 = ReadWriteAttribute(jsObject: jsObject, name: .m32)
        _m33 = ReadWriteAttribute(jsObject: jsObject, name: .m33)
        _m34 = ReadWriteAttribute(jsObject: jsObject, name: .m34)
        _m41 = ReadWriteAttribute(jsObject: jsObject, name: .m41)
        _m42 = ReadWriteAttribute(jsObject: jsObject, name: .m42)
        _m43 = ReadWriteAttribute(jsObject: jsObject, name: .m43)
        _m44 = ReadWriteAttribute(jsObject: jsObject, name: .m44)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(init: String_or_seq_of_Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable override public class func fromMatrix(other: DOMMatrixInit? = nil) -> Self {
        let this = constructor!
        return this[.fromMatrix].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable override public class func fromFloat32Array(array32: Float32Array) -> Self {
        let this = constructor!
        return this[.fromFloat32Array].function!(this: this, arguments: [_toJSValue(array32)]).fromJSValue()!
    }

    @inlinable override public class func fromFloat64Array(array64: Float64Array) -> Self {
        let this = constructor!
        return this[.fromFloat64Array].function!(this: this, arguments: [_toJSValue(array64)]).fromJSValue()!
    }

    @usableFromInline let _a: ReadWriteAttribute<Double>
    @inlinable override public var a: Double {
        get { _a.wrappedValue }
        set { _a.wrappedValue = newValue }
    }

    @usableFromInline let _b: ReadWriteAttribute<Double>
    @inlinable override public var b: Double {
        get { _b.wrappedValue }
        set { _b.wrappedValue = newValue }
    }

    @usableFromInline let _c: ReadWriteAttribute<Double>
    @inlinable override public var c: Double {
        get { _c.wrappedValue }
        set { _c.wrappedValue = newValue }
    }

    @usableFromInline let _d: ReadWriteAttribute<Double>
    @inlinable override public var d: Double {
        get { _d.wrappedValue }
        set { _d.wrappedValue = newValue }
    }

    @usableFromInline let _e: ReadWriteAttribute<Double>
    @inlinable override public var e: Double {
        get { _e.wrappedValue }
        set { _e.wrappedValue = newValue }
    }

    @usableFromInline let _f: ReadWriteAttribute<Double>
    @inlinable override public var f: Double {
        get { _f.wrappedValue }
        set { _f.wrappedValue = newValue }
    }

    @usableFromInline let _m11: ReadWriteAttribute<Double>
    @inlinable override public var m11: Double {
        get { _m11.wrappedValue }
        set { _m11.wrappedValue = newValue }
    }

    @usableFromInline let _m12: ReadWriteAttribute<Double>
    @inlinable override public var m12: Double {
        get { _m12.wrappedValue }
        set { _m12.wrappedValue = newValue }
    }

    @usableFromInline let _m13: ReadWriteAttribute<Double>
    @inlinable override public var m13: Double {
        get { _m13.wrappedValue }
        set { _m13.wrappedValue = newValue }
    }

    @usableFromInline let _m14: ReadWriteAttribute<Double>
    @inlinable override public var m14: Double {
        get { _m14.wrappedValue }
        set { _m14.wrappedValue = newValue }
    }

    @usableFromInline let _m21: ReadWriteAttribute<Double>
    @inlinable override public var m21: Double {
        get { _m21.wrappedValue }
        set { _m21.wrappedValue = newValue }
    }

    @usableFromInline let _m22: ReadWriteAttribute<Double>
    @inlinable override public var m22: Double {
        get { _m22.wrappedValue }
        set { _m22.wrappedValue = newValue }
    }

    @usableFromInline let _m23: ReadWriteAttribute<Double>
    @inlinable override public var m23: Double {
        get { _m23.wrappedValue }
        set { _m23.wrappedValue = newValue }
    }

    @usableFromInline let _m24: ReadWriteAttribute<Double>
    @inlinable override public var m24: Double {
        get { _m24.wrappedValue }
        set { _m24.wrappedValue = newValue }
    }

    @usableFromInline let _m31: ReadWriteAttribute<Double>
    @inlinable override public var m31: Double {
        get { _m31.wrappedValue }
        set { _m31.wrappedValue = newValue }
    }

    @usableFromInline let _m32: ReadWriteAttribute<Double>
    @inlinable override public var m32: Double {
        get { _m32.wrappedValue }
        set { _m32.wrappedValue = newValue }
    }

    @usableFromInline let _m33: ReadWriteAttribute<Double>
    @inlinable override public var m33: Double {
        get { _m33.wrappedValue }
        set { _m33.wrappedValue = newValue }
    }

    @usableFromInline let _m34: ReadWriteAttribute<Double>
    @inlinable override public var m34: Double {
        get { _m34.wrappedValue }
        set { _m34.wrappedValue = newValue }
    }

    @usableFromInline let _m41: ReadWriteAttribute<Double>
    @inlinable override public var m41: Double {
        get { _m41.wrappedValue }
        set { _m41.wrappedValue = newValue }
    }

    @usableFromInline let _m42: ReadWriteAttribute<Double>
    @inlinable override public var m42: Double {
        get { _m42.wrappedValue }
        set { _m42.wrappedValue = newValue }
    }

    @usableFromInline let _m43: ReadWriteAttribute<Double>
    @inlinable override public var m43: Double {
        get { _m43.wrappedValue }
        set { _m43.wrappedValue = newValue }
    }

    @usableFromInline let _m44: ReadWriteAttribute<Double>
    @inlinable override public var m44: Double {
        get { _m44.wrappedValue }
        set { _m44.wrappedValue = newValue }
    }

    @inlinable public func multiplySelf(other: DOMMatrixInit? = nil) -> Self {
        let this = jsObject
        return this[.multiplySelf].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public func preMultiplySelf(other: DOMMatrixInit? = nil) -> Self {
        let this = jsObject
        return this[.preMultiplySelf].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public func translateSelf(tx: Double? = nil, ty: Double? = nil, tz: Double? = nil) -> Self {
        let this = jsObject
        return this[.translateSelf].function!(this: this, arguments: [_toJSValue(tx), _toJSValue(ty), _toJSValue(tz)]).fromJSValue()!
    }

    @inlinable public func scaleSelf(scaleX: Double? = nil, scaleY: Double? = nil, scaleZ: Double? = nil, originX: Double? = nil, originY: Double? = nil, originZ: Double? = nil) -> Self {
        let this = jsObject
        return this[.scaleSelf].function!(this: this, arguments: [_toJSValue(scaleX), _toJSValue(scaleY), _toJSValue(scaleZ), _toJSValue(originX), _toJSValue(originY), _toJSValue(originZ)]).fromJSValue()!
    }

    @inlinable public func scale3dSelf(scale: Double? = nil, originX: Double? = nil, originY: Double? = nil, originZ: Double? = nil) -> Self {
        let this = jsObject
        return this[.scale3dSelf].function!(this: this, arguments: [_toJSValue(scale), _toJSValue(originX), _toJSValue(originY), _toJSValue(originZ)]).fromJSValue()!
    }

    @inlinable public func rotateSelf(rotX: Double? = nil, rotY: Double? = nil, rotZ: Double? = nil) -> Self {
        let this = jsObject
        return this[.rotateSelf].function!(this: this, arguments: [_toJSValue(rotX), _toJSValue(rotY), _toJSValue(rotZ)]).fromJSValue()!
    }

    @inlinable public func rotateFromVectorSelf(x: Double? = nil, y: Double? = nil) -> Self {
        let this = jsObject
        return this[.rotateFromVectorSelf].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)]).fromJSValue()!
    }

    @inlinable public func rotateAxisAngleSelf(x: Double? = nil, y: Double? = nil, z: Double? = nil, angle: Double? = nil) -> Self {
        let this = jsObject
        return this[.rotateAxisAngleSelf].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z), _toJSValue(angle)]).fromJSValue()!
    }

    @inlinable public func skewXSelf(sx: Double? = nil) -> Self {
        let this = jsObject
        return this[.skewXSelf].function!(this: this, arguments: [_toJSValue(sx)]).fromJSValue()!
    }

    @inlinable public func skewYSelf(sy: Double? = nil) -> Self {
        let this = jsObject
        return this[.skewYSelf].function!(this: this, arguments: [_toJSValue(sy)]).fromJSValue()!
    }

    @inlinable public func invertSelf() -> Self {
        let this = jsObject
        return this[.invertSelf].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setMatrixValue(transformList: String) -> Self {
        let this = jsObject
        return this[.setMatrixValue].function!(this: this, arguments: [_toJSValue(transformList)]).fromJSValue()!
    }
}

public class DOMMatrix2DInit: BridgedDictionary {
    public convenience init(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double, m11: Double, m12: Double, m21: Double, m22: Double, m41: Double, m42: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.a] = _toJSValue(a)
        object[.b] = _toJSValue(b)
        object[.c] = _toJSValue(c)
        object[.d] = _toJSValue(d)
        object[.e] = _toJSValue(e)
        object[.f] = _toJSValue(f)
        object[.m11] = _toJSValue(m11)
        object[.m12] = _toJSValue(m12)
        object[.m21] = _toJSValue(m21)
        object[.m22] = _toJSValue(m22)
        object[.m41] = _toJSValue(m41)
        object[.m42] = _toJSValue(m42)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _a = ReadWriteAttribute(jsObject: object, name: .a)
        _b = ReadWriteAttribute(jsObject: object, name: .b)
        _c = ReadWriteAttribute(jsObject: object, name: .c)
        _d = ReadWriteAttribute(jsObject: object, name: .d)
        _e = ReadWriteAttribute(jsObject: object, name: .e)
        _f = ReadWriteAttribute(jsObject: object, name: .f)
        _m11 = ReadWriteAttribute(jsObject: object, name: .m11)
        _m12 = ReadWriteAttribute(jsObject: object, name: .m12)
        _m21 = ReadWriteAttribute(jsObject: object, name: .m21)
        _m22 = ReadWriteAttribute(jsObject: object, name: .m22)
        _m41 = ReadWriteAttribute(jsObject: object, name: .m41)
        _m42 = ReadWriteAttribute(jsObject: object, name: .m42)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var a: Double

    @ReadWriteAttribute
    public var b: Double

    @ReadWriteAttribute
    public var c: Double

    @ReadWriteAttribute
    public var d: Double

    @ReadWriteAttribute
    public var e: Double

    @ReadWriteAttribute
    public var f: Double

    @ReadWriteAttribute
    public var m11: Double

    @ReadWriteAttribute
    public var m12: Double

    @ReadWriteAttribute
    public var m21: Double

    @ReadWriteAttribute
    public var m22: Double

    @ReadWriteAttribute
    public var m41: Double

    @ReadWriteAttribute
    public var m42: Double
}

public class DOMMatrixInit: BridgedDictionary {
    public convenience init(m13: Double, m14: Double, m23: Double, m24: Double, m31: Double, m32: Double, m33: Double, m34: Double, m43: Double, m44: Double, is2D: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.m13] = _toJSValue(m13)
        object[.m14] = _toJSValue(m14)
        object[.m23] = _toJSValue(m23)
        object[.m24] = _toJSValue(m24)
        object[.m31] = _toJSValue(m31)
        object[.m32] = _toJSValue(m32)
        object[.m33] = _toJSValue(m33)
        object[.m34] = _toJSValue(m34)
        object[.m43] = _toJSValue(m43)
        object[.m44] = _toJSValue(m44)
        object[.is2D] = _toJSValue(is2D)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _m13 = ReadWriteAttribute(jsObject: object, name: .m13)
        _m14 = ReadWriteAttribute(jsObject: object, name: .m14)
        _m23 = ReadWriteAttribute(jsObject: object, name: .m23)
        _m24 = ReadWriteAttribute(jsObject: object, name: .m24)
        _m31 = ReadWriteAttribute(jsObject: object, name: .m31)
        _m32 = ReadWriteAttribute(jsObject: object, name: .m32)
        _m33 = ReadWriteAttribute(jsObject: object, name: .m33)
        _m34 = ReadWriteAttribute(jsObject: object, name: .m34)
        _m43 = ReadWriteAttribute(jsObject: object, name: .m43)
        _m44 = ReadWriteAttribute(jsObject: object, name: .m44)
        _is2D = ReadWriteAttribute(jsObject: object, name: .is2D)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var m13: Double

    @ReadWriteAttribute
    public var m14: Double

    @ReadWriteAttribute
    public var m23: Double

    @ReadWriteAttribute
    public var m24: Double

    @ReadWriteAttribute
    public var m31: Double

    @ReadWriteAttribute
    public var m32: Double

    @ReadWriteAttribute
    public var m33: Double

    @ReadWriteAttribute
    public var m34: Double

    @ReadWriteAttribute
    public var m43: Double

    @ReadWriteAttribute
    public var m44: Double

    @ReadWriteAttribute
    public var is2D: Bool
}

public class DOMMatrixReadOnly: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DOMMatrixReadOnly].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _a = ReadonlyAttribute(jsObject: jsObject, name: .a)
        _b = ReadonlyAttribute(jsObject: jsObject, name: .b)
        _c = ReadonlyAttribute(jsObject: jsObject, name: .c)
        _d = ReadonlyAttribute(jsObject: jsObject, name: .d)
        _e = ReadonlyAttribute(jsObject: jsObject, name: .e)
        _f = ReadonlyAttribute(jsObject: jsObject, name: .f)
        _m11 = ReadonlyAttribute(jsObject: jsObject, name: .m11)
        _m12 = ReadonlyAttribute(jsObject: jsObject, name: .m12)
        _m13 = ReadonlyAttribute(jsObject: jsObject, name: .m13)
        _m14 = ReadonlyAttribute(jsObject: jsObject, name: .m14)
        _m21 = ReadonlyAttribute(jsObject: jsObject, name: .m21)
        _m22 = ReadonlyAttribute(jsObject: jsObject, name: .m22)
        _m23 = ReadonlyAttribute(jsObject: jsObject, name: .m23)
        _m24 = ReadonlyAttribute(jsObject: jsObject, name: .m24)
        _m31 = ReadonlyAttribute(jsObject: jsObject, name: .m31)
        _m32 = ReadonlyAttribute(jsObject: jsObject, name: .m32)
        _m33 = ReadonlyAttribute(jsObject: jsObject, name: .m33)
        _m34 = ReadonlyAttribute(jsObject: jsObject, name: .m34)
        _m41 = ReadonlyAttribute(jsObject: jsObject, name: .m41)
        _m42 = ReadonlyAttribute(jsObject: jsObject, name: .m42)
        _m43 = ReadonlyAttribute(jsObject: jsObject, name: .m43)
        _m44 = ReadonlyAttribute(jsObject: jsObject, name: .m44)
        _is2D = ReadonlyAttribute(jsObject: jsObject, name: .is2D)
        _isIdentity = ReadonlyAttribute(jsObject: jsObject, name: .isIdentity)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: String_or_seq_of_Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public class func fromMatrix(other: DOMMatrixInit? = nil) -> Self {
        let this = constructor!
        return this[.fromMatrix].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public class func fromFloat32Array(array32: Float32Array) -> Self {
        let this = constructor!
        return this[.fromFloat32Array].function!(this: this, arguments: [_toJSValue(array32)]).fromJSValue()!
    }

    @inlinable public class func fromFloat64Array(array64: Float64Array) -> Self {
        let this = constructor!
        return this[.fromFloat64Array].function!(this: this, arguments: [_toJSValue(array64)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var a: Double

    @ReadonlyAttribute
    public var b: Double

    @ReadonlyAttribute
    public var c: Double

    @ReadonlyAttribute
    public var d: Double

    @ReadonlyAttribute
    public var e: Double

    @ReadonlyAttribute
    public var f: Double

    @ReadonlyAttribute
    public var m11: Double

    @ReadonlyAttribute
    public var m12: Double

    @ReadonlyAttribute
    public var m13: Double

    @ReadonlyAttribute
    public var m14: Double

    @ReadonlyAttribute
    public var m21: Double

    @ReadonlyAttribute
    public var m22: Double

    @ReadonlyAttribute
    public var m23: Double

    @ReadonlyAttribute
    public var m24: Double

    @ReadonlyAttribute
    public var m31: Double

    @ReadonlyAttribute
    public var m32: Double

    @ReadonlyAttribute
    public var m33: Double

    @ReadonlyAttribute
    public var m34: Double

    @ReadonlyAttribute
    public var m41: Double

    @ReadonlyAttribute
    public var m42: Double

    @ReadonlyAttribute
    public var m43: Double

    @ReadonlyAttribute
    public var m44: Double

    @ReadonlyAttribute
    public var is2D: Bool

    @ReadonlyAttribute
    public var isIdentity: Bool

    @inlinable public func translate(tx: Double? = nil, ty: Double? = nil, tz: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[.translate].function!(this: this, arguments: [_toJSValue(tx), _toJSValue(ty), _toJSValue(tz)]).fromJSValue()!
    }

    @inlinable public func scale(scaleX: Double? = nil, scaleY: Double? = nil, scaleZ: Double? = nil, originX: Double? = nil, originY: Double? = nil, originZ: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[.scale].function!(this: this, arguments: [_toJSValue(scaleX), _toJSValue(scaleY), _toJSValue(scaleZ), _toJSValue(originX), _toJSValue(originY), _toJSValue(originZ)]).fromJSValue()!
    }

    @inlinable public func scaleNonUniform(scaleX: Double? = nil, scaleY: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[.scaleNonUniform].function!(this: this, arguments: [_toJSValue(scaleX), _toJSValue(scaleY)]).fromJSValue()!
    }

    @inlinable public func scale3d(scale: Double? = nil, originX: Double? = nil, originY: Double? = nil, originZ: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[.scale3d].function!(this: this, arguments: [_toJSValue(scale), _toJSValue(originX), _toJSValue(originY), _toJSValue(originZ)]).fromJSValue()!
    }

    @inlinable public func rotate(rotX: Double? = nil, rotY: Double? = nil, rotZ: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[.rotate].function!(this: this, arguments: [_toJSValue(rotX), _toJSValue(rotY), _toJSValue(rotZ)]).fromJSValue()!
    }

    @inlinable public func rotateFromVector(x: Double? = nil, y: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[.rotateFromVector].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)]).fromJSValue()!
    }

    @inlinable public func rotateAxisAngle(x: Double? = nil, y: Double? = nil, z: Double? = nil, angle: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[.rotateAxisAngle].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z), _toJSValue(angle)]).fromJSValue()!
    }

    @inlinable public func skewX(sx: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[.skewX].function!(this: this, arguments: [_toJSValue(sx)]).fromJSValue()!
    }

    @inlinable public func skewY(sy: Double? = nil) -> DOMMatrix {
        let this = jsObject
        return this[.skewY].function!(this: this, arguments: [_toJSValue(sy)]).fromJSValue()!
    }

    @inlinable public func multiply(other: DOMMatrixInit? = nil) -> DOMMatrix {
        let this = jsObject
        return this[.multiply].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public func flipX() -> DOMMatrix {
        let this = jsObject
        return this[.flipX].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func flipY() -> DOMMatrix {
        let this = jsObject
        return this[.flipY].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func inverse() -> DOMMatrix {
        let this = jsObject
        return this[.inverse].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func transformPoint(point: DOMPointInit? = nil) -> DOMPoint {
        let this = jsObject
        return this[.transformPoint].function!(this: this, arguments: [_toJSValue(point)]).fromJSValue()!
    }

    @inlinable public func toFloat32Array() -> Float32Array {
        let this = jsObject
        return this[.toFloat32Array].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func toFloat64Array() -> Float64Array {
        let this = jsObject
        return this[.toFloat64Array].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var description: String {
        jsObject[.toString]!().fromJSValue()!
    }

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMParser: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DOMParser].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @inlinable public func parseFromString(string: String, type: DOMParserSupportedType) -> Document {
        let this = jsObject
        return this[.parseFromString].function!(this: this, arguments: [_toJSValue(string), _toJSValue(type)]).fromJSValue()!
    }
}

public enum DOMParserSupportedType: JSString, JSValueCompatible {
    case textHtml = "text/html"
    case textXml = "text/xml"
    case applicationXml = "application/xml"
    case applicationXhtmlXml = "application/xhtml+xml"
    case imageSvgXml = "image/svg+xml"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class DOMPoint: DOMPointReadOnly {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.DOMPoint].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _x = ReadWriteAttribute(jsObject: jsObject, name: .x)
        _y = ReadWriteAttribute(jsObject: jsObject, name: .y)
        _z = ReadWriteAttribute(jsObject: jsObject, name: .z)
        _w = ReadWriteAttribute(jsObject: jsObject, name: .w)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(x: Double? = nil, y: Double? = nil, z: Double? = nil, w: Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z), _toJSValue(w)]))
    }

    @inlinable override public class func fromPoint(other: DOMPointInit? = nil) -> Self {
        let this = constructor!
        return this[.fromPoint].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @usableFromInline let _x: ReadWriteAttribute<Double>
    @inlinable override public var x: Double {
        get { _x.wrappedValue }
        set { _x.wrappedValue = newValue }
    }

    @usableFromInline let _y: ReadWriteAttribute<Double>
    @inlinable override public var y: Double {
        get { _y.wrappedValue }
        set { _y.wrappedValue = newValue }
    }

    @usableFromInline let _z: ReadWriteAttribute<Double>
    @inlinable override public var z: Double {
        get { _z.wrappedValue }
        set { _z.wrappedValue = newValue }
    }

    @usableFromInline let _w: ReadWriteAttribute<Double>
    @inlinable override public var w: Double {
        get { _w.wrappedValue }
        set { _w.wrappedValue = newValue }
    }
}

public class DOMPointInit: BridgedDictionary {
    public convenience init(x: Double, y: Double, z: Double, w: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.x] = _toJSValue(x)
        object[.y] = _toJSValue(y)
        object[.z] = _toJSValue(z)
        object[.w] = _toJSValue(w)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _x = ReadWriteAttribute(jsObject: object, name: .x)
        _y = ReadWriteAttribute(jsObject: object, name: .y)
        _z = ReadWriteAttribute(jsObject: object, name: .z)
        _w = ReadWriteAttribute(jsObject: object, name: .w)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var x: Double

    @ReadWriteAttribute
    public var y: Double

    @ReadWriteAttribute
    public var z: Double

    @ReadWriteAttribute
    public var w: Double
}

public class DOMPointReadOnly: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DOMPointReadOnly].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _x = ReadonlyAttribute(jsObject: jsObject, name: .x)
        _y = ReadonlyAttribute(jsObject: jsObject, name: .y)
        _z = ReadonlyAttribute(jsObject: jsObject, name: .z)
        _w = ReadonlyAttribute(jsObject: jsObject, name: .w)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(x: Double? = nil, y: Double? = nil, z: Double? = nil, w: Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z), _toJSValue(w)]))
    }

    @inlinable public class func fromPoint(other: DOMPointInit? = nil) -> Self {
        let this = constructor!
        return this[.fromPoint].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var x: Double

    @ReadonlyAttribute
    public var y: Double

    @ReadonlyAttribute
    public var z: Double

    @ReadonlyAttribute
    public var w: Double

    @inlinable public func matrixTransform(matrix: DOMMatrixInit? = nil) -> DOMPoint {
        let this = jsObject
        return this[.matrixTransform].function!(this: this, arguments: [_toJSValue(matrix)]).fromJSValue()!
    }

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMQuad: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DOMQuad].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _p1 = ReadonlyAttribute(jsObject: jsObject, name: .p1)
        _p2 = ReadonlyAttribute(jsObject: jsObject, name: .p2)
        _p3 = ReadonlyAttribute(jsObject: jsObject, name: .p3)
        _p4 = ReadonlyAttribute(jsObject: jsObject, name: .p4)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(p1: DOMPointInit? = nil, p2: DOMPointInit? = nil, p3: DOMPointInit? = nil, p4: DOMPointInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(p1), _toJSValue(p2), _toJSValue(p3), _toJSValue(p4)]))
    }

    @inlinable public class func fromRect(other: DOMRectInit? = nil) -> Self {
        let this = constructor!
        return this[.fromRect].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public class func fromQuad(other: DOMQuadInit? = nil) -> Self {
        let this = constructor!
        return this[.fromQuad].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var p1: DOMPoint

    @ReadonlyAttribute
    public var p2: DOMPoint

    @ReadonlyAttribute
    public var p3: DOMPoint

    @ReadonlyAttribute
    public var p4: DOMPoint

    @inlinable public func getBounds() -> DOMRect {
        let this = jsObject
        return this[.getBounds].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMQuadInit: BridgedDictionary {
    public convenience init(p1: DOMPointInit, p2: DOMPointInit, p3: DOMPointInit, p4: DOMPointInit) {
        let object = JSObject.global[.Object].function!.new()
        object[.p1] = _toJSValue(p1)
        object[.p2] = _toJSValue(p2)
        object[.p3] = _toJSValue(p3)
        object[.p4] = _toJSValue(p4)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _p1 = ReadWriteAttribute(jsObject: object, name: .p1)
        _p2 = ReadWriteAttribute(jsObject: object, name: .p2)
        _p3 = ReadWriteAttribute(jsObject: object, name: .p3)
        _p4 = ReadWriteAttribute(jsObject: object, name: .p4)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var p1: DOMPointInit

    @ReadWriteAttribute
    public var p2: DOMPointInit

    @ReadWriteAttribute
    public var p3: DOMPointInit

    @ReadWriteAttribute
    public var p4: DOMPointInit
}

public class DOMRect: DOMRectReadOnly {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.DOMRect].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _x = ReadWriteAttribute(jsObject: jsObject, name: .x)
        _y = ReadWriteAttribute(jsObject: jsObject, name: .y)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height)]))
    }

    @inlinable override public class func fromRect(other: DOMRectInit? = nil) -> Self {
        let this = constructor!
        return this[.fromRect].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @usableFromInline let _x: ReadWriteAttribute<Double>
    @inlinable override public var x: Double {
        get { _x.wrappedValue }
        set { _x.wrappedValue = newValue }
    }

    @usableFromInline let _y: ReadWriteAttribute<Double>
    @inlinable override public var y: Double {
        get { _y.wrappedValue }
        set { _y.wrappedValue = newValue }
    }

    @usableFromInline let _width: ReadWriteAttribute<Double>
    @inlinable override public var width: Double {
        get { _width.wrappedValue }
        set { _width.wrappedValue = newValue }
    }

    @usableFromInline let _height: ReadWriteAttribute<Double>
    @inlinable override public var height: Double {
        get { _height.wrappedValue }
        set { _height.wrappedValue = newValue }
    }
}

public class DOMRectInit: BridgedDictionary {
    public convenience init(x: Double, y: Double, width: Double, height: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.x] = _toJSValue(x)
        object[.y] = _toJSValue(y)
        object[.width] = _toJSValue(width)
        object[.height] = _toJSValue(height)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _x = ReadWriteAttribute(jsObject: object, name: .x)
        _y = ReadWriteAttribute(jsObject: object, name: .y)
        _width = ReadWriteAttribute(jsObject: object, name: .width)
        _height = ReadWriteAttribute(jsObject: object, name: .height)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var x: Double

    @ReadWriteAttribute
    public var y: Double

    @ReadWriteAttribute
    public var width: Double

    @ReadWriteAttribute
    public var height: Double
}

public class DOMRectList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DOMRectList].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> DOMRect? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(index: UInt32) -> DOMRect? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
}

public class DOMRectReadOnly: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DOMRectReadOnly].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _x = ReadonlyAttribute(jsObject: jsObject, name: .x)
        _y = ReadonlyAttribute(jsObject: jsObject, name: .y)
        _width = ReadonlyAttribute(jsObject: jsObject, name: .width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: .height)
        _top = ReadonlyAttribute(jsObject: jsObject, name: .top)
        _right = ReadonlyAttribute(jsObject: jsObject, name: .right)
        _bottom = ReadonlyAttribute(jsObject: jsObject, name: .bottom)
        _left = ReadonlyAttribute(jsObject: jsObject, name: .left)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height)]))
    }

    @inlinable public class func fromRect(other: DOMRectInit? = nil) -> Self {
        let this = constructor!
        return this[.fromRect].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var x: Double

    @ReadonlyAttribute
    public var y: Double

    @ReadonlyAttribute
    public var width: Double

    @ReadonlyAttribute
    public var height: Double

    @ReadonlyAttribute
    public var top: Double

    @ReadonlyAttribute
    public var right: Double

    @ReadonlyAttribute
    public var bottom: Double

    @ReadonlyAttribute
    public var left: Double

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMStringList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DOMStringList].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> String? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(index: UInt32) -> String? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public func contains(string: String) -> Bool {
        let this = jsObject
        return this[.contains].function!(this: this, arguments: [_toJSValue(string)]).fromJSValue()!
    }
}

public class DOMStringMap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DOMStringMap].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: String) -> String {
        get {
            jsObject[key].fromJSValue()!
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }

    @inlinable public func removeValue(forKey key: String) {
        _ = JSObject.global.Reflect.deleteProperty(jsObject, _toJSValue(key))
    }
}

public class DOMTokenList: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DOMTokenList].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> String? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(index: UInt32) -> String? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public func contains(token: String) -> Bool {
        let this = jsObject
        return this[.contains].function!(this: this, arguments: [_toJSValue(token)]).fromJSValue()!
    }

    @inlinable public func add(tokens: String...) {
        let this = jsObject
        _ = this[.add].function!(this: this, arguments: tokens.map(_toJSValue))
    }

    @inlinable public func remove(tokens: String...) {
        let this = jsObject
        _ = this[.remove].function!(this: this, arguments: tokens.map(_toJSValue))
    }

    @inlinable public func toggle(token: String, force: Bool? = nil) -> Bool {
        let this = jsObject
        return this[.toggle].function!(this: this, arguments: [_toJSValue(token), _toJSValue(force)]).fromJSValue()!
    }

    @inlinable public func replace(token: String, newToken: String) -> Bool {
        let this = jsObject
        return this[.replace].function!(this: this, arguments: [_toJSValue(token), _toJSValue(newToken)]).fromJSValue()!
    }

    @inlinable public func supports(token: String) -> Bool {
        let this = jsObject
        return this[.supports].function!(this: this, arguments: [_toJSValue(token)]).fromJSValue()!
    }

    @ReadWriteAttribute
    public var value: String

    public typealias Element = String
    public func makeIterator() -> ValueIterableIterator<DOMTokenList> {
        ValueIterableIterator(sequence: self)
    }
}

public class DataTransfer: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DataTransfer].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _dropEffect = ReadWriteAttribute(jsObject: jsObject, name: .dropEffect)
        _effectAllowed = ReadWriteAttribute(jsObject: jsObject, name: .effectAllowed)
        _items = ReadonlyAttribute(jsObject: jsObject, name: .items)
        _types = ReadonlyAttribute(jsObject: jsObject, name: .types)
        _files = ReadonlyAttribute(jsObject: jsObject, name: .files)
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var dropEffect: String

    @ReadWriteAttribute
    public var effectAllowed: String

    @ReadonlyAttribute
    public var items: DataTransferItemList

    @inlinable public func setDragImage(image: Element, x: Int32, y: Int32) {
        let this = jsObject
        _ = this[.setDragImage].function!(this: this, arguments: [_toJSValue(image), _toJSValue(x), _toJSValue(y)])
    }

    @ReadonlyAttribute
    public var types: [String]

    @inlinable public func getData(format: String) -> String {
        let this = jsObject
        return this[.getData].function!(this: this, arguments: [_toJSValue(format)]).fromJSValue()!
    }

    @inlinable public func setData(format: String, data: String) {
        let this = jsObject
        _ = this[.setData].function!(this: this, arguments: [_toJSValue(format), _toJSValue(data)])
    }

    @inlinable public func clearData(format: String? = nil) {
        let this = jsObject
        _ = this[.clearData].function!(this: this, arguments: [_toJSValue(format)])
    }

    @ReadonlyAttribute
    public var files: FileList
}

public class DataTransferItem: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DataTransferItem].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadonlyAttribute(jsObject: jsObject, name: .kind)
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var kind: String

    @ReadonlyAttribute
    public var type: String

    @inlinable public func getAsString(callback: FunctionStringCallback?) {
        let this = jsObject
        _ = this[.getAsString].function!(this: this, arguments: [_toJSValue(callback)])
    }

    @inlinable public func getAsFile() -> File? {
        let this = jsObject
        return this[.getAsFile].function!(this: this, arguments: []).fromJSValue()
    }
}

public class DataTransferItemList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.DataTransferItemList].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> DataTransferItem {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func add(data: String, type: String) -> DataTransferItem? {
        let this = jsObject
        return this[.add].function!(this: this, arguments: [_toJSValue(data), _toJSValue(type)]).fromJSValue()
    }

    @inlinable public func add(data: File) -> DataTransferItem? {
        let this = jsObject
        return this[.add].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()
    }

    @inlinable public func remove(index: UInt32) {
        let this = jsObject
        _ = this[.remove].function!(this: this, arguments: [_toJSValue(index)])
    }

    @inlinable public func clear() {
        let this = jsObject
        _ = this[.clear].function!(this: this, arguments: [])
    }
}

public class DevicePermissionDescriptor: BridgedDictionary {
    public convenience init(deviceId: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.deviceId] = _toJSValue(deviceId)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _deviceId = ReadWriteAttribute(jsObject: object, name: .deviceId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var deviceId: String
}

public class Document: Node, NonElementParentNode, DocumentOrShadowRoot, ParentNode, XPathEvaluatorBase, GlobalEventHandlers, GeometryUtils {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.Document].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _implementation = ReadonlyAttribute(jsObject: jsObject, name: .implementation)
        _URL = ReadonlyAttribute(jsObject: jsObject, name: .URL)
        _documentURI = ReadonlyAttribute(jsObject: jsObject, name: .documentURI)
        _compatMode = ReadonlyAttribute(jsObject: jsObject, name: .compatMode)
        _characterSet = ReadonlyAttribute(jsObject: jsObject, name: .characterSet)
        _charset = ReadonlyAttribute(jsObject: jsObject, name: .charset)
        _inputEncoding = ReadonlyAttribute(jsObject: jsObject, name: .inputEncoding)
        _contentType = ReadonlyAttribute(jsObject: jsObject, name: .contentType)
        _doctype = ReadonlyAttribute(jsObject: jsObject, name: .doctype)
        _documentElement = ReadonlyAttribute(jsObject: jsObject, name: .documentElement)
        _location = ReadonlyAttribute(jsObject: jsObject, name: .location)
        _domain = ReadWriteAttribute(jsObject: jsObject, name: .domain)
        _referrer = ReadonlyAttribute(jsObject: jsObject, name: .referrer)
        _cookie = ReadWriteAttribute(jsObject: jsObject, name: .cookie)
        _lastModified = ReadonlyAttribute(jsObject: jsObject, name: .lastModified)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: .readyState)
        _title = ReadWriteAttribute(jsObject: jsObject, name: .title)
        _dir = ReadWriteAttribute(jsObject: jsObject, name: .dir)
        _body = ReadWriteAttribute(jsObject: jsObject, name: .body)
        _head = ReadonlyAttribute(jsObject: jsObject, name: .head)
        _images = ReadonlyAttribute(jsObject: jsObject, name: .images)
        _embeds = ReadonlyAttribute(jsObject: jsObject, name: .embeds)
        _plugins = ReadonlyAttribute(jsObject: jsObject, name: .plugins)
        _links = ReadonlyAttribute(jsObject: jsObject, name: .links)
        _forms = ReadonlyAttribute(jsObject: jsObject, name: .forms)
        _scripts = ReadonlyAttribute(jsObject: jsObject, name: .scripts)
        _currentScript = ReadonlyAttribute(jsObject: jsObject, name: .currentScript)
        _defaultView = ReadonlyAttribute(jsObject: jsObject, name: .defaultView)
        _designMode = ReadWriteAttribute(jsObject: jsObject, name: .designMode)
        _hidden = ReadonlyAttribute(jsObject: jsObject, name: .hidden)
        _visibilityState = ReadonlyAttribute(jsObject: jsObject, name: .visibilityState)
        _onreadystatechange = ClosureAttribute1Optional(jsObject: jsObject, name: .onreadystatechange)
        _onvisibilitychange = ClosureAttribute1Optional(jsObject: jsObject, name: .onvisibilitychange)
        _fgColor = ReadWriteAttribute(jsObject: jsObject, name: .fgColor)
        _linkColor = ReadWriteAttribute(jsObject: jsObject, name: .linkColor)
        _vlinkColor = ReadWriteAttribute(jsObject: jsObject, name: .vlinkColor)
        _alinkColor = ReadWriteAttribute(jsObject: jsObject, name: .alinkColor)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: .bgColor)
        _anchors = ReadonlyAttribute(jsObject: jsObject, name: .anchors)
        _applets = ReadonlyAttribute(jsObject: jsObject, name: .applets)
        _all = ReadonlyAttribute(jsObject: jsObject, name: .all)
        _scrollingElement = ReadonlyAttribute(jsObject: jsObject, name: .scrollingElement)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var implementation: DOMImplementation

    @ReadonlyAttribute
    public var URL: String

    @ReadonlyAttribute
    public var documentURI: String

    @ReadonlyAttribute
    public var compatMode: String

    @ReadonlyAttribute
    public var characterSet: String

    @ReadonlyAttribute
    public var charset: String

    @ReadonlyAttribute
    public var inputEncoding: String

    @ReadonlyAttribute
    public var contentType: String

    @ReadonlyAttribute
    public var doctype: DocumentType?

    @ReadonlyAttribute
    public var documentElement: Element?

    @inlinable public func getElementsByTagName(qualifiedName: String) -> HTMLCollection {
        let this = jsObject
        return this[.getElementsByTagName].function!(this: this, arguments: [_toJSValue(qualifiedName)]).fromJSValue()!
    }

    @inlinable public func getElementsByTagNameNS(namespace: String?, localName: String) -> HTMLCollection {
        let this = jsObject
        return this[.getElementsByTagNameNS].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(localName)]).fromJSValue()!
    }

    @inlinable public func getElementsByClassName(classNames: String) -> HTMLCollection {
        let this = jsObject
        return this[.getElementsByClassName].function!(this: this, arguments: [_toJSValue(classNames)]).fromJSValue()!
    }

    @inlinable public func createElement(localName: String, options: ElementCreationOptions_or_String? = nil) -> Element {
        let this = jsObject
        return this[.createElement].function!(this: this, arguments: [_toJSValue(localName), _toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func createElementNS(namespace: String?, qualifiedName: String, options: ElementCreationOptions_or_String? = nil) -> Element {
        let this = jsObject
        return this[.createElementNS].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(qualifiedName), _toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func createDocumentFragment() -> DocumentFragment {
        let this = jsObject
        return this[.createDocumentFragment].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func createTextNode(data: String) -> Text {
        let this = jsObject
        return this[.createTextNode].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()!
    }

    @inlinable public func createCDATASection(data: String) -> CDATASection {
        let this = jsObject
        return this[.createCDATASection].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()!
    }

    @inlinable public func createComment(data: String) -> Comment {
        let this = jsObject
        return this[.createComment].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()!
    }

    @inlinable public func createProcessingInstruction(target: String, data: String) -> ProcessingInstruction {
        let this = jsObject
        return this[.createProcessingInstruction].function!(this: this, arguments: [_toJSValue(target), _toJSValue(data)]).fromJSValue()!
    }

    @inlinable public func importNode(node: Node, deep: Bool? = nil) -> Node {
        let this = jsObject
        return this[.importNode].function!(this: this, arguments: [_toJSValue(node), _toJSValue(deep)]).fromJSValue()!
    }

    @inlinable public func adoptNode(node: Node) -> Node {
        let this = jsObject
        return this[.adoptNode].function!(this: this, arguments: [_toJSValue(node)]).fromJSValue()!
    }

    @inlinable public func createAttribute(localName: String) -> Attr {
        let this = jsObject
        return this[.createAttribute].function!(this: this, arguments: [_toJSValue(localName)]).fromJSValue()!
    }

    @inlinable public func createAttributeNS(namespace: String?, qualifiedName: String) -> Attr {
        let this = jsObject
        return this[.createAttributeNS].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(qualifiedName)]).fromJSValue()!
    }

    @inlinable public func createEvent(interface: String) -> Event {
        let this = jsObject
        return this[.createEvent].function!(this: this, arguments: [_toJSValue(interface)]).fromJSValue()!
    }

    @inlinable public func createRange() -> Range {
        let this = jsObject
        return this[.createRange].function!(this: this, arguments: []).fromJSValue()!
    }

    // XXX: member 'createNodeIterator' is ignored

    // XXX: member 'createTreeWalker' is ignored

    @ReadonlyAttribute
    public var location: Location?

    @ReadWriteAttribute
    public var domain: String

    @ReadonlyAttribute
    public var referrer: String

    @ReadWriteAttribute
    public var cookie: String

    @ReadonlyAttribute
    public var lastModified: String

    @ReadonlyAttribute
    public var readyState: DocumentReadyState

    @inlinable public subscript(key: String) -> JSObject {
        jsObject[key].fromJSValue()!
    }

    @ReadWriteAttribute
    public var title: String

    @ReadWriteAttribute
    public var dir: String

    @ReadWriteAttribute
    public var body: HTMLElement?

    @ReadonlyAttribute
    public var head: HTMLHeadElement?

    @ReadonlyAttribute
    public var images: HTMLCollection

    @ReadonlyAttribute
    public var embeds: HTMLCollection

    @ReadonlyAttribute
    public var plugins: HTMLCollection

    @ReadonlyAttribute
    public var links: HTMLCollection

    @ReadonlyAttribute
    public var forms: HTMLCollection

    @ReadonlyAttribute
    public var scripts: HTMLCollection

    @inlinable public func getElementsByName(elementName: String) -> NodeList {
        let this = jsObject
        return this[.getElementsByName].function!(this: this, arguments: [_toJSValue(elementName)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var currentScript: HTMLOrSVGScriptElement?

    @inlinable public func open(unused1: String? = nil, unused2: String? = nil) -> Self {
        let this = jsObject
        return this[.open].function!(this: this, arguments: [_toJSValue(unused1), _toJSValue(unused2)]).fromJSValue()!
    }

    @inlinable public func open(url: String, name: String, features: String) -> WindowProxy? {
        let this = jsObject
        return this[.open].function!(this: this, arguments: [_toJSValue(url), _toJSValue(name), _toJSValue(features)]).fromJSValue()
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }

    @inlinable public func write(text: String...) {
        let this = jsObject
        _ = this[.write].function!(this: this, arguments: text.map(_toJSValue))
    }

    @inlinable public func writeln(text: String...) {
        let this = jsObject
        _ = this[.writeln].function!(this: this, arguments: text.map(_toJSValue))
    }

    @ReadonlyAttribute
    public var defaultView: WindowProxy?

    @inlinable public func hasFocus() -> Bool {
        let this = jsObject
        return this[.hasFocus].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadWriteAttribute
    public var designMode: String

    @inlinable public func execCommand(commandId: String, showUI: Bool? = nil, value: String? = nil) -> Bool {
        let this = jsObject
        return this[.execCommand].function!(this: this, arguments: [_toJSValue(commandId), _toJSValue(showUI), _toJSValue(value)]).fromJSValue()!
    }

    @inlinable public func queryCommandEnabled(commandId: String) -> Bool {
        let this = jsObject
        return this[.queryCommandEnabled].function!(this: this, arguments: [_toJSValue(commandId)]).fromJSValue()!
    }

    @inlinable public func queryCommandIndeterm(commandId: String) -> Bool {
        let this = jsObject
        return this[.queryCommandIndeterm].function!(this: this, arguments: [_toJSValue(commandId)]).fromJSValue()!
    }

    @inlinable public func queryCommandState(commandId: String) -> Bool {
        let this = jsObject
        return this[.queryCommandState].function!(this: this, arguments: [_toJSValue(commandId)]).fromJSValue()!
    }

    @inlinable public func queryCommandSupported(commandId: String) -> Bool {
        let this = jsObject
        return this[.queryCommandSupported].function!(this: this, arguments: [_toJSValue(commandId)]).fromJSValue()!
    }

    @inlinable public func queryCommandValue(commandId: String) -> String {
        let this = jsObject
        return this[.queryCommandValue].function!(this: this, arguments: [_toJSValue(commandId)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var hidden: Bool

    @ReadonlyAttribute
    public var visibilityState: DocumentVisibilityState

    @ClosureAttribute1Optional
    public var onreadystatechange: EventHandler

    @ClosureAttribute1Optional
    public var onvisibilitychange: EventHandler

    @ReadWriteAttribute
    public var fgColor: String

    @ReadWriteAttribute
    public var linkColor: String

    @ReadWriteAttribute
    public var vlinkColor: String

    @ReadWriteAttribute
    public var alinkColor: String

    @ReadWriteAttribute
    public var bgColor: String

    @ReadonlyAttribute
    public var anchors: HTMLCollection

    @ReadonlyAttribute
    public var applets: HTMLCollection

    @inlinable public func clear() {
        let this = jsObject
        _ = this[.clear].function!(this: this, arguments: [])
    }

    @inlinable public func captureEvents() {
        let this = jsObject
        _ = this[.captureEvents].function!(this: this, arguments: [])
    }

    @inlinable public func releaseEvents() {
        let this = jsObject
        _ = this[.releaseEvents].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var all: HTMLAllCollection

    @inlinable public func elementFromPoint(x: Double, y: Double) -> Element? {
        let this = jsObject
        return this[.elementFromPoint].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)]).fromJSValue()
    }

    @inlinable public func elementsFromPoint(x: Double, y: Double) -> [Element] {
        let this = jsObject
        return this[.elementsFromPoint].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)]).fromJSValue()!
    }

    @inlinable public func caretPositionFromPoint(x: Double, y: Double) -> CaretPosition? {
        let this = jsObject
        return this[.caretPositionFromPoint].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)]).fromJSValue()
    }

    @ReadonlyAttribute
    public var scrollingElement: Element?
}

open class DocumentFragment: Node, NonElementParentNode, ParentNode {
    @inlinable override open class var constructor: JSFunction? { JSObject.global[.DocumentFragment].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }
}

public protocol DocumentOrShadowRoot: JSBridgedClass {}
public extension DocumentOrShadowRoot {
    @inlinable var activeElement: Element? { jsObject[.activeElement].fromJSValue() }
}

public enum DocumentReadyState: JSString, JSValueCompatible {
    case loading = "loading"
    case interactive = "interactive"
    case complete = "complete"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class DocumentType: Node, ChildNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.DocumentType].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: .name)
        _publicId = ReadonlyAttribute(jsObject: jsObject, name: .publicId)
        _systemId = ReadonlyAttribute(jsObject: jsObject, name: .systemId)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var publicId: String

    @ReadonlyAttribute
    public var systemId: String
}

public enum DocumentVisibilityState: JSString, JSValueCompatible {
    case visible = "visible"
    case hidden = "hidden"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class DoubleRange: BridgedDictionary {
    public convenience init(max: Double, min: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.max] = _toJSValue(max)
        object[.min] = _toJSValue(min)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _max = ReadWriteAttribute(jsObject: object, name: .max)
        _min = ReadWriteAttribute(jsObject: object, name: .min)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var max: Double

    @ReadWriteAttribute
    public var min: Double
}

public class DragEvent: MouseEvent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.DragEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _dataTransfer = ReadonlyAttribute(jsObject: jsObject, name: .dataTransfer)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: DragEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var dataTransfer: DataTransfer?
}

public class DragEventInit: BridgedDictionary {
    public convenience init(dataTransfer: DataTransfer?) {
        let object = JSObject.global[.Object].function!.new()
        object[.dataTransfer] = _toJSValue(dataTransfer)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _dataTransfer = ReadWriteAttribute(jsObject: object, name: .dataTransfer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var dataTransfer: DataTransfer?
}

open class Element: Node, ParentNode, NonDocumentTypeChildNode, ChildNode, Slottable, ARIAMixin, GeometryUtils {
    @inlinable override open class var constructor: JSFunction? { JSObject.global[.Element].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _namespaceURI = ReadonlyAttribute(jsObject: jsObject, name: .namespaceURI)
        _prefix = ReadonlyAttribute(jsObject: jsObject, name: .prefix)
        _localName = ReadonlyAttribute(jsObject: jsObject, name: .localName)
        _tagName = ReadonlyAttribute(jsObject: jsObject, name: .tagName)
        _id = ReadWriteAttribute(jsObject: jsObject, name: .id)
        _className = ReadWriteAttribute(jsObject: jsObject, name: .className)
        _classList = ReadonlyAttribute(jsObject: jsObject, name: .classList)
        _slot = ReadWriteAttribute(jsObject: jsObject, name: .slot)
        _attributes = ReadonlyAttribute(jsObject: jsObject, name: .attributes)
        _shadowRoot = ReadonlyAttribute(jsObject: jsObject, name: .shadowRoot)
        _scrollTop = ReadWriteAttribute(jsObject: jsObject, name: .scrollTop)
        _scrollLeft = ReadWriteAttribute(jsObject: jsObject, name: .scrollLeft)
        _scrollWidth = ReadonlyAttribute(jsObject: jsObject, name: .scrollWidth)
        _scrollHeight = ReadonlyAttribute(jsObject: jsObject, name: .scrollHeight)
        _clientTop = ReadonlyAttribute(jsObject: jsObject, name: .clientTop)
        _clientLeft = ReadonlyAttribute(jsObject: jsObject, name: .clientLeft)
        _clientWidth = ReadonlyAttribute(jsObject: jsObject, name: .clientWidth)
        _clientHeight = ReadonlyAttribute(jsObject: jsObject, name: .clientHeight)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var namespaceURI: String?

    @ReadonlyAttribute
    public var prefix: String?

    @ReadonlyAttribute
    public var localName: String

    @ReadonlyAttribute
    public var tagName: String

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var className: String

    @ReadonlyAttribute
    public var classList: DOMTokenList

    @ReadWriteAttribute
    public var slot: String

    @inlinable public func hasAttributes() -> Bool {
        let this = jsObject
        return this[.hasAttributes].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var attributes: NamedNodeMap

    @inlinable public func getAttributeNames() -> [String] {
        let this = jsObject
        return this[.getAttributeNames].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getAttribute(qualifiedName: String) -> String? {
        let this = jsObject
        return this[.getAttribute].function!(this: this, arguments: [_toJSValue(qualifiedName)]).fromJSValue()
    }

    @inlinable public func getAttributeNS(namespace: String?, localName: String) -> String? {
        let this = jsObject
        return this[.getAttributeNS].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(localName)]).fromJSValue()
    }

    @inlinable public func setAttribute(qualifiedName: String, value: String) {
        let this = jsObject
        _ = this[.setAttribute].function!(this: this, arguments: [_toJSValue(qualifiedName), _toJSValue(value)])
    }

    @inlinable public func setAttributeNS(namespace: String?, qualifiedName: String, value: String) {
        let this = jsObject
        _ = this[.setAttributeNS].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(qualifiedName), _toJSValue(value)])
    }

    @inlinable public func removeAttribute(qualifiedName: String) {
        let this = jsObject
        _ = this[.removeAttribute].function!(this: this, arguments: [_toJSValue(qualifiedName)])
    }

    @inlinable public func removeAttributeNS(namespace: String?, localName: String) {
        let this = jsObject
        _ = this[.removeAttributeNS].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(localName)])
    }

    @inlinable public func toggleAttribute(qualifiedName: String, force: Bool? = nil) -> Bool {
        let this = jsObject
        return this[.toggleAttribute].function!(this: this, arguments: [_toJSValue(qualifiedName), _toJSValue(force)]).fromJSValue()!
    }

    @inlinable public func hasAttribute(qualifiedName: String) -> Bool {
        let this = jsObject
        return this[.hasAttribute].function!(this: this, arguments: [_toJSValue(qualifiedName)]).fromJSValue()!
    }

    @inlinable public func hasAttributeNS(namespace: String?, localName: String) -> Bool {
        let this = jsObject
        return this[.hasAttributeNS].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(localName)]).fromJSValue()!
    }

    @inlinable public func getAttributeNode(qualifiedName: String) -> Attr? {
        let this = jsObject
        return this[.getAttributeNode].function!(this: this, arguments: [_toJSValue(qualifiedName)]).fromJSValue()
    }

    @inlinable public func getAttributeNodeNS(namespace: String?, localName: String) -> Attr? {
        let this = jsObject
        return this[.getAttributeNodeNS].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(localName)]).fromJSValue()
    }

    @inlinable public func setAttributeNode(attr: Attr) -> Attr? {
        let this = jsObject
        return this[.setAttributeNode].function!(this: this, arguments: [_toJSValue(attr)]).fromJSValue()
    }

    @inlinable public func setAttributeNodeNS(attr: Attr) -> Attr? {
        let this = jsObject
        return this[.setAttributeNodeNS].function!(this: this, arguments: [_toJSValue(attr)]).fromJSValue()
    }

    @inlinable public func removeAttributeNode(attr: Attr) -> Attr {
        let this = jsObject
        return this[.removeAttributeNode].function!(this: this, arguments: [_toJSValue(attr)]).fromJSValue()!
    }

    @inlinable public func attachShadow(init: ShadowRootInit) -> ShadowRoot {
        let this = jsObject
        return this[.attachShadow].function!(this: this, arguments: [_toJSValue(`init`)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var shadowRoot: ShadowRoot?

    @inlinable public func closest(selectors: String) -> Element? {
        let this = jsObject
        return this[.closest].function!(this: this, arguments: [_toJSValue(selectors)]).fromJSValue()
    }

    @inlinable public func matches(selectors: String) -> Bool {
        let this = jsObject
        return this[.matches].function!(this: this, arguments: [_toJSValue(selectors)]).fromJSValue()!
    }

    @inlinable public func webkitMatchesSelector(selectors: String) -> Bool {
        let this = jsObject
        return this[.webkitMatchesSelector].function!(this: this, arguments: [_toJSValue(selectors)]).fromJSValue()!
    }

    @inlinable public func getElementsByTagName(qualifiedName: String) -> HTMLCollection {
        let this = jsObject
        return this[.getElementsByTagName].function!(this: this, arguments: [_toJSValue(qualifiedName)]).fromJSValue()!
    }

    @inlinable public func getElementsByTagNameNS(namespace: String?, localName: String) -> HTMLCollection {
        let this = jsObject
        return this[.getElementsByTagNameNS].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(localName)]).fromJSValue()!
    }

    @inlinable public func getElementsByClassName(classNames: String) -> HTMLCollection {
        let this = jsObject
        return this[.getElementsByClassName].function!(this: this, arguments: [_toJSValue(classNames)]).fromJSValue()!
    }

    @inlinable public func insertAdjacentElement(where: String, element: Element) -> Element? {
        let this = jsObject
        return this[.insertAdjacentElement].function!(this: this, arguments: [_toJSValue(`where`), _toJSValue(element)]).fromJSValue()
    }

    @inlinable public func insertAdjacentText(where: String, data: String) {
        let this = jsObject
        _ = this[.insertAdjacentText].function!(this: this, arguments: [_toJSValue(`where`), _toJSValue(data)])
    }

    @inlinable public func pseudo(type: String) -> CSSPseudoElement? {
        let this = jsObject
        return this[.pseudo].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()
    }

    @inlinable public func getClientRects() -> DOMRectList {
        let this = jsObject
        return this[.getClientRects].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getBoundingClientRect() -> DOMRect {
        let this = jsObject
        return this[.getBoundingClientRect].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func checkVisibility(options: CheckVisibilityOptions? = nil) -> Bool {
        let this = jsObject
        return this[.checkVisibility].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func scrollIntoView(arg: Bool_or_ScrollIntoViewOptions? = nil) {
        let this = jsObject
        _ = this[.scrollIntoView].function!(this: this, arguments: [_toJSValue(arg)])
    }

    @inlinable public func scroll(options: ScrollToOptions? = nil) {
        let this = jsObject
        _ = this[.scroll].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable public func scroll(x: Double, y: Double) {
        let this = jsObject
        _ = this[.scroll].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable public func scrollTo(options: ScrollToOptions? = nil) {
        let this = jsObject
        _ = this[.scrollTo].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable public func scrollTo(x: Double, y: Double) {
        let this = jsObject
        _ = this[.scrollTo].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable public func scrollBy(options: ScrollToOptions? = nil) {
        let this = jsObject
        _ = this[.scrollBy].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable public func scrollBy(x: Double, y: Double) {
        let this = jsObject
        _ = this[.scrollBy].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @ReadWriteAttribute
    public var scrollTop: Double

    @ReadWriteAttribute
    public var scrollLeft: Double

    @ReadonlyAttribute
    public var scrollWidth: Int32

    @ReadonlyAttribute
    public var scrollHeight: Int32

    @ReadonlyAttribute
    public var clientTop: Int32

    @ReadonlyAttribute
    public var clientLeft: Int32

    @ReadonlyAttribute
    public var clientWidth: Int32

    @ReadonlyAttribute
    public var clientHeight: Int32
}

public protocol ElementContentEditable: JSBridgedClass {}
public extension ElementContentEditable {
    @inlinable var contentEditable: String {
        get { jsObject[.contentEditable].fromJSValue()! }
        nonmutating set { jsObject[.contentEditable] = _toJSValue(newValue) }
    }

    @inlinable var enterKeyHint: String {
        get { jsObject[.enterKeyHint].fromJSValue()! }
        nonmutating set { jsObject[.enterKeyHint] = _toJSValue(newValue) }
    }

    @inlinable var isContentEditable: Bool { jsObject[.isContentEditable].fromJSValue()! }

    @inlinable var inputMode: String {
        get { jsObject[.inputMode].fromJSValue()! }
        nonmutating set { jsObject[.inputMode] = _toJSValue(newValue) }
    }
}

public class ElementCreationOptions: BridgedDictionary {
    public convenience init(is: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.is] = _toJSValue(`is`)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _is = ReadWriteAttribute(jsObject: object, name: .is)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var `is`: String
}

public class ElementDefinitionOptions: BridgedDictionary {
    public convenience init(extends: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.extends] = _toJSValue(extends)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _extends = ReadWriteAttribute(jsObject: object, name: .extends)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var extends: String
}

public class ElementInternals: JSBridgedClass, ARIAMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ElementInternals].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _shadowRoot = ReadonlyAttribute(jsObject: jsObject, name: .shadowRoot)
        _form = ReadonlyAttribute(jsObject: jsObject, name: .form)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: .willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: .validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: .validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: .labels)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var shadowRoot: ShadowRoot?

    @inlinable public func setFormValue(value: File_or_FormData_or_String?, state: File_or_FormData_or_String? = nil) {
        let this = jsObject
        _ = this[.setFormValue].function!(this: this, arguments: [_toJSValue(value), _toJSValue(state)])
    }

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @inlinable public func setValidity(flags: ValidityStateFlags? = nil, message: String? = nil, anchor: HTMLElement? = nil) {
        let this = jsObject
        _ = this[.setValidity].function!(this: this, arguments: [_toJSValue(flags), _toJSValue(message), _toJSValue(anchor)])
    }

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class EncodedAudioChunk: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.EncodedAudioChunk].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _timestamp = ReadonlyAttribute(jsObject: jsObject, name: .timestamp)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: .duration)
        _byteLength = ReadonlyAttribute(jsObject: jsObject, name: .byteLength)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: EncodedAudioChunkInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var type: EncodedAudioChunkType

    @ReadonlyAttribute
    public var timestamp: Int64

    @ReadonlyAttribute
    public var duration: UInt64?

    @ReadonlyAttribute
    public var byteLength: UInt32

    @inlinable public func copyTo(destination: AllowSharedBufferSource) {
        let this = jsObject
        _ = this[.copyTo].function!(this: this, arguments: [_toJSValue(destination)])
    }
}

public class EncodedAudioChunkInit: BridgedDictionary {
    public convenience init(type: EncodedAudioChunkType, timestamp: Int64, duration: UInt64, data: BufferSource) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.timestamp] = _toJSValue(timestamp)
        object[.duration] = _toJSValue(duration)
        object[.data] = _toJSValue(data)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        _timestamp = ReadWriteAttribute(jsObject: object, name: .timestamp)
        _duration = ReadWriteAttribute(jsObject: object, name: .duration)
        _data = ReadWriteAttribute(jsObject: object, name: .data)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: EncodedAudioChunkType

    @ReadWriteAttribute
    public var timestamp: Int64

    @ReadWriteAttribute
    public var duration: UInt64

    @ReadWriteAttribute
    public var data: BufferSource
}

public class EncodedAudioChunkMetadata: BridgedDictionary {
    public convenience init(decoderConfig: AudioDecoderConfig) {
        let object = JSObject.global[.Object].function!.new()
        object[.decoderConfig] = _toJSValue(decoderConfig)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _decoderConfig = ReadWriteAttribute(jsObject: object, name: .decoderConfig)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var decoderConfig: AudioDecoderConfig
}

public enum EncodedAudioChunkType: JSString, JSValueCompatible {
    case key = "key"
    case delta = "delta"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class EncodedVideoChunk: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.EncodedVideoChunk].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _timestamp = ReadonlyAttribute(jsObject: jsObject, name: .timestamp)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: .duration)
        _byteLength = ReadonlyAttribute(jsObject: jsObject, name: .byteLength)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: EncodedVideoChunkInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var type: EncodedVideoChunkType

    @ReadonlyAttribute
    public var timestamp: Int64

    @ReadonlyAttribute
    public var duration: UInt64?

    @ReadonlyAttribute
    public var byteLength: UInt32

    @inlinable public func copyTo(destination: AllowSharedBufferSource) {
        let this = jsObject
        _ = this[.copyTo].function!(this: this, arguments: [_toJSValue(destination)])
    }
}

public class EncodedVideoChunkInit: BridgedDictionary {
    public convenience init(type: EncodedVideoChunkType, timestamp: Int64, duration: UInt64, data: AllowSharedBufferSource) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.timestamp] = _toJSValue(timestamp)
        object[.duration] = _toJSValue(duration)
        object[.data] = _toJSValue(data)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        _timestamp = ReadWriteAttribute(jsObject: object, name: .timestamp)
        _duration = ReadWriteAttribute(jsObject: object, name: .duration)
        _data = ReadWriteAttribute(jsObject: object, name: .data)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: EncodedVideoChunkType

    @ReadWriteAttribute
    public var timestamp: Int64

    @ReadWriteAttribute
    public var duration: UInt64

    @ReadWriteAttribute
    public var data: AllowSharedBufferSource
}

public class EncodedVideoChunkMetadata: BridgedDictionary {
    public convenience init(decoderConfig: VideoDecoderConfig, svc: SvcOutputMetadata, alphaSideData: BufferSource) {
        let object = JSObject.global[.Object].function!.new()
        object[.decoderConfig] = _toJSValue(decoderConfig)
        object[.svc] = _toJSValue(svc)
        object[.alphaSideData] = _toJSValue(alphaSideData)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _decoderConfig = ReadWriteAttribute(jsObject: object, name: .decoderConfig)
        _svc = ReadWriteAttribute(jsObject: object, name: .svc)
        _alphaSideData = ReadWriteAttribute(jsObject: object, name: .alphaSideData)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var decoderConfig: VideoDecoderConfig

    @ReadWriteAttribute
    public var svc: SvcOutputMetadata

    @ReadWriteAttribute
    public var alphaSideData: BufferSource
}

public enum EncodedVideoChunkType: JSString, JSValueCompatible {
    case key = "key"
    case delta = "delta"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum EndOfStreamError: JSString, JSValueCompatible {
    case network = "network"
    case decode = "decode"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum EndingType: JSString, JSValueCompatible {
    case transparent = "transparent"
    case native = "native"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ErrorEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ErrorEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _message = ReadonlyAttribute(jsObject: jsObject, name: .message)
        _filename = ReadonlyAttribute(jsObject: jsObject, name: .filename)
        _lineno = ReadonlyAttribute(jsObject: jsObject, name: .lineno)
        _colno = ReadonlyAttribute(jsObject: jsObject, name: .colno)
        _error = ReadonlyAttribute(jsObject: jsObject, name: .error)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: ErrorEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var message: String

    @ReadonlyAttribute
    public var filename: String

    @ReadonlyAttribute
    public var lineno: UInt32

    @ReadonlyAttribute
    public var colno: UInt32

    @ReadonlyAttribute
    public var error: JSValue
}

public class ErrorEventInit: BridgedDictionary {
    public convenience init(message: String, filename: String, lineno: UInt32, colno: UInt32, error: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        object[.message] = _toJSValue(message)
        object[.filename] = _toJSValue(filename)
        object[.lineno] = _toJSValue(lineno)
        object[.colno] = _toJSValue(colno)
        object[.error] = _toJSValue(error)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _message = ReadWriteAttribute(jsObject: object, name: .message)
        _filename = ReadWriteAttribute(jsObject: object, name: .filename)
        _lineno = ReadWriteAttribute(jsObject: object, name: .lineno)
        _colno = ReadWriteAttribute(jsObject: object, name: .colno)
        _error = ReadWriteAttribute(jsObject: object, name: .error)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var message: String

    @ReadWriteAttribute
    public var filename: String

    @ReadWriteAttribute
    public var lineno: UInt32

    @ReadWriteAttribute
    public var colno: UInt32

    @ReadWriteAttribute
    public var error: JSValue
}

open class Event: JSBridgedClass {
    @inlinable open class var constructor: JSFunction? { JSObject.global[.Event].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _target = ReadonlyAttribute(jsObject: jsObject, name: .target)
        _srcElement = ReadonlyAttribute(jsObject: jsObject, name: .srcElement)
        _currentTarget = ReadonlyAttribute(jsObject: jsObject, name: .currentTarget)
        _eventPhase = ReadonlyAttribute(jsObject: jsObject, name: .eventPhase)
        _cancelBubble = ReadWriteAttribute(jsObject: jsObject, name: .cancelBubble)
        _bubbles = ReadonlyAttribute(jsObject: jsObject, name: .bubbles)
        _cancelable = ReadonlyAttribute(jsObject: jsObject, name: .cancelable)
        _returnValue = ReadWriteAttribute(jsObject: jsObject, name: .returnValue)
        _defaultPrevented = ReadonlyAttribute(jsObject: jsObject, name: .defaultPrevented)
        _composed = ReadonlyAttribute(jsObject: jsObject, name: .composed)
        _isTrusted = ReadonlyAttribute(jsObject: jsObject, name: .isTrusted)
        _timeStamp = ReadonlyAttribute(jsObject: jsObject, name: .timeStamp)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(type: String, eventInitDict: EventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var target: EventTarget?

    @ReadonlyAttribute
    public var srcElement: EventTarget?

    @ReadonlyAttribute
    public var currentTarget: EventTarget?

    @inlinable public func composedPath() -> [EventTarget] {
        let this = jsObject
        return this[.composedPath].function!(this: this, arguments: []).fromJSValue()!
    }

    public static let NONE: UInt16 = 0

    public static let CAPTURING_PHASE: UInt16 = 1

    public static let AT_TARGET: UInt16 = 2

    public static let BUBBLING_PHASE: UInt16 = 3

    @ReadonlyAttribute
    public var eventPhase: UInt16

    @inlinable public func stopPropagation() {
        let this = jsObject
        _ = this[.stopPropagation].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var cancelBubble: Bool

    @inlinable public func stopImmediatePropagation() {
        let this = jsObject
        _ = this[.stopImmediatePropagation].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var bubbles: Bool

    @ReadonlyAttribute
    public var cancelable: Bool

    @ReadWriteAttribute
    public var returnValue: Bool

    @inlinable public func preventDefault() {
        let this = jsObject
        _ = this[.preventDefault].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var defaultPrevented: Bool

    @ReadonlyAttribute
    public var composed: Bool

    @ReadonlyAttribute
    public var isTrusted: Bool

    @ReadonlyAttribute
    public var timeStamp: DOMHighResTimeStamp

    @inlinable public func initEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil) {
        let this = jsObject
        _ = this[.initEvent].function!(this: this, arguments: [_toJSValue(type), _toJSValue(bubbles), _toJSValue(cancelable)])
    }
}

public class EventInit: BridgedDictionary {
    public convenience init(bubbles: Bool, cancelable: Bool, composed: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.bubbles] = _toJSValue(bubbles)
        object[.cancelable] = _toJSValue(cancelable)
        object[.composed] = _toJSValue(composed)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _bubbles = ReadWriteAttribute(jsObject: object, name: .bubbles)
        _cancelable = ReadWriteAttribute(jsObject: object, name: .cancelable)
        _composed = ReadWriteAttribute(jsObject: object, name: .composed)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var bubbles: Bool

    @ReadWriteAttribute
    public var cancelable: Bool

    @ReadWriteAttribute
    public var composed: Bool
}

public typealias EventListener = (Event) -> Void
public class EventListenerOptions: BridgedDictionary {
    public convenience init(capture: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.capture] = _toJSValue(capture)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _capture = ReadWriteAttribute(jsObject: object, name: .capture)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var capture: Bool
}

public class EventModifierInit: BridgedDictionary {
    public convenience init(ctrlKey: Bool, shiftKey: Bool, altKey: Bool, metaKey: Bool, modifierAltGraph: Bool, modifierCapsLock: Bool, modifierFn: Bool, modifierFnLock: Bool, modifierHyper: Bool, modifierNumLock: Bool, modifierScrollLock: Bool, modifierSuper: Bool, modifierSymbol: Bool, modifierSymbolLock: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.ctrlKey] = _toJSValue(ctrlKey)
        object[.shiftKey] = _toJSValue(shiftKey)
        object[.altKey] = _toJSValue(altKey)
        object[.metaKey] = _toJSValue(metaKey)
        object[.modifierAltGraph] = _toJSValue(modifierAltGraph)
        object[.modifierCapsLock] = _toJSValue(modifierCapsLock)
        object[.modifierFn] = _toJSValue(modifierFn)
        object[.modifierFnLock] = _toJSValue(modifierFnLock)
        object[.modifierHyper] = _toJSValue(modifierHyper)
        object[.modifierNumLock] = _toJSValue(modifierNumLock)
        object[.modifierScrollLock] = _toJSValue(modifierScrollLock)
        object[.modifierSuper] = _toJSValue(modifierSuper)
        object[.modifierSymbol] = _toJSValue(modifierSymbol)
        object[.modifierSymbolLock] = _toJSValue(modifierSymbolLock)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _ctrlKey = ReadWriteAttribute(jsObject: object, name: .ctrlKey)
        _shiftKey = ReadWriteAttribute(jsObject: object, name: .shiftKey)
        _altKey = ReadWriteAttribute(jsObject: object, name: .altKey)
        _metaKey = ReadWriteAttribute(jsObject: object, name: .metaKey)
        _modifierAltGraph = ReadWriteAttribute(jsObject: object, name: .modifierAltGraph)
        _modifierCapsLock = ReadWriteAttribute(jsObject: object, name: .modifierCapsLock)
        _modifierFn = ReadWriteAttribute(jsObject: object, name: .modifierFn)
        _modifierFnLock = ReadWriteAttribute(jsObject: object, name: .modifierFnLock)
        _modifierHyper = ReadWriteAttribute(jsObject: object, name: .modifierHyper)
        _modifierNumLock = ReadWriteAttribute(jsObject: object, name: .modifierNumLock)
        _modifierScrollLock = ReadWriteAttribute(jsObject: object, name: .modifierScrollLock)
        _modifierSuper = ReadWriteAttribute(jsObject: object, name: .modifierSuper)
        _modifierSymbol = ReadWriteAttribute(jsObject: object, name: .modifierSymbol)
        _modifierSymbolLock = ReadWriteAttribute(jsObject: object, name: .modifierSymbolLock)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var ctrlKey: Bool

    @ReadWriteAttribute
    public var shiftKey: Bool

    @ReadWriteAttribute
    public var altKey: Bool

    @ReadWriteAttribute
    public var metaKey: Bool

    @ReadWriteAttribute
    public var modifierAltGraph: Bool

    @ReadWriteAttribute
    public var modifierCapsLock: Bool

    @ReadWriteAttribute
    public var modifierFn: Bool

    @ReadWriteAttribute
    public var modifierFnLock: Bool

    @ReadWriteAttribute
    public var modifierHyper: Bool

    @ReadWriteAttribute
    public var modifierNumLock: Bool

    @ReadWriteAttribute
    public var modifierScrollLock: Bool

    @ReadWriteAttribute
    public var modifierSuper: Bool

    @ReadWriteAttribute
    public var modifierSymbol: Bool

    @ReadWriteAttribute
    public var modifierSymbolLock: Bool
}

public class EventSource: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.EventSource].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _url = ReadonlyAttribute(jsObject: jsObject, name: .url)
        _withCredentials = ReadonlyAttribute(jsObject: jsObject, name: .withCredentials)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: .readyState)
        _onopen = ClosureAttribute1Optional(jsObject: jsObject, name: .onopen)
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: .onmessage)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(url: String, eventSourceInitDict: EventSourceInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(url), _toJSValue(eventSourceInitDict)]))
    }

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var withCredentials: Bool

    public static let CONNECTING: UInt16 = 0

    public static let OPEN: UInt16 = 1

    public static let CLOSED: UInt16 = 2

    @ReadonlyAttribute
    public var readyState: UInt16

    @ClosureAttribute1Optional
    public var onopen: EventHandler

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }
}

public class EventSourceInit: BridgedDictionary {
    public convenience init(withCredentials: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.withCredentials] = _toJSValue(withCredentials)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _withCredentials = ReadWriteAttribute(jsObject: object, name: .withCredentials)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var withCredentials: Bool
}

open class EventTarget: JSBridgedClass {
    @inlinable open class var constructor: JSFunction? { JSObject.global[.EventTarget].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @inlinable public func addEventListener(type: String, callback: EventListener?, options: AddEventListenerOptions_or_Bool? = nil) {
        let this = jsObject
        _ = this[.addEventListener].function!(this: this, arguments: [_toJSValue(type), _toJSValue(callback), _toJSValue(options)])
    }

    @inlinable public func removeEventListener(type: String, callback: EventListener?, options: Bool_or_EventListenerOptions? = nil) {
        let this = jsObject
        _ = this[.removeEventListener].function!(this: this, arguments: [_toJSValue(type), _toJSValue(callback), _toJSValue(options)])
    }

    @inlinable public func dispatchEvent(event: Event) -> Bool {
        let this = jsObject
        return this[.dispatchEvent].function!(this: this, arguments: [_toJSValue(event)]).fromJSValue()!
    }
}

public class ExtendableEventInit: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class External: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.External].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func AddSearchProvider() {
        let this = jsObject
        _ = this[.AddSearchProvider].function!(this: this, arguments: [])
    }

    @inlinable public func IsSearchProviderInstalled() {
        let this = jsObject
        _ = this[.IsSearchProviderInstalled].function!(this: this, arguments: [])
    }
}

public class FetchEventInit: BridgedDictionary {
    public convenience init(request: Request, preloadResponse: JSPromise, clientId: String, resultingClientId: String, replacesClientId: String, handled: JSPromise) {
        let object = JSObject.global[.Object].function!.new()
        object[.request] = _toJSValue(request)
        object[.preloadResponse] = _toJSValue(preloadResponse)
        object[.clientId] = _toJSValue(clientId)
        object[.resultingClientId] = _toJSValue(resultingClientId)
        object[.replacesClientId] = _toJSValue(replacesClientId)
        object[.handled] = _toJSValue(handled)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _request = ReadWriteAttribute(jsObject: object, name: .request)
        _preloadResponse = ReadWriteAttribute(jsObject: object, name: .preloadResponse)
        _clientId = ReadWriteAttribute(jsObject: object, name: .clientId)
        _resultingClientId = ReadWriteAttribute(jsObject: object, name: .resultingClientId)
        _replacesClientId = ReadWriteAttribute(jsObject: object, name: .replacesClientId)
        _handled = ReadWriteAttribute(jsObject: object, name: .handled)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var request: Request

    @ReadWriteAttribute
    public var preloadResponse: JSPromise

    @ReadWriteAttribute
    public var clientId: String

    @ReadWriteAttribute
    public var resultingClientId: String

    @ReadWriteAttribute
    public var replacesClientId: String

    @ReadWriteAttribute
    public var handled: JSPromise
}

public class File: Blob {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.File].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: .name)
        _lastModified = ReadonlyAttribute(jsObject: jsObject, name: .lastModified)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(fileBits: [BlobPart], fileName: String, options: FilePropertyBag? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(fileBits), _toJSValue(fileName), _toJSValue(options)]))
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var lastModified: Int64
}

public class FileList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.FileList].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: Int) -> File? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(index: UInt32) -> File? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @ReadonlyAttribute
    public var length: UInt32
}

public class FilePropertyBag: BridgedDictionary {
    public convenience init(lastModified: Int64) {
        let object = JSObject.global[.Object].function!.new()
        object[.lastModified] = _toJSValue(lastModified)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _lastModified = ReadWriteAttribute(jsObject: object, name: .lastModified)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var lastModified: Int64
}

public class FileReader: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.FileReader].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: .readyState)
        _result = ReadonlyAttribute(jsObject: jsObject, name: .result)
        _error = ReadonlyAttribute(jsObject: jsObject, name: .error)
        _onloadstart = ClosureAttribute1Optional(jsObject: jsObject, name: .onloadstart)
        _onprogress = ClosureAttribute1Optional(jsObject: jsObject, name: .onprogress)
        _onload = ClosureAttribute1Optional(jsObject: jsObject, name: .onload)
        _onabort = ClosureAttribute1Optional(jsObject: jsObject, name: .onabort)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onerror)
        _onloadend = ClosureAttribute1Optional(jsObject: jsObject, name: .onloadend)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @inlinable public func readAsArrayBuffer(blob: Blob) {
        let this = jsObject
        _ = this[.readAsArrayBuffer].function!(this: this, arguments: [_toJSValue(blob)])
    }

    @inlinable public func readAsBinaryString(blob: Blob) {
        let this = jsObject
        _ = this[.readAsBinaryString].function!(this: this, arguments: [_toJSValue(blob)])
    }

    @inlinable public func readAsText(blob: Blob, encoding: String? = nil) {
        let this = jsObject
        _ = this[.readAsText].function!(this: this, arguments: [_toJSValue(blob), _toJSValue(encoding)])
    }

    @inlinable public func readAsDataURL(blob: Blob) {
        let this = jsObject
        _ = this[.readAsDataURL].function!(this: this, arguments: [_toJSValue(blob)])
    }

    @inlinable public func abort() {
        let this = jsObject
        _ = this[.abort].function!(this: this, arguments: [])
    }

    public static let EMPTY: UInt16 = 0

    public static let LOADING: UInt16 = 1

    public static let DONE: UInt16 = 2

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var result: ArrayBuffer_or_String?

    @ReadonlyAttribute
    public var error: DOMException?

    @ClosureAttribute1Optional
    public var onloadstart: EventHandler

    @ClosureAttribute1Optional
    public var onprogress: EventHandler

    @ClosureAttribute1Optional
    public var onload: EventHandler

    @ClosureAttribute1Optional
    public var onabort: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @ClosureAttribute1Optional
    public var onloadend: EventHandler
}

public class FocusEvent: UIEvent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.FocusEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _relatedTarget = ReadonlyAttribute(jsObject: jsObject, name: .relatedTarget)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: FocusEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var relatedTarget: EventTarget?
}

public class FocusEventInit: BridgedDictionary {
    public convenience init(relatedTarget: EventTarget?) {
        let object = JSObject.global[.Object].function!.new()
        object[.relatedTarget] = _toJSValue(relatedTarget)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _relatedTarget = ReadWriteAttribute(jsObject: object, name: .relatedTarget)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var relatedTarget: EventTarget?
}

public class FocusOptions: BridgedDictionary {
    public convenience init(preventScroll: Bool, focusVisible: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.preventScroll] = _toJSValue(preventScroll)
        object[.focusVisible] = _toJSValue(focusVisible)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _preventScroll = ReadWriteAttribute(jsObject: object, name: .preventScroll)
        _focusVisible = ReadWriteAttribute(jsObject: object, name: .focusVisible)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var preventScroll: Bool

    @ReadWriteAttribute
    public var focusVisible: Bool
}

public class FormData: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.FormData].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(form: HTMLFormElement? = nil, submitter: HTMLElement? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(form), _toJSValue(submitter)]))
    }

    @inlinable public func append(name: String, value: String) {
        let this = jsObject
        _ = this[.append].function!(this: this, arguments: [_toJSValue(name), _toJSValue(value)])
    }

    @inlinable public func append(name: String, blobValue: Blob, filename: String? = nil) {
        let this = jsObject
        _ = this[.append].function!(this: this, arguments: [_toJSValue(name), _toJSValue(blobValue), _toJSValue(filename)])
    }

    @inlinable public func delete(name: String) {
        let this = jsObject
        _ = this[.delete].function!(this: this, arguments: [_toJSValue(name)])
    }

    @inlinable public func get(name: String) -> FormDataEntryValue? {
        let this = jsObject
        return this[.get].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }

    @inlinable public func getAll(name: String) -> [FormDataEntryValue] {
        let this = jsObject
        return this[.getAll].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()!
    }

    @inlinable public func has(name: String) -> Bool {
        let this = jsObject
        return this[.has].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()!
    }

    @inlinable public func set(name: String, value: String) {
        let this = jsObject
        _ = this[.set].function!(this: this, arguments: [_toJSValue(name), _toJSValue(value)])
    }

    @inlinable public func set(name: String, blobValue: Blob, filename: String? = nil) {
        let this = jsObject
        _ = this[.set].function!(this: this, arguments: [_toJSValue(name), _toJSValue(blobValue), _toJSValue(filename)])
    }

    public typealias Element = String
    public func makeIterator() -> ValueIterableIterator<FormData> {
        ValueIterableIterator(sequence: self)
    }
}

public class FormDataEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.FormDataEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _formData = ReadonlyAttribute(jsObject: jsObject, name: .formData)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: FormDataEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var formData: FormData
}

public class FormDataEventInit: BridgedDictionary {
    public convenience init(formData: FormData) {
        let object = JSObject.global[.Object].function!.new()
        object[.formData] = _toJSValue(formData)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _formData = ReadWriteAttribute(jsObject: object, name: .formData)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var formData: FormData
}

public enum FrameType: JSString, JSValueCompatible {
    case auxiliary = "auxiliary"
    case topLevel = "top-level"
    case nested = "nested"
    case none = "none"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol GenericTransformStream: JSBridgedClass {}
public extension GenericTransformStream {
    @inlinable var readable: ReadableStream { jsObject[.readable].fromJSValue()! }

    @inlinable var writable: WritableStream { jsObject[.writable].fromJSValue()! }
}

public protocol GeometryUtils: JSBridgedClass {}
public extension GeometryUtils {
    @inlinable func getBoxQuads(options: BoxQuadOptions? = nil) -> [DOMQuad] {
        let this = jsObject
        return this[.getBoxQuads].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable func convertQuadFromNode(quad: DOMQuadInit, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMQuad {
        let this = jsObject
        return this[.convertQuadFromNode].function!(this: this, arguments: [_toJSValue(quad), _toJSValue(from), _toJSValue(options)]).fromJSValue()!
    }

    @inlinable func convertRectFromNode(rect: DOMRectReadOnly, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMQuad {
        let this = jsObject
        return this[.convertRectFromNode].function!(this: this, arguments: [_toJSValue(rect), _toJSValue(from), _toJSValue(options)]).fromJSValue()!
    }

    @inlinable func convertPointFromNode(point: DOMPointInit, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMPoint {
        let this = jsObject
        return this[.convertPointFromNode].function!(this: this, arguments: [_toJSValue(point), _toJSValue(from), _toJSValue(options)]).fromJSValue()!
    }
}

public class GetRootNodeOptions: BridgedDictionary {
    public convenience init(composed: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.composed] = _toJSValue(composed)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _composed = ReadWriteAttribute(jsObject: object, name: .composed)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var composed: Bool
}

public protocol GlobalEventHandlers: JSBridgedClass {}
public extension GlobalEventHandlers {
    @inlinable var onabort: EventHandler {
        get { ClosureAttribute1Optional[.onabort, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onabort, in: jsObject] = newValue }
    }

    @inlinable var onauxclick: EventHandler {
        get { ClosureAttribute1Optional[.onauxclick, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onauxclick, in: jsObject] = newValue }
    }

    @inlinable var onbeforeinput: EventHandler {
        get { ClosureAttribute1Optional[.onbeforeinput, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onbeforeinput, in: jsObject] = newValue }
    }

    @inlinable var onbeforematch: EventHandler {
        get { ClosureAttribute1Optional[.onbeforematch, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onbeforematch, in: jsObject] = newValue }
    }

    @inlinable var onbeforetoggle: EventHandler {
        get { ClosureAttribute1Optional[.onbeforetoggle, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onbeforetoggle, in: jsObject] = newValue }
    }

    @inlinable var onblur: EventHandler {
        get { ClosureAttribute1Optional[.onblur, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onblur, in: jsObject] = newValue }
    }

    @inlinable var oncancel: EventHandler {
        get { ClosureAttribute1Optional[.oncancel, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.oncancel, in: jsObject] = newValue }
    }

    @inlinable var oncanplay: EventHandler {
        get { ClosureAttribute1Optional[.oncanplay, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.oncanplay, in: jsObject] = newValue }
    }

    @inlinable var oncanplaythrough: EventHandler {
        get { ClosureAttribute1Optional[.oncanplaythrough, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.oncanplaythrough, in: jsObject] = newValue }
    }

    @inlinable var onchange: EventHandler {
        get { ClosureAttribute1Optional[.onchange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onchange, in: jsObject] = newValue }
    }

    @inlinable var onclick: EventHandler {
        get { ClosureAttribute1Optional[.onclick, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onclick, in: jsObject] = newValue }
    }

    @inlinable var onclose: EventHandler {
        get { ClosureAttribute1Optional[.onclose, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onclose, in: jsObject] = newValue }
    }

    @inlinable var oncontextlost: EventHandler {
        get { ClosureAttribute1Optional[.oncontextlost, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.oncontextlost, in: jsObject] = newValue }
    }

    @inlinable var oncontextmenu: EventHandler {
        get { ClosureAttribute1Optional[.oncontextmenu, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.oncontextmenu, in: jsObject] = newValue }
    }

    @inlinable var oncontextrestored: EventHandler {
        get { ClosureAttribute1Optional[.oncontextrestored, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.oncontextrestored, in: jsObject] = newValue }
    }

    @inlinable var oncopy: EventHandler {
        get { ClosureAttribute1Optional[.oncopy, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.oncopy, in: jsObject] = newValue }
    }

    @inlinable var oncuechange: EventHandler {
        get { ClosureAttribute1Optional[.oncuechange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.oncuechange, in: jsObject] = newValue }
    }

    @inlinable var oncut: EventHandler {
        get { ClosureAttribute1Optional[.oncut, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.oncut, in: jsObject] = newValue }
    }

    @inlinable var ondblclick: EventHandler {
        get { ClosureAttribute1Optional[.ondblclick, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ondblclick, in: jsObject] = newValue }
    }

    @inlinable var ondrag: EventHandler {
        get { ClosureAttribute1Optional[.ondrag, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ondrag, in: jsObject] = newValue }
    }

    @inlinable var ondragend: EventHandler {
        get { ClosureAttribute1Optional[.ondragend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ondragend, in: jsObject] = newValue }
    }

    @inlinable var ondragenter: EventHandler {
        get { ClosureAttribute1Optional[.ondragenter, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ondragenter, in: jsObject] = newValue }
    }

    @inlinable var ondragleave: EventHandler {
        get { ClosureAttribute1Optional[.ondragleave, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ondragleave, in: jsObject] = newValue }
    }

    @inlinable var ondragover: EventHandler {
        get { ClosureAttribute1Optional[.ondragover, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ondragover, in: jsObject] = newValue }
    }

    @inlinable var ondragstart: EventHandler {
        get { ClosureAttribute1Optional[.ondragstart, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ondragstart, in: jsObject] = newValue }
    }

    @inlinable var ondrop: EventHandler {
        get { ClosureAttribute1Optional[.ondrop, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ondrop, in: jsObject] = newValue }
    }

    @inlinable var ondurationchange: EventHandler {
        get { ClosureAttribute1Optional[.ondurationchange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ondurationchange, in: jsObject] = newValue }
    }

    @inlinable var onemptied: EventHandler {
        get { ClosureAttribute1Optional[.onemptied, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onemptied, in: jsObject] = newValue }
    }

    @inlinable var onended: EventHandler {
        get { ClosureAttribute1Optional[.onended, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onended, in: jsObject] = newValue }
    }

    @inlinable var onerror: OnErrorEventHandler {
        get { ClosureAttribute5Optional[.onerror, in: jsObject] }
        nonmutating set { ClosureAttribute5Optional[.onerror, in: jsObject] = newValue }
    }

    @inlinable var onfocus: EventHandler {
        get { ClosureAttribute1Optional[.onfocus, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onfocus, in: jsObject] = newValue }
    }

    @inlinable var onformdata: EventHandler {
        get { ClosureAttribute1Optional[.onformdata, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onformdata, in: jsObject] = newValue }
    }

    @inlinable var oninput: EventHandler {
        get { ClosureAttribute1Optional[.oninput, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.oninput, in: jsObject] = newValue }
    }

    @inlinable var oninvalid: EventHandler {
        get { ClosureAttribute1Optional[.oninvalid, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.oninvalid, in: jsObject] = newValue }
    }

    @inlinable var onkeydown: EventHandler {
        get { ClosureAttribute1Optional[.onkeydown, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onkeydown, in: jsObject] = newValue }
    }

    @inlinable var onkeypress: EventHandler {
        get { ClosureAttribute1Optional[.onkeypress, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onkeypress, in: jsObject] = newValue }
    }

    @inlinable var onkeyup: EventHandler {
        get { ClosureAttribute1Optional[.onkeyup, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onkeyup, in: jsObject] = newValue }
    }

    @inlinable var onload: EventHandler {
        get { ClosureAttribute1Optional[.onload, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onload, in: jsObject] = newValue }
    }

    @inlinable var onloadeddata: EventHandler {
        get { ClosureAttribute1Optional[.onloadeddata, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onloadeddata, in: jsObject] = newValue }
    }

    @inlinable var onloadedmetadata: EventHandler {
        get { ClosureAttribute1Optional[.onloadedmetadata, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onloadedmetadata, in: jsObject] = newValue }
    }

    @inlinable var onloadstart: EventHandler {
        get { ClosureAttribute1Optional[.onloadstart, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onloadstart, in: jsObject] = newValue }
    }

    @inlinable var onmousedown: EventHandler {
        get { ClosureAttribute1Optional[.onmousedown, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onmousedown, in: jsObject] = newValue }
    }

    @inlinable var onmouseenter: EventHandler {
        get { ClosureAttribute1Optional[.onmouseenter, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onmouseenter, in: jsObject] = newValue }
    }

    @inlinable var onmouseleave: EventHandler {
        get { ClosureAttribute1Optional[.onmouseleave, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onmouseleave, in: jsObject] = newValue }
    }

    @inlinable var onmousemove: EventHandler {
        get { ClosureAttribute1Optional[.onmousemove, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onmousemove, in: jsObject] = newValue }
    }

    @inlinable var onmouseout: EventHandler {
        get { ClosureAttribute1Optional[.onmouseout, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onmouseout, in: jsObject] = newValue }
    }

    @inlinable var onmouseover: EventHandler {
        get { ClosureAttribute1Optional[.onmouseover, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onmouseover, in: jsObject] = newValue }
    }

    @inlinable var onmouseup: EventHandler {
        get { ClosureAttribute1Optional[.onmouseup, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onmouseup, in: jsObject] = newValue }
    }

    @inlinable var onpaste: EventHandler {
        get { ClosureAttribute1Optional[.onpaste, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onpaste, in: jsObject] = newValue }
    }

    @inlinable var onpause: EventHandler {
        get { ClosureAttribute1Optional[.onpause, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onpause, in: jsObject] = newValue }
    }

    @inlinable var onplay: EventHandler {
        get { ClosureAttribute1Optional[.onplay, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onplay, in: jsObject] = newValue }
    }

    @inlinable var onplaying: EventHandler {
        get { ClosureAttribute1Optional[.onplaying, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onplaying, in: jsObject] = newValue }
    }

    @inlinable var onprogress: EventHandler {
        get { ClosureAttribute1Optional[.onprogress, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onprogress, in: jsObject] = newValue }
    }

    @inlinable var onratechange: EventHandler {
        get { ClosureAttribute1Optional[.onratechange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onratechange, in: jsObject] = newValue }
    }

    @inlinable var onreset: EventHandler {
        get { ClosureAttribute1Optional[.onreset, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onreset, in: jsObject] = newValue }
    }

    @inlinable var onresize: EventHandler {
        get { ClosureAttribute1Optional[.onresize, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onresize, in: jsObject] = newValue }
    }

    @inlinable var onscroll: EventHandler {
        get { ClosureAttribute1Optional[.onscroll, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onscroll, in: jsObject] = newValue }
    }

    @inlinable var onscrollend: EventHandler {
        get { ClosureAttribute1Optional[.onscrollend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onscrollend, in: jsObject] = newValue }
    }

    @inlinable var onsecuritypolicyviolation: EventHandler {
        get { ClosureAttribute1Optional[.onsecuritypolicyviolation, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onsecuritypolicyviolation, in: jsObject] = newValue }
    }

    @inlinable var onseeked: EventHandler {
        get { ClosureAttribute1Optional[.onseeked, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onseeked, in: jsObject] = newValue }
    }

    @inlinable var onseeking: EventHandler {
        get { ClosureAttribute1Optional[.onseeking, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onseeking, in: jsObject] = newValue }
    }

    @inlinable var onselect: EventHandler {
        get { ClosureAttribute1Optional[.onselect, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onselect, in: jsObject] = newValue }
    }

    @inlinable var onslotchange: EventHandler {
        get { ClosureAttribute1Optional[.onslotchange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onslotchange, in: jsObject] = newValue }
    }

    @inlinable var onstalled: EventHandler {
        get { ClosureAttribute1Optional[.onstalled, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onstalled, in: jsObject] = newValue }
    }

    @inlinable var onsubmit: EventHandler {
        get { ClosureAttribute1Optional[.onsubmit, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onsubmit, in: jsObject] = newValue }
    }

    @inlinable var onsuspend: EventHandler {
        get { ClosureAttribute1Optional[.onsuspend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onsuspend, in: jsObject] = newValue }
    }

    @inlinable var ontimeupdate: EventHandler {
        get { ClosureAttribute1Optional[.ontimeupdate, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ontimeupdate, in: jsObject] = newValue }
    }

    @inlinable var ontoggle: EventHandler {
        get { ClosureAttribute1Optional[.ontoggle, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ontoggle, in: jsObject] = newValue }
    }

    @inlinable var onvolumechange: EventHandler {
        get { ClosureAttribute1Optional[.onvolumechange, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onvolumechange, in: jsObject] = newValue }
    }

    @inlinable var onwaiting: EventHandler {
        get { ClosureAttribute1Optional[.onwaiting, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onwaiting, in: jsObject] = newValue }
    }

    @inlinable var onwebkitanimationend: EventHandler {
        get { ClosureAttribute1Optional[.onwebkitanimationend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onwebkitanimationend, in: jsObject] = newValue }
    }

    @inlinable var onwebkitanimationiteration: EventHandler {
        get { ClosureAttribute1Optional[.onwebkitanimationiteration, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onwebkitanimationiteration, in: jsObject] = newValue }
    }

    @inlinable var onwebkitanimationstart: EventHandler {
        get { ClosureAttribute1Optional[.onwebkitanimationstart, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onwebkitanimationstart, in: jsObject] = newValue }
    }

    @inlinable var onwebkittransitionend: EventHandler {
        get { ClosureAttribute1Optional[.onwebkittransitionend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onwebkittransitionend, in: jsObject] = newValue }
    }

    @inlinable var onwheel: EventHandler {
        get { ClosureAttribute1Optional[.onwheel, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.onwheel, in: jsObject] = newValue }
    }

    @inlinable var ontouchstart: EventHandler {
        get { ClosureAttribute1Optional[.ontouchstart, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ontouchstart, in: jsObject] = newValue }
    }

    @inlinable var ontouchend: EventHandler {
        get { ClosureAttribute1Optional[.ontouchend, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ontouchend, in: jsObject] = newValue }
    }

    @inlinable var ontouchmove: EventHandler {
        get { ClosureAttribute1Optional[.ontouchmove, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ontouchmove, in: jsObject] = newValue }
    }

    @inlinable var ontouchcancel: EventHandler {
        get { ClosureAttribute1Optional[.ontouchcancel, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ontouchcancel, in: jsObject] = newValue }
    }
}

public class HTMLAllCollection: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.HTMLAllCollection].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Element {
        jsObject[key].fromJSValue()!
    }

    @inlinable public subscript(key: String) -> Element_or_HTMLCollection? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func namedItem(name: String) -> Element_or_HTMLCollection? {
        let this = jsObject
        return this[.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }

    @inlinable public func item(nameOrIndex: String? = nil) -> Element_or_HTMLCollection? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(nameOrIndex)]).fromJSValue()
    }
}

public class HTMLAnchorElement: HTMLElement, HTMLHyperlinkElementUtils {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLAnchorElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _target = ReadWriteAttribute(jsObject: jsObject, name: .target)
        _download = ReadWriteAttribute(jsObject: jsObject, name: .download)
        _ping = ReadWriteAttribute(jsObject: jsObject, name: .ping)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: .rel)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: .relList)
        _hreflang = ReadWriteAttribute(jsObject: jsObject, name: .hreflang)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        _text = ReadWriteAttribute(jsObject: jsObject, name: .text)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: .referrerPolicy)
        _coords = ReadWriteAttribute(jsObject: jsObject, name: .coords)
        _charset = ReadWriteAttribute(jsObject: jsObject, name: .charset)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _rev = ReadWriteAttribute(jsObject: jsObject, name: .rev)
        _shape = ReadWriteAttribute(jsObject: jsObject, name: .shape)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var target: String

    @ReadWriteAttribute
    public var download: String

    @ReadWriteAttribute
    public var ping: String

    @ReadWriteAttribute
    public var rel: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadWriteAttribute
    public var hreflang: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var text: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var coords: String

    @ReadWriteAttribute
    public var charset: String

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var rev: String

    @ReadWriteAttribute
    public var shape: String
}

public class HTMLAreaElement: HTMLElement, HTMLHyperlinkElementUtils {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLAreaElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _alt = ReadWriteAttribute(jsObject: jsObject, name: .alt)
        _coords = ReadWriteAttribute(jsObject: jsObject, name: .coords)
        _shape = ReadWriteAttribute(jsObject: jsObject, name: .shape)
        _target = ReadWriteAttribute(jsObject: jsObject, name: .target)
        _download = ReadWriteAttribute(jsObject: jsObject, name: .download)
        _ping = ReadWriteAttribute(jsObject: jsObject, name: .ping)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: .rel)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: .relList)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: .referrerPolicy)
        _noHref = ReadWriteAttribute(jsObject: jsObject, name: .noHref)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var alt: String

    @ReadWriteAttribute
    public var coords: String

    @ReadWriteAttribute
    public var shape: String

    @ReadWriteAttribute
    public var target: String

    @ReadWriteAttribute
    public var download: String

    @ReadWriteAttribute
    public var ping: String

    @ReadWriteAttribute
    public var rel: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var noHref: Bool
}

public class HTMLAudioElement: HTMLMediaElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLAudioElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }
}

public class HTMLBRElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLBRElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _clear = ReadWriteAttribute(jsObject: jsObject, name: .clear)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var clear: String
}

public class HTMLBaseElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLBaseElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _href = ReadWriteAttribute(jsObject: jsObject, name: .href)
        _target = ReadWriteAttribute(jsObject: jsObject, name: .target)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var href: String

    @ReadWriteAttribute
    public var target: String
}

public class HTMLBodyElement: HTMLElement, WindowEventHandlers {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLBodyElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _text = ReadWriteAttribute(jsObject: jsObject, name: .text)
        _link = ReadWriteAttribute(jsObject: jsObject, name: .link)
        _vLink = ReadWriteAttribute(jsObject: jsObject, name: .vLink)
        _aLink = ReadWriteAttribute(jsObject: jsObject, name: .aLink)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: .bgColor)
        _background = ReadWriteAttribute(jsObject: jsObject, name: .background)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var text: String

    @ReadWriteAttribute
    public var link: String

    @ReadWriteAttribute
    public var vLink: String

    @ReadWriteAttribute
    public var aLink: String

    @ReadWriteAttribute
    public var bgColor: String

    @ReadWriteAttribute
    public var background: String
}

public class HTMLButtonElement: HTMLElement, PopoverInvokerElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLButtonElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: .disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: .form)
        _formAction = ReadWriteAttribute(jsObject: jsObject, name: .formAction)
        _formEnctype = ReadWriteAttribute(jsObject: jsObject, name: .formEnctype)
        _formMethod = ReadWriteAttribute(jsObject: jsObject, name: .formMethod)
        _formNoValidate = ReadWriteAttribute(jsObject: jsObject, name: .formNoValidate)
        _formTarget = ReadWriteAttribute(jsObject: jsObject, name: .formTarget)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: .willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: .validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: .validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: .labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var formAction: String

    @ReadWriteAttribute
    public var formEnctype: String

    @ReadWriteAttribute
    public var formMethod: String

    @ReadWriteAttribute
    public var formNoValidate: Bool

    @ReadWriteAttribute
    public var formTarget: String

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLCanvasElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLCanvasElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    // XXX: member 'getContext' is ignored

    @inlinable public func toDataURL(type: String? = nil, quality: JSValue? = nil) -> String {
        let this = jsObject
        return this[.toDataURL].function!(this: this, arguments: [_toJSValue(type), _toJSValue(quality)]).fromJSValue()!
    }

    @inlinable public func toBlob(callback: @escaping BlobCallback, type: String? = nil, quality: JSValue? = nil) {
        let this = jsObject
        _ = this[.toBlob].function!(this: this, arguments: [_toJSValue(callback), _toJSValue(type), _toJSValue(quality)])
    }

    @inlinable public func transferControlToOffscreen() -> OffscreenCanvas {
        let this = jsObject
        return this[.transferControlToOffscreen].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class HTMLCollection: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.HTMLCollection].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Element? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(index: UInt32) -> Element? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> Element? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func namedItem(name: String) -> Element? {
        let this = jsObject
        return this[.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public class HTMLDListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLDListElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: .compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLDataElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLDataElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: String
}

public class HTMLDataListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLDataListElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _options = ReadonlyAttribute(jsObject: jsObject, name: .options)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var options: HTMLCollection
}

public class HTMLDetailsElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLDetailsElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _open = ReadWriteAttribute(jsObject: jsObject, name: .open)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var open: Bool
}

public class HTMLDialogElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLDialogElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _open = ReadWriteAttribute(jsObject: jsObject, name: .open)
        _returnValue = ReadWriteAttribute(jsObject: jsObject, name: .returnValue)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var open: Bool

    @ReadWriteAttribute
    public var returnValue: String

    @inlinable public func show() {
        let this = jsObject
        _ = this[.show].function!(this: this, arguments: [])
    }

    @inlinable public func showModal() {
        let this = jsObject
        _ = this[.showModal].function!(this: this, arguments: [])
    }

    @inlinable public func close(returnValue: String? = nil) {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [_toJSValue(returnValue)])
    }
}

public class HTMLDirectoryElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLDirectoryElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: .compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLDivElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLDivElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLElement: Element, GlobalEventHandlers, ElementContentEditable, HTMLOrSVGElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _title = ReadWriteAttribute(jsObject: jsObject, name: .title)
        _lang = ReadWriteAttribute(jsObject: jsObject, name: .lang)
        _translate = ReadWriteAttribute(jsObject: jsObject, name: .translate)
        _dir = ReadWriteAttribute(jsObject: jsObject, name: .dir)
        _hidden = ReadWriteAttribute(jsObject: jsObject, name: .hidden)
        _inert = ReadWriteAttribute(jsObject: jsObject, name: .inert)
        _accessKey = ReadWriteAttribute(jsObject: jsObject, name: .accessKey)
        _accessKeyLabel = ReadonlyAttribute(jsObject: jsObject, name: .accessKeyLabel)
        _draggable = ReadWriteAttribute(jsObject: jsObject, name: .draggable)
        _spellcheck = ReadWriteAttribute(jsObject: jsObject, name: .spellcheck)
        _autocapitalize = ReadWriteAttribute(jsObject: jsObject, name: .autocapitalize)
        _innerText = ReadWriteAttribute(jsObject: jsObject, name: .innerText)
        _outerText = ReadWriteAttribute(jsObject: jsObject, name: .outerText)
        _popover = ReadWriteAttribute(jsObject: jsObject, name: .popover)
        _offsetParent = ReadonlyAttribute(jsObject: jsObject, name: .offsetParent)
        _offsetTop = ReadonlyAttribute(jsObject: jsObject, name: .offsetTop)
        _offsetLeft = ReadonlyAttribute(jsObject: jsObject, name: .offsetLeft)
        _offsetWidth = ReadonlyAttribute(jsObject: jsObject, name: .offsetWidth)
        _offsetHeight = ReadonlyAttribute(jsObject: jsObject, name: .offsetHeight)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var title: String

    @ReadWriteAttribute
    public var lang: String

    @ReadWriteAttribute
    public var translate: Bool

    @ReadWriteAttribute
    public var dir: String

    @ReadWriteAttribute
    public var hidden: Bool_or_Double_or_String?

    @ReadWriteAttribute
    public var inert: Bool

    @inlinable public func click() {
        let this = jsObject
        _ = this[.click].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var accessKey: String

    @ReadonlyAttribute
    public var accessKeyLabel: String

    @ReadWriteAttribute
    public var draggable: Bool

    @ReadWriteAttribute
    public var spellcheck: Bool

    @ReadWriteAttribute
    public var autocapitalize: String

    @ReadWriteAttribute
    public var innerText: String

    @ReadWriteAttribute
    public var outerText: String

    @inlinable public func attachInternals() -> ElementInternals {
        let this = jsObject
        return this[.attachInternals].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func showPopover() {
        let this = jsObject
        _ = this[.showPopover].function!(this: this, arguments: [])
    }

    @inlinable public func hidePopover() {
        let this = jsObject
        _ = this[.hidePopover].function!(this: this, arguments: [])
    }

    @inlinable public func togglePopover(force: Bool? = nil) -> Bool {
        let this = jsObject
        return this[.togglePopover].function!(this: this, arguments: [_toJSValue(force)]).fromJSValue()!
    }

    @ReadWriteAttribute
    public var popover: String?

    @ReadonlyAttribute
    public var offsetParent: Element?

    @ReadonlyAttribute
    public var offsetTop: Int32

    @ReadonlyAttribute
    public var offsetLeft: Int32

    @ReadonlyAttribute
    public var offsetWidth: Int32

    @ReadonlyAttribute
    public var offsetHeight: Int32
}

public class HTMLEmbedElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLEmbedElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: .src)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var height: String

    @inlinable public func getSVGDocument() -> Document? {
        let this = jsObject
        return this[.getSVGDocument].function!(this: this, arguments: []).fromJSValue()
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var name: String
}

public class HTMLFieldSetElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLFieldSetElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: .disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: .form)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _elements = ReadonlyAttribute(jsObject: jsObject, name: .elements)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: .willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: .validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: .validationMessage)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var elements: HTMLCollection

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }
}

public class HTMLFontElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLFontElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _color = ReadWriteAttribute(jsObject: jsObject, name: .color)
        _face = ReadWriteAttribute(jsObject: jsObject, name: .face)
        _size = ReadWriteAttribute(jsObject: jsObject, name: .size)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var color: String

    @ReadWriteAttribute
    public var face: String

    @ReadWriteAttribute
    public var size: String
}

public class HTMLFormControlsCollection: HTMLCollection {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLFormControlsCollection].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public subscript(key: String) -> Element_or_RadioNodeList? {
        jsObject[key].fromJSValue()
    }

    // `override` removed since the superclass returns a more constrained type `Element`
    @inlinable func namedItem(name: String) -> Element_or_RadioNodeList? {
        let this = jsObject
        return this[.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public class HTMLFormElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLFormElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _acceptCharset = ReadWriteAttribute(jsObject: jsObject, name: .acceptCharset)
        _action = ReadWriteAttribute(jsObject: jsObject, name: .action)
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: .autocomplete)
        _enctype = ReadWriteAttribute(jsObject: jsObject, name: .enctype)
        _encoding = ReadWriteAttribute(jsObject: jsObject, name: .encoding)
        _method = ReadWriteAttribute(jsObject: jsObject, name: .method)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _noValidate = ReadWriteAttribute(jsObject: jsObject, name: .noValidate)
        _target = ReadWriteAttribute(jsObject: jsObject, name: .target)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: .rel)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: .relList)
        _elements = ReadonlyAttribute(jsObject: jsObject, name: .elements)
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var acceptCharset: String

    @ReadWriteAttribute
    public var action: String

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var enctype: String

    @ReadWriteAttribute
    public var encoding: String

    @ReadWriteAttribute
    public var method: String

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var noValidate: Bool

    @ReadWriteAttribute
    public var target: String

    @ReadWriteAttribute
    public var rel: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadonlyAttribute
    public var elements: HTMLFormControlsCollection

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Element {
        jsObject[key].fromJSValue()!
    }

    @inlinable public subscript(key: String) -> Element_or_RadioNodeList {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func submit() {
        let this = jsObject
        _ = this[.submit].function!(this: this, arguments: [])
    }

    @inlinable public func requestSubmit(submitter: HTMLElement? = nil) {
        let this = jsObject
        _ = this[.requestSubmit].function!(this: this, arguments: [_toJSValue(submitter)])
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[.reset].function!(this: this, arguments: [])
    }

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class HTMLFrameElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLFrameElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _scrolling = ReadWriteAttribute(jsObject: jsObject, name: .scrolling)
        _src = ReadWriteAttribute(jsObject: jsObject, name: .src)
        _frameBorder = ReadWriteAttribute(jsObject: jsObject, name: .frameBorder)
        _longDesc = ReadWriteAttribute(jsObject: jsObject, name: .longDesc)
        _noResize = ReadWriteAttribute(jsObject: jsObject, name: .noResize)
        _contentDocument = ReadonlyAttribute(jsObject: jsObject, name: .contentDocument)
        _contentWindow = ReadonlyAttribute(jsObject: jsObject, name: .contentWindow)
        _marginHeight = ReadWriteAttribute(jsObject: jsObject, name: .marginHeight)
        _marginWidth = ReadWriteAttribute(jsObject: jsObject, name: .marginWidth)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var scrolling: String

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var frameBorder: String

    @ReadWriteAttribute
    public var longDesc: String

    @ReadWriteAttribute
    public var noResize: Bool

    @ReadonlyAttribute
    public var contentDocument: Document?

    @ReadonlyAttribute
    public var contentWindow: WindowProxy?

    @ReadWriteAttribute
    public var marginHeight: String

    @ReadWriteAttribute
    public var marginWidth: String
}

public class HTMLFrameSetElement: HTMLElement, WindowEventHandlers {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLFrameSetElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _cols = ReadWriteAttribute(jsObject: jsObject, name: .cols)
        _rows = ReadWriteAttribute(jsObject: jsObject, name: .rows)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var cols: String

    @ReadWriteAttribute
    public var rows: String
}

public class HTMLHRElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLHRElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        _color = ReadWriteAttribute(jsObject: jsObject, name: .color)
        _noShade = ReadWriteAttribute(jsObject: jsObject, name: .noShade)
        _size = ReadWriteAttribute(jsObject: jsObject, name: .size)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var color: String

    @ReadWriteAttribute
    public var noShade: Bool

    @ReadWriteAttribute
    public var size: String

    @ReadWriteAttribute
    public var width: String
}

public class HTMLHeadElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLHeadElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }
}

public class HTMLHeadingElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLHeadingElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLHtmlElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLHtmlElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _version = ReadWriteAttribute(jsObject: jsObject, name: .version)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var version: String
}

public protocol HTMLHyperlinkElementUtils: JSBridgedClass {}
public extension HTMLHyperlinkElementUtils {
    @inlinable var href: String {
        get { jsObject[.href].fromJSValue()! }
        nonmutating set { jsObject[.href] = _toJSValue(newValue) }
    }

    @inlinable var origin: String { jsObject[.origin].fromJSValue()! }

    @inlinable var `protocol`: String {
        get { jsObject[.protocol].fromJSValue()! }
        nonmutating set { jsObject[.protocol] = _toJSValue(newValue) }
    }

    @inlinable var username: String {
        get { jsObject[.username].fromJSValue()! }
        nonmutating set { jsObject[.username] = _toJSValue(newValue) }
    }

    @inlinable var password: String {
        get { jsObject[.password].fromJSValue()! }
        nonmutating set { jsObject[.password] = _toJSValue(newValue) }
    }

    @inlinable var host: String {
        get { jsObject[.host].fromJSValue()! }
        nonmutating set { jsObject[.host] = _toJSValue(newValue) }
    }

    @inlinable var hostname: String {
        get { jsObject[.hostname].fromJSValue()! }
        nonmutating set { jsObject[.hostname] = _toJSValue(newValue) }
    }

    @inlinable var port: String {
        get { jsObject[.port].fromJSValue()! }
        nonmutating set { jsObject[.port] = _toJSValue(newValue) }
    }

    @inlinable var pathname: String {
        get { jsObject[.pathname].fromJSValue()! }
        nonmutating set { jsObject[.pathname] = _toJSValue(newValue) }
    }

    @inlinable var search: String {
        get { jsObject[.search].fromJSValue()! }
        nonmutating set { jsObject[.search] = _toJSValue(newValue) }
    }

    @inlinable var hash: String {
        get { jsObject[.hash].fromJSValue()! }
        nonmutating set { jsObject[.hash] = _toJSValue(newValue) }
    }
}

public class HTMLIFrameElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLIFrameElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: .src)
        _srcdoc = ReadWriteAttribute(jsObject: jsObject, name: .srcdoc)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _sandbox = ReadonlyAttribute(jsObject: jsObject, name: .sandbox)
        _allow = ReadWriteAttribute(jsObject: jsObject, name: .allow)
        _allowFullscreen = ReadWriteAttribute(jsObject: jsObject, name: .allowFullscreen)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: .referrerPolicy)
        _loading = ReadWriteAttribute(jsObject: jsObject, name: .loading)
        _contentDocument = ReadonlyAttribute(jsObject: jsObject, name: .contentDocument)
        _contentWindow = ReadonlyAttribute(jsObject: jsObject, name: .contentWindow)
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        _scrolling = ReadWriteAttribute(jsObject: jsObject, name: .scrolling)
        _frameBorder = ReadWriteAttribute(jsObject: jsObject, name: .frameBorder)
        _longDesc = ReadWriteAttribute(jsObject: jsObject, name: .longDesc)
        _marginHeight = ReadWriteAttribute(jsObject: jsObject, name: .marginHeight)
        _marginWidth = ReadWriteAttribute(jsObject: jsObject, name: .marginWidth)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srcdoc: String

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var sandbox: DOMTokenList

    @ReadWriteAttribute
    public var allow: String

    @ReadWriteAttribute
    public var allowFullscreen: Bool

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var height: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var loading: String

    @ReadonlyAttribute
    public var contentDocument: Document?

    @ReadonlyAttribute
    public var contentWindow: WindowProxy?

    @inlinable public func getSVGDocument() -> Document? {
        let this = jsObject
        return this[.getSVGDocument].function!(this: this, arguments: []).fromJSValue()
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var scrolling: String

    @ReadWriteAttribute
    public var frameBorder: String

    @ReadWriteAttribute
    public var longDesc: String

    @ReadWriteAttribute
    public var marginHeight: String

    @ReadWriteAttribute
    public var marginWidth: String
}

public class HTMLImageElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLImageElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _alt = ReadWriteAttribute(jsObject: jsObject, name: .alt)
        _src = ReadWriteAttribute(jsObject: jsObject, name: .src)
        _srcset = ReadWriteAttribute(jsObject: jsObject, name: .srcset)
        _sizes = ReadWriteAttribute(jsObject: jsObject, name: .sizes)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: .crossOrigin)
        _useMap = ReadWriteAttribute(jsObject: jsObject, name: .useMap)
        _isMap = ReadWriteAttribute(jsObject: jsObject, name: .isMap)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        _naturalWidth = ReadonlyAttribute(jsObject: jsObject, name: .naturalWidth)
        _naturalHeight = ReadonlyAttribute(jsObject: jsObject, name: .naturalHeight)
        _complete = ReadonlyAttribute(jsObject: jsObject, name: .complete)
        _currentSrc = ReadonlyAttribute(jsObject: jsObject, name: .currentSrc)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: .referrerPolicy)
        _decoding = ReadWriteAttribute(jsObject: jsObject, name: .decoding)
        _loading = ReadWriteAttribute(jsObject: jsObject, name: .loading)
        _fetchPriority = ReadWriteAttribute(jsObject: jsObject, name: .fetchPriority)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _lowsrc = ReadWriteAttribute(jsObject: jsObject, name: .lowsrc)
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        _hspace = ReadWriteAttribute(jsObject: jsObject, name: .hspace)
        _vspace = ReadWriteAttribute(jsObject: jsObject, name: .vspace)
        _longDesc = ReadWriteAttribute(jsObject: jsObject, name: .longDesc)
        _border = ReadWriteAttribute(jsObject: jsObject, name: .border)
        _x = ReadonlyAttribute(jsObject: jsObject, name: .x)
        _y = ReadonlyAttribute(jsObject: jsObject, name: .y)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var alt: String

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srcset: String

    @ReadWriteAttribute
    public var sizes: String

    @ReadWriteAttribute
    public var crossOrigin: String?

    @ReadWriteAttribute
    public var useMap: String

    @ReadWriteAttribute
    public var isMap: Bool

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    @ReadonlyAttribute
    public var naturalWidth: UInt32

    @ReadonlyAttribute
    public var naturalHeight: UInt32

    @ReadonlyAttribute
    public var complete: Bool

    @ReadonlyAttribute
    public var currentSrc: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadWriteAttribute
    public var decoding: String

    @ReadWriteAttribute
    public var loading: String

    @ReadWriteAttribute
    public var fetchPriority: String

    @inlinable public func decode() -> JSPromise {
        let this = jsObject
        return this[.decode].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func decode() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.decode].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var lowsrc: String

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var hspace: UInt32

    @ReadWriteAttribute
    public var vspace: UInt32

    @ReadWriteAttribute
    public var longDesc: String

    @ReadWriteAttribute
    public var border: String

    @ReadonlyAttribute
    public var x: Int32

    @ReadonlyAttribute
    public var y: Int32
}

public class HTMLInputElement: HTMLElement, PopoverInvokerElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLInputElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _accept = ReadWriteAttribute(jsObject: jsObject, name: .accept)
        _alt = ReadWriteAttribute(jsObject: jsObject, name: .alt)
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: .autocomplete)
        _defaultChecked = ReadWriteAttribute(jsObject: jsObject, name: .defaultChecked)
        _checked = ReadWriteAttribute(jsObject: jsObject, name: .checked)
        _dirName = ReadWriteAttribute(jsObject: jsObject, name: .dirName)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: .disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: .form)
        _files = ReadWriteAttribute(jsObject: jsObject, name: .files)
        _formAction = ReadWriteAttribute(jsObject: jsObject, name: .formAction)
        _formEnctype = ReadWriteAttribute(jsObject: jsObject, name: .formEnctype)
        _formMethod = ReadWriteAttribute(jsObject: jsObject, name: .formMethod)
        _formNoValidate = ReadWriteAttribute(jsObject: jsObject, name: .formNoValidate)
        _formTarget = ReadWriteAttribute(jsObject: jsObject, name: .formTarget)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        _indeterminate = ReadWriteAttribute(jsObject: jsObject, name: .indeterminate)
        _list = ReadonlyAttribute(jsObject: jsObject, name: .list)
        _max = ReadWriteAttribute(jsObject: jsObject, name: .max)
        _maxLength = ReadWriteAttribute(jsObject: jsObject, name: .maxLength)
        _min = ReadWriteAttribute(jsObject: jsObject, name: .min)
        _minLength = ReadWriteAttribute(jsObject: jsObject, name: .minLength)
        _multiple = ReadWriteAttribute(jsObject: jsObject, name: .multiple)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _pattern = ReadWriteAttribute(jsObject: jsObject, name: .pattern)
        _placeholder = ReadWriteAttribute(jsObject: jsObject, name: .placeholder)
        _readOnly = ReadWriteAttribute(jsObject: jsObject, name: .readOnly)
        _required = ReadWriteAttribute(jsObject: jsObject, name: .required)
        _size = ReadWriteAttribute(jsObject: jsObject, name: .size)
        _src = ReadWriteAttribute(jsObject: jsObject, name: .src)
        _step = ReadWriteAttribute(jsObject: jsObject, name: .step)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        _defaultValue = ReadWriteAttribute(jsObject: jsObject, name: .defaultValue)
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        _valueAsDate = ReadWriteAttribute(jsObject: jsObject, name: .valueAsDate)
        _valueAsNumber = ReadWriteAttribute(jsObject: jsObject, name: .valueAsNumber)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: .willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: .validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: .validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: .labels)
        _selectionStart = ReadWriteAttribute(jsObject: jsObject, name: .selectionStart)
        _selectionEnd = ReadWriteAttribute(jsObject: jsObject, name: .selectionEnd)
        _selectionDirection = ReadWriteAttribute(jsObject: jsObject, name: .selectionDirection)
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        _useMap = ReadWriteAttribute(jsObject: jsObject, name: .useMap)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var accept: String

    @ReadWriteAttribute
    public var alt: String

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var defaultChecked: Bool

    @ReadWriteAttribute
    public var checked: Bool

    @ReadWriteAttribute
    public var dirName: String

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var files: FileList?

    @ReadWriteAttribute
    public var formAction: String

    @ReadWriteAttribute
    public var formEnctype: String

    @ReadWriteAttribute
    public var formMethod: String

    @ReadWriteAttribute
    public var formNoValidate: Bool

    @ReadWriteAttribute
    public var formTarget: String

    @ReadWriteAttribute
    public var height: UInt32

    @ReadWriteAttribute
    public var indeterminate: Bool

    @ReadonlyAttribute
    public var list: HTMLDataListElement?

    @ReadWriteAttribute
    public var max: String

    @ReadWriteAttribute
    public var maxLength: Int32

    @ReadWriteAttribute
    public var min: String

    @ReadWriteAttribute
    public var minLength: Int32

    @ReadWriteAttribute
    public var multiple: Bool

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var pattern: String

    @ReadWriteAttribute
    public var placeholder: String

    @ReadWriteAttribute
    public var readOnly: Bool

    @ReadWriteAttribute
    public var required: Bool

    @ReadWriteAttribute
    public var size: UInt32

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var step: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var defaultValue: String

    @ReadWriteAttribute
    public var value: String

    @ReadWriteAttribute
    public var valueAsDate: JSObject?

    @ReadWriteAttribute
    public var valueAsNumber: Double

    @ReadWriteAttribute
    public var width: UInt32

    @inlinable public func stepUp(n: Int32? = nil) {
        let this = jsObject
        _ = this[.stepUp].function!(this: this, arguments: [_toJSValue(n)])
    }

    @inlinable public func stepDown(n: Int32? = nil) {
        let this = jsObject
        _ = this[.stepDown].function!(this: this, arguments: [_toJSValue(n)])
    }

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @ReadonlyAttribute
    public var labels: NodeList?

    @inlinable public func select() {
        let this = jsObject
        _ = this[.select].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var selectionStart: UInt32?

    @ReadWriteAttribute
    public var selectionEnd: UInt32?

    @ReadWriteAttribute
    public var selectionDirection: String?

    @inlinable public func setRangeText(replacement: String) {
        let this = jsObject
        _ = this[.setRangeText].function!(this: this, arguments: [_toJSValue(replacement)])
    }

    @inlinable public func setRangeText(replacement: String, start: UInt32, end: UInt32, selectionMode: SelectionMode? = nil) {
        let this = jsObject
        _ = this[.setRangeText].function!(this: this, arguments: [_toJSValue(replacement), _toJSValue(start), _toJSValue(end), _toJSValue(selectionMode)])
    }

    @inlinable public func setSelectionRange(start: UInt32, end: UInt32, direction: String? = nil) {
        let this = jsObject
        _ = this[.setSelectionRange].function!(this: this, arguments: [_toJSValue(start), _toJSValue(end), _toJSValue(direction)])
    }

    @inlinable public func showPicker() {
        let this = jsObject
        _ = this[.showPicker].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var useMap: String
}

public class HTMLLIElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLLIElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: Int32

    @ReadWriteAttribute
    public var type: String
}

public class HTMLLabelElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLLabelElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _form = ReadonlyAttribute(jsObject: jsObject, name: .form)
        _htmlFor = ReadWriteAttribute(jsObject: jsObject, name: .htmlFor)
        _control = ReadonlyAttribute(jsObject: jsObject, name: .control)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var htmlFor: String

    @ReadonlyAttribute
    public var control: HTMLElement?
}

public class HTMLLegendElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLLegendElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _form = ReadonlyAttribute(jsObject: jsObject, name: .form)
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var align: String
}

public class HTMLLinkElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLLinkElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _href = ReadWriteAttribute(jsObject: jsObject, name: .href)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: .crossOrigin)
        _rel = ReadWriteAttribute(jsObject: jsObject, name: .rel)
        _as = ReadWriteAttribute(jsObject: jsObject, name: .as)
        _relList = ReadonlyAttribute(jsObject: jsObject, name: .relList)
        _media = ReadWriteAttribute(jsObject: jsObject, name: .media)
        _integrity = ReadWriteAttribute(jsObject: jsObject, name: .integrity)
        _hreflang = ReadWriteAttribute(jsObject: jsObject, name: .hreflang)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        _sizes = ReadonlyAttribute(jsObject: jsObject, name: .sizes)
        _imageSrcset = ReadWriteAttribute(jsObject: jsObject, name: .imageSrcset)
        _imageSizes = ReadWriteAttribute(jsObject: jsObject, name: .imageSizes)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: .referrerPolicy)
        _blocking = ReadonlyAttribute(jsObject: jsObject, name: .blocking)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: .disabled)
        _fetchPriority = ReadWriteAttribute(jsObject: jsObject, name: .fetchPriority)
        _charset = ReadWriteAttribute(jsObject: jsObject, name: .charset)
        _rev = ReadWriteAttribute(jsObject: jsObject, name: .rev)
        _target = ReadWriteAttribute(jsObject: jsObject, name: .target)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var href: String

    @ReadWriteAttribute
    public var crossOrigin: String?

    @ReadWriteAttribute
    public var rel: String

    @ReadWriteAttribute
    public var `as`: String

    @ReadonlyAttribute
    public var relList: DOMTokenList

    @ReadWriteAttribute
    public var media: String

    @ReadWriteAttribute
    public var integrity: String

    @ReadWriteAttribute
    public var hreflang: String

    @ReadWriteAttribute
    public var type: String

    @ReadonlyAttribute
    public var sizes: DOMTokenList

    @ReadWriteAttribute
    public var imageSrcset: String

    @ReadWriteAttribute
    public var imageSizes: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadonlyAttribute
    public var blocking: DOMTokenList

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadWriteAttribute
    public var fetchPriority: String

    @ReadWriteAttribute
    public var charset: String

    @ReadWriteAttribute
    public var rev: String

    @ReadWriteAttribute
    public var target: String
}

public class HTMLMapElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLMapElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _areas = ReadonlyAttribute(jsObject: jsObject, name: .areas)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var areas: HTMLCollection
}

public class HTMLMarqueeElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLMarqueeElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _behavior = ReadWriteAttribute(jsObject: jsObject, name: .behavior)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: .bgColor)
        _direction = ReadWriteAttribute(jsObject: jsObject, name: .direction)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        _hspace = ReadWriteAttribute(jsObject: jsObject, name: .hspace)
        _loop = ReadWriteAttribute(jsObject: jsObject, name: .loop)
        _scrollAmount = ReadWriteAttribute(jsObject: jsObject, name: .scrollAmount)
        _scrollDelay = ReadWriteAttribute(jsObject: jsObject, name: .scrollDelay)
        _trueSpeed = ReadWriteAttribute(jsObject: jsObject, name: .trueSpeed)
        _vspace = ReadWriteAttribute(jsObject: jsObject, name: .vspace)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var behavior: String

    @ReadWriteAttribute
    public var bgColor: String

    @ReadWriteAttribute
    public var direction: String

    @ReadWriteAttribute
    public var height: String

    @ReadWriteAttribute
    public var hspace: UInt32

    @ReadWriteAttribute
    public var loop: Int32

    @ReadWriteAttribute
    public var scrollAmount: UInt32

    @ReadWriteAttribute
    public var scrollDelay: UInt32

    @ReadWriteAttribute
    public var trueSpeed: Bool

    @ReadWriteAttribute
    public var vspace: UInt32

    @ReadWriteAttribute
    public var width: String

    @inlinable public func start() {
        let this = jsObject
        _ = this[.start].function!(this: this, arguments: [])
    }

    @inlinable public func stop() {
        let this = jsObject
        _ = this[.stop].function!(this: this, arguments: [])
    }
}

public class HTMLMediaElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLMediaElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _error = ReadonlyAttribute(jsObject: jsObject, name: .error)
        _src = ReadWriteAttribute(jsObject: jsObject, name: .src)
        _srcObject = ReadWriteAttribute(jsObject: jsObject, name: .srcObject)
        _currentSrc = ReadonlyAttribute(jsObject: jsObject, name: .currentSrc)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: .crossOrigin)
        _networkState = ReadonlyAttribute(jsObject: jsObject, name: .networkState)
        _preload = ReadWriteAttribute(jsObject: jsObject, name: .preload)
        _buffered = ReadonlyAttribute(jsObject: jsObject, name: .buffered)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: .readyState)
        _seeking = ReadonlyAttribute(jsObject: jsObject, name: .seeking)
        _currentTime = ReadWriteAttribute(jsObject: jsObject, name: .currentTime)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: .duration)
        _paused = ReadonlyAttribute(jsObject: jsObject, name: .paused)
        _defaultPlaybackRate = ReadWriteAttribute(jsObject: jsObject, name: .defaultPlaybackRate)
        _playbackRate = ReadWriteAttribute(jsObject: jsObject, name: .playbackRate)
        _preservesPitch = ReadWriteAttribute(jsObject: jsObject, name: .preservesPitch)
        _played = ReadonlyAttribute(jsObject: jsObject, name: .played)
        _seekable = ReadonlyAttribute(jsObject: jsObject, name: .seekable)
        _ended = ReadonlyAttribute(jsObject: jsObject, name: .ended)
        _autoplay = ReadWriteAttribute(jsObject: jsObject, name: .autoplay)
        _loop = ReadWriteAttribute(jsObject: jsObject, name: .loop)
        _controls = ReadWriteAttribute(jsObject: jsObject, name: .controls)
        _volume = ReadWriteAttribute(jsObject: jsObject, name: .volume)
        _muted = ReadWriteAttribute(jsObject: jsObject, name: .muted)
        _defaultMuted = ReadWriteAttribute(jsObject: jsObject, name: .defaultMuted)
        _audioTracks = ReadonlyAttribute(jsObject: jsObject, name: .audioTracks)
        _videoTracks = ReadonlyAttribute(jsObject: jsObject, name: .videoTracks)
        _textTracks = ReadonlyAttribute(jsObject: jsObject, name: .textTracks)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var error: MediaError?

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srcObject: MediaProvider?

    @ReadonlyAttribute
    public var currentSrc: String

    @ReadWriteAttribute
    public var crossOrigin: String?

    public static let NETWORK_EMPTY: UInt16 = 0

    public static let NETWORK_IDLE: UInt16 = 1

    public static let NETWORK_LOADING: UInt16 = 2

    public static let NETWORK_NO_SOURCE: UInt16 = 3

    @ReadonlyAttribute
    public var networkState: UInt16

    @ReadWriteAttribute
    public var preload: String

    @ReadonlyAttribute
    public var buffered: TimeRanges

    @inlinable public func load() {
        let this = jsObject
        _ = this[.load].function!(this: this, arguments: [])
    }

    @inlinable public func canPlayType(type: String) -> CanPlayTypeResult {
        let this = jsObject
        return this[.canPlayType].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    public static let HAVE_NOTHING: UInt16 = 0

    public static let HAVE_METADATA: UInt16 = 1

    public static let HAVE_CURRENT_DATA: UInt16 = 2

    public static let HAVE_FUTURE_DATA: UInt16 = 3

    public static let HAVE_ENOUGH_DATA: UInt16 = 4

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var seeking: Bool

    @ReadWriteAttribute
    public var currentTime: Double

    @inlinable public func fastSeek(time: Double) {
        let this = jsObject
        _ = this[.fastSeek].function!(this: this, arguments: [_toJSValue(time)])
    }

    @ReadonlyAttribute
    public var duration: Double

    @inlinable public func getStartDate() -> JSObject {
        let this = jsObject
        return this[.getStartDate].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var paused: Bool

    @ReadWriteAttribute
    public var defaultPlaybackRate: Double

    @ReadWriteAttribute
    public var playbackRate: Double

    @ReadWriteAttribute
    public var preservesPitch: Bool

    @ReadonlyAttribute
    public var played: TimeRanges

    @ReadonlyAttribute
    public var seekable: TimeRanges

    @ReadonlyAttribute
    public var ended: Bool

    @ReadWriteAttribute
    public var autoplay: Bool

    @ReadWriteAttribute
    public var loop: Bool

    @inlinable public func play() -> JSPromise {
        let this = jsObject
        return this[.play].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func play() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.play].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func pause() {
        let this = jsObject
        _ = this[.pause].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var controls: Bool

    @ReadWriteAttribute
    public var volume: Double

    @ReadWriteAttribute
    public var muted: Bool

    @ReadWriteAttribute
    public var defaultMuted: Bool

    @ReadonlyAttribute
    public var audioTracks: AudioTrackList

    @ReadonlyAttribute
    public var videoTracks: VideoTrackList

    @ReadonlyAttribute
    public var textTracks: TextTrackList

    @inlinable public func addTextTrack(kind: TextTrackKind, label: String? = nil, language: String? = nil) -> TextTrack {
        let this = jsObject
        return this[.addTextTrack].function!(this: this, arguments: [_toJSValue(kind), _toJSValue(label), _toJSValue(language)]).fromJSValue()!
    }
}

public class HTMLMenuElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLMenuElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: .compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLMetaElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLMetaElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _httpEquiv = ReadWriteAttribute(jsObject: jsObject, name: .httpEquiv)
        _content = ReadWriteAttribute(jsObject: jsObject, name: .content)
        _media = ReadWriteAttribute(jsObject: jsObject, name: .media)
        _scheme = ReadWriteAttribute(jsObject: jsObject, name: .scheme)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var httpEquiv: String

    @ReadWriteAttribute
    public var content: String

    @ReadWriteAttribute
    public var media: String

    @ReadWriteAttribute
    public var scheme: String
}

public class HTMLMeterElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLMeterElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        _min = ReadWriteAttribute(jsObject: jsObject, name: .min)
        _max = ReadWriteAttribute(jsObject: jsObject, name: .max)
        _low = ReadWriteAttribute(jsObject: jsObject, name: .low)
        _high = ReadWriteAttribute(jsObject: jsObject, name: .high)
        _optimum = ReadWriteAttribute(jsObject: jsObject, name: .optimum)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: .labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: Double

    @ReadWriteAttribute
    public var min: Double

    @ReadWriteAttribute
    public var max: Double

    @ReadWriteAttribute
    public var low: Double

    @ReadWriteAttribute
    public var high: Double

    @ReadWriteAttribute
    public var optimum: Double

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLModElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLModElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _cite = ReadWriteAttribute(jsObject: jsObject, name: .cite)
        _dateTime = ReadWriteAttribute(jsObject: jsObject, name: .dateTime)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var cite: String

    @ReadWriteAttribute
    public var dateTime: String
}

public class HTMLOListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLOListElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _reversed = ReadWriteAttribute(jsObject: jsObject, name: .reversed)
        _start = ReadWriteAttribute(jsObject: jsObject, name: .start)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        _compact = ReadWriteAttribute(jsObject: jsObject, name: .compact)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var reversed: Bool

    @ReadWriteAttribute
    public var start: Int32

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var compact: Bool
}

public class HTMLObjectElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLObjectElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadWriteAttribute(jsObject: jsObject, name: .data)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _form = ReadonlyAttribute(jsObject: jsObject, name: .form)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        _contentDocument = ReadonlyAttribute(jsObject: jsObject, name: .contentDocument)
        _contentWindow = ReadonlyAttribute(jsObject: jsObject, name: .contentWindow)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: .willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: .validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: .validationMessage)
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        _archive = ReadWriteAttribute(jsObject: jsObject, name: .archive)
        _code = ReadWriteAttribute(jsObject: jsObject, name: .code)
        _declare = ReadWriteAttribute(jsObject: jsObject, name: .declare)
        _hspace = ReadWriteAttribute(jsObject: jsObject, name: .hspace)
        _standby = ReadWriteAttribute(jsObject: jsObject, name: .standby)
        _vspace = ReadWriteAttribute(jsObject: jsObject, name: .vspace)
        _codeBase = ReadWriteAttribute(jsObject: jsObject, name: .codeBase)
        _codeType = ReadWriteAttribute(jsObject: jsObject, name: .codeType)
        _useMap = ReadWriteAttribute(jsObject: jsObject, name: .useMap)
        _border = ReadWriteAttribute(jsObject: jsObject, name: .border)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var data: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var height: String

    @ReadonlyAttribute
    public var contentDocument: Document?

    @ReadonlyAttribute
    public var contentWindow: WindowProxy?

    @inlinable public func getSVGDocument() -> Document? {
        let this = jsObject
        return this[.getSVGDocument].function!(this: this, arguments: []).fromJSValue()
    }

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var archive: String

    @ReadWriteAttribute
    public var code: String

    @ReadWriteAttribute
    public var declare: Bool

    @ReadWriteAttribute
    public var hspace: UInt32

    @ReadWriteAttribute
    public var standby: String

    @ReadWriteAttribute
    public var vspace: UInt32

    @ReadWriteAttribute
    public var codeBase: String

    @ReadWriteAttribute
    public var codeType: String

    @ReadWriteAttribute
    public var useMap: String

    @ReadWriteAttribute
    public var border: String
}

public class HTMLOptGroupElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLOptGroupElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: .disabled)
        _label = ReadWriteAttribute(jsObject: jsObject, name: .label)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadWriteAttribute
    public var label: String
}

public class HTMLOptionElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLOptionElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: .disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: .form)
        _label = ReadWriteAttribute(jsObject: jsObject, name: .label)
        _defaultSelected = ReadWriteAttribute(jsObject: jsObject, name: .defaultSelected)
        _selected = ReadWriteAttribute(jsObject: jsObject, name: .selected)
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        _text = ReadWriteAttribute(jsObject: jsObject, name: .text)
        _index = ReadonlyAttribute(jsObject: jsObject, name: .index)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var label: String

    @ReadWriteAttribute
    public var defaultSelected: Bool

    @ReadWriteAttribute
    public var selected: Bool

    @ReadWriteAttribute
    public var value: String

    @ReadWriteAttribute
    public var text: String

    @ReadonlyAttribute
    public var index: Int32
}

public class HTMLOptionsCollection: HTMLCollection {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLOptionsCollection].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadWriteAttribute(jsObject: jsObject, name: .length)
        _selectedIndex = ReadWriteAttribute(jsObject: jsObject, name: .selectedIndex)
        super.init(unsafelyWrapping: jsObject)
    }

    @usableFromInline let _length: ReadWriteAttribute<UInt32>
    @inlinable override public var length: UInt32 {
        get { _length.wrappedValue }
        set { _length.wrappedValue = newValue }
    }

    @inlinable override public subscript(key: Int) -> HTMLOptionElement? {
        get {
            super[key] as? HTMLOptionElement
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }

    @inlinable public func add(element: HTMLOptGroupElement_or_HTMLOptionElement, before: HTMLElement_or_Int32? = nil) {
        let this = jsObject
        _ = this[.add].function!(this: this, arguments: [_toJSValue(element), _toJSValue(before)])
    }

    @inlinable public func remove(index: Int32) {
        let this = jsObject
        _ = this[.remove].function!(this: this, arguments: [_toJSValue(index)])
    }

    @ReadWriteAttribute
    public var selectedIndex: Int32
}

public protocol HTMLOrSVGElement: JSBridgedClass {}
public extension HTMLOrSVGElement {
    @inlinable var dataset: DOMStringMap { jsObject[.dataset].fromJSValue()! }

    @inlinable var nonce: String {
        get { jsObject[.nonce].fromJSValue()! }
        nonmutating set { jsObject[.nonce] = _toJSValue(newValue) }
    }

    @inlinable var autofocus: Bool {
        get { jsObject[.autofocus].fromJSValue()! }
        nonmutating set { jsObject[.autofocus] = _toJSValue(newValue) }
    }

    @inlinable var tabIndex: Int32 {
        get { jsObject[.tabIndex].fromJSValue()! }
        nonmutating set { jsObject[.tabIndex] = _toJSValue(newValue) }
    }

    @inlinable func focus(options: FocusOptions? = nil) {
        let this = jsObject
        _ = this[.focus].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable func blur() {
        let this = jsObject
        _ = this[.blur].function!(this: this, arguments: [])
    }
}

public class HTMLOutputElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLOutputElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _htmlFor = ReadonlyAttribute(jsObject: jsObject, name: .htmlFor)
        _form = ReadonlyAttribute(jsObject: jsObject, name: .form)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _defaultValue = ReadWriteAttribute(jsObject: jsObject, name: .defaultValue)
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: .willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: .validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: .validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: .labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var htmlFor: DOMTokenList

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var name: String

    @ReadonlyAttribute
    public var type: String

    @ReadWriteAttribute
    public var defaultValue: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLParagraphElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLParagraphElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLParamElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLParamElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        _valueType = ReadWriteAttribute(jsObject: jsObject, name: .valueType)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var value: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var valueType: String
}

public class HTMLPictureElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLPictureElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }
}

public class HTMLPreElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLPreElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var width: Int32
}

public class HTMLProgressElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLProgressElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        _max = ReadWriteAttribute(jsObject: jsObject, name: .max)
        _position = ReadonlyAttribute(jsObject: jsObject, name: .position)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: .labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var value: Double

    @ReadWriteAttribute
    public var max: Double

    @ReadonlyAttribute
    public var position: Double

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLQuoteElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLQuoteElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _cite = ReadWriteAttribute(jsObject: jsObject, name: .cite)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var cite: String
}

public class HTMLScriptElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLScriptElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: .src)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        _noModule = ReadWriteAttribute(jsObject: jsObject, name: .noModule)
        _async = ReadWriteAttribute(jsObject: jsObject, name: .async)
        _defer = ReadWriteAttribute(jsObject: jsObject, name: .defer)
        _crossOrigin = ReadWriteAttribute(jsObject: jsObject, name: .crossOrigin)
        _text = ReadWriteAttribute(jsObject: jsObject, name: .text)
        _integrity = ReadWriteAttribute(jsObject: jsObject, name: .integrity)
        _referrerPolicy = ReadWriteAttribute(jsObject: jsObject, name: .referrerPolicy)
        _blocking = ReadonlyAttribute(jsObject: jsObject, name: .blocking)
        _fetchPriority = ReadWriteAttribute(jsObject: jsObject, name: .fetchPriority)
        _charset = ReadWriteAttribute(jsObject: jsObject, name: .charset)
        _event = ReadWriteAttribute(jsObject: jsObject, name: .event)
        _htmlFor = ReadWriteAttribute(jsObject: jsObject, name: .htmlFor)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var noModule: Bool

    @ReadWriteAttribute
    public var async: Bool

    @ReadWriteAttribute
    public var `defer`: Bool

    @ReadWriteAttribute
    public var crossOrigin: String?

    @ReadWriteAttribute
    public var text: String

    @ReadWriteAttribute
    public var integrity: String

    @ReadWriteAttribute
    public var referrerPolicy: String

    @ReadonlyAttribute
    public var blocking: DOMTokenList

    @ReadWriteAttribute
    public var fetchPriority: String

    @inlinable public class func supports(type: String) -> Bool {
        let this = constructor!
        return this[.supports].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    @ReadWriteAttribute
    public var charset: String

    @ReadWriteAttribute
    public var event: String

    @ReadWriteAttribute
    public var htmlFor: String
}

public class HTMLSelectElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLSelectElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: .autocomplete)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: .disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: .form)
        _multiple = ReadWriteAttribute(jsObject: jsObject, name: .multiple)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _required = ReadWriteAttribute(jsObject: jsObject, name: .required)
        _size = ReadWriteAttribute(jsObject: jsObject, name: .size)
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _options = ReadonlyAttribute(jsObject: jsObject, name: .options)
        _length = ReadWriteAttribute(jsObject: jsObject, name: .length)
        _selectedOptions = ReadonlyAttribute(jsObject: jsObject, name: .selectedOptions)
        _selectedIndex = ReadWriteAttribute(jsObject: jsObject, name: .selectedIndex)
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: .willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: .validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: .validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: .labels)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var multiple: Bool

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var required: Bool

    @ReadWriteAttribute
    public var size: UInt32

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var options: HTMLOptionsCollection

    @ReadWriteAttribute
    public var length: UInt32

    @inlinable public func item(index: UInt32) -> HTMLOptionElement? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public func namedItem(name: String) -> HTMLOptionElement? {
        let this = jsObject
        return this[.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }

    @inlinable public func add(element: HTMLOptGroupElement_or_HTMLOptionElement, before: HTMLElement_or_Int32? = nil) {
        let this = jsObject
        _ = this[.add].function!(this: this, arguments: [_toJSValue(element), _toJSValue(before)])
    }

    @inlinable public func remove() {
        let this = jsObject
        _ = this[.remove].function!(this: this, arguments: [])
    }

    @inlinable public func remove(index: Int32) {
        let this = jsObject
        _ = this[.remove].function!(this: this, arguments: [_toJSValue(index)])
    }

    @inlinable public subscript(key: Int) -> HTMLOptionElement? {
        get {
            jsObject[key].fromJSValue()
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }

    @ReadonlyAttribute
    public var selectedOptions: HTMLCollection

    @ReadWriteAttribute
    public var selectedIndex: Int32

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @ReadonlyAttribute
    public var labels: NodeList
}

public class HTMLSlotElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLSlotElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var name: String

    @inlinable public func assignedNodes(options: AssignedNodesOptions? = nil) -> [Node] {
        let this = jsObject
        return this[.assignedNodes].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func assignedElements(options: AssignedNodesOptions? = nil) -> [Element] {
        let this = jsObject
        return this[.assignedElements].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func assign(nodes: Element_or_Text...) {
        let this = jsObject
        _ = this[.assign].function!(this: this, arguments: nodes.map(_toJSValue))
    }
}

public class HTMLSourceElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLSourceElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _src = ReadWriteAttribute(jsObject: jsObject, name: .src)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        _srcset = ReadWriteAttribute(jsObject: jsObject, name: .srcset)
        _sizes = ReadWriteAttribute(jsObject: jsObject, name: .sizes)
        _media = ReadWriteAttribute(jsObject: jsObject, name: .media)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var srcset: String

    @ReadWriteAttribute
    public var sizes: String

    @ReadWriteAttribute
    public var media: String

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32
}

public class HTMLSpanElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLSpanElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }
}

public class HTMLStyleElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLStyleElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: .disabled)
        _media = ReadWriteAttribute(jsObject: jsObject, name: .media)
        _blocking = ReadonlyAttribute(jsObject: jsObject, name: .blocking)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadWriteAttribute
    public var media: String

    @ReadonlyAttribute
    public var blocking: DOMTokenList

    @ReadWriteAttribute
    public var type: String
}

public class HTMLTableCaptionElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLTableCaptionElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var align: String
}

public class HTMLTableCellElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLTableCellElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _colSpan = ReadWriteAttribute(jsObject: jsObject, name: .colSpan)
        _rowSpan = ReadWriteAttribute(jsObject: jsObject, name: .rowSpan)
        _headers = ReadWriteAttribute(jsObject: jsObject, name: .headers)
        _cellIndex = ReadonlyAttribute(jsObject: jsObject, name: .cellIndex)
        _scope = ReadWriteAttribute(jsObject: jsObject, name: .scope)
        _abbr = ReadWriteAttribute(jsObject: jsObject, name: .abbr)
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        _axis = ReadWriteAttribute(jsObject: jsObject, name: .axis)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: .ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: .chOff)
        _noWrap = ReadWriteAttribute(jsObject: jsObject, name: .noWrap)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: .vAlign)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: .bgColor)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var colSpan: UInt32

    @ReadWriteAttribute
    public var rowSpan: UInt32

    @ReadWriteAttribute
    public var headers: String

    @ReadonlyAttribute
    public var cellIndex: Int32

    @ReadWriteAttribute
    public var scope: String

    @ReadWriteAttribute
    public var abbr: String

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var axis: String

    @ReadWriteAttribute
    public var height: String

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var noWrap: Bool

    @ReadWriteAttribute
    public var vAlign: String

    @ReadWriteAttribute
    public var bgColor: String
}

public class HTMLTableColElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLTableColElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _span = ReadWriteAttribute(jsObject: jsObject, name: .span)
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: .ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: .chOff)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: .vAlign)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var span: UInt32

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var vAlign: String

    @ReadWriteAttribute
    public var width: String
}

public class HTMLTableElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLTableElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _caption = ReadWriteAttribute(jsObject: jsObject, name: .caption)
        _tHead = ReadWriteAttribute(jsObject: jsObject, name: .tHead)
        _tFoot = ReadWriteAttribute(jsObject: jsObject, name: .tFoot)
        _tBodies = ReadonlyAttribute(jsObject: jsObject, name: .tBodies)
        _rows = ReadonlyAttribute(jsObject: jsObject, name: .rows)
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        _border = ReadWriteAttribute(jsObject: jsObject, name: .border)
        _frame = ReadWriteAttribute(jsObject: jsObject, name: .frame)
        _rules = ReadWriteAttribute(jsObject: jsObject, name: .rules)
        _summary = ReadWriteAttribute(jsObject: jsObject, name: .summary)
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: .bgColor)
        _cellPadding = ReadWriteAttribute(jsObject: jsObject, name: .cellPadding)
        _cellSpacing = ReadWriteAttribute(jsObject: jsObject, name: .cellSpacing)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var caption: HTMLTableCaptionElement?

    @inlinable public func createCaption() -> HTMLTableCaptionElement {
        let this = jsObject
        return this[.createCaption].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func deleteCaption() {
        let this = jsObject
        _ = this[.deleteCaption].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var tHead: HTMLTableSectionElement?

    @inlinable public func createTHead() -> HTMLTableSectionElement {
        let this = jsObject
        return this[.createTHead].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func deleteTHead() {
        let this = jsObject
        _ = this[.deleteTHead].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var tFoot: HTMLTableSectionElement?

    @inlinable public func createTFoot() -> HTMLTableSectionElement {
        let this = jsObject
        return this[.createTFoot].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func deleteTFoot() {
        let this = jsObject
        _ = this[.deleteTFoot].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var tBodies: HTMLCollection

    @inlinable public func createTBody() -> HTMLTableSectionElement {
        let this = jsObject
        return this[.createTBody].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var rows: HTMLCollection

    @inlinable public func insertRow(index: Int32? = nil) -> HTMLTableRowElement {
        let this = jsObject
        return this[.insertRow].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }

    @inlinable public func deleteRow(index: Int32) {
        let this = jsObject
        _ = this[.deleteRow].function!(this: this, arguments: [_toJSValue(index)])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var border: String

    @ReadWriteAttribute
    public var frame: String

    @ReadWriteAttribute
    public var rules: String

    @ReadWriteAttribute
    public var summary: String

    @ReadWriteAttribute
    public var width: String

    @ReadWriteAttribute
    public var bgColor: String

    @ReadWriteAttribute
    public var cellPadding: String

    @ReadWriteAttribute
    public var cellSpacing: String
}

public class HTMLTableRowElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLTableRowElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _rowIndex = ReadonlyAttribute(jsObject: jsObject, name: .rowIndex)
        _sectionRowIndex = ReadonlyAttribute(jsObject: jsObject, name: .sectionRowIndex)
        _cells = ReadonlyAttribute(jsObject: jsObject, name: .cells)
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: .ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: .chOff)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: .vAlign)
        _bgColor = ReadWriteAttribute(jsObject: jsObject, name: .bgColor)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var rowIndex: Int32

    @ReadonlyAttribute
    public var sectionRowIndex: Int32

    @ReadonlyAttribute
    public var cells: HTMLCollection

    @inlinable public func insertCell(index: Int32? = nil) -> HTMLTableCellElement {
        let this = jsObject
        return this[.insertCell].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }

    @inlinable public func deleteCell(index: Int32) {
        let this = jsObject
        _ = this[.deleteCell].function!(this: this, arguments: [_toJSValue(index)])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var vAlign: String

    @ReadWriteAttribute
    public var bgColor: String
}

public class HTMLTableSectionElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLTableSectionElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _rows = ReadonlyAttribute(jsObject: jsObject, name: .rows)
        _align = ReadWriteAttribute(jsObject: jsObject, name: .align)
        _ch = ReadWriteAttribute(jsObject: jsObject, name: .ch)
        _chOff = ReadWriteAttribute(jsObject: jsObject, name: .chOff)
        _vAlign = ReadWriteAttribute(jsObject: jsObject, name: .vAlign)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var rows: HTMLCollection

    @inlinable public func insertRow(index: Int32? = nil) -> HTMLTableRowElement {
        let this = jsObject
        return this[.insertRow].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }

    @inlinable public func deleteRow(index: Int32) {
        let this = jsObject
        _ = this[.deleteRow].function!(this: this, arguments: [_toJSValue(index)])
    }

    @ReadWriteAttribute
    public var align: String

    @ReadWriteAttribute
    public var ch: String

    @ReadWriteAttribute
    public var chOff: String

    @ReadWriteAttribute
    public var vAlign: String
}

public class HTMLTemplateElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLTemplateElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _content = ReadonlyAttribute(jsObject: jsObject, name: .content)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var content: DocumentFragment
}

public class HTMLTextAreaElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLTextAreaElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _autocomplete = ReadWriteAttribute(jsObject: jsObject, name: .autocomplete)
        _cols = ReadWriteAttribute(jsObject: jsObject, name: .cols)
        _dirName = ReadWriteAttribute(jsObject: jsObject, name: .dirName)
        _disabled = ReadWriteAttribute(jsObject: jsObject, name: .disabled)
        _form = ReadonlyAttribute(jsObject: jsObject, name: .form)
        _maxLength = ReadWriteAttribute(jsObject: jsObject, name: .maxLength)
        _minLength = ReadWriteAttribute(jsObject: jsObject, name: .minLength)
        _name = ReadWriteAttribute(jsObject: jsObject, name: .name)
        _placeholder = ReadWriteAttribute(jsObject: jsObject, name: .placeholder)
        _readOnly = ReadWriteAttribute(jsObject: jsObject, name: .readOnly)
        _required = ReadWriteAttribute(jsObject: jsObject, name: .required)
        _rows = ReadWriteAttribute(jsObject: jsObject, name: .rows)
        _wrap = ReadWriteAttribute(jsObject: jsObject, name: .wrap)
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _defaultValue = ReadWriteAttribute(jsObject: jsObject, name: .defaultValue)
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        _textLength = ReadonlyAttribute(jsObject: jsObject, name: .textLength)
        _willValidate = ReadonlyAttribute(jsObject: jsObject, name: .willValidate)
        _validity = ReadonlyAttribute(jsObject: jsObject, name: .validity)
        _validationMessage = ReadonlyAttribute(jsObject: jsObject, name: .validationMessage)
        _labels = ReadonlyAttribute(jsObject: jsObject, name: .labels)
        _selectionStart = ReadWriteAttribute(jsObject: jsObject, name: .selectionStart)
        _selectionEnd = ReadWriteAttribute(jsObject: jsObject, name: .selectionEnd)
        _selectionDirection = ReadWriteAttribute(jsObject: jsObject, name: .selectionDirection)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var autocomplete: String

    @ReadWriteAttribute
    public var cols: UInt32

    @ReadWriteAttribute
    public var dirName: String

    @ReadWriteAttribute
    public var disabled: Bool

    @ReadonlyAttribute
    public var form: HTMLFormElement?

    @ReadWriteAttribute
    public var maxLength: Int32

    @ReadWriteAttribute
    public var minLength: Int32

    @ReadWriteAttribute
    public var name: String

    @ReadWriteAttribute
    public var placeholder: String

    @ReadWriteAttribute
    public var readOnly: Bool

    @ReadWriteAttribute
    public var required: Bool

    @ReadWriteAttribute
    public var rows: UInt32

    @ReadWriteAttribute
    public var wrap: String

    @ReadonlyAttribute
    public var type: String

    @ReadWriteAttribute
    public var defaultValue: String

    @ReadWriteAttribute
    public var value: String

    @ReadonlyAttribute
    public var textLength: UInt32

    @ReadonlyAttribute
    public var willValidate: Bool

    @ReadonlyAttribute
    public var validity: ValidityState

    @ReadonlyAttribute
    public var validationMessage: String

    @inlinable public func checkValidity() -> Bool {
        let this = jsObject
        return this[.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func reportValidity() -> Bool {
        let this = jsObject
        return this[.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func setCustomValidity(error: String) {
        let this = jsObject
        _ = this[.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @ReadonlyAttribute
    public var labels: NodeList

    @inlinable public func select() {
        let this = jsObject
        _ = this[.select].function!(this: this, arguments: [])
    }

    @ReadWriteAttribute
    public var selectionStart: UInt32

    @ReadWriteAttribute
    public var selectionEnd: UInt32

    @ReadWriteAttribute
    public var selectionDirection: String

    @inlinable public func setRangeText(replacement: String) {
        let this = jsObject
        _ = this[.setRangeText].function!(this: this, arguments: [_toJSValue(replacement)])
    }

    @inlinable public func setRangeText(replacement: String, start: UInt32, end: UInt32, selectionMode: SelectionMode? = nil) {
        let this = jsObject
        _ = this[.setRangeText].function!(this: this, arguments: [_toJSValue(replacement), _toJSValue(start), _toJSValue(end), _toJSValue(selectionMode)])
    }

    @inlinable public func setSelectionRange(start: UInt32, end: UInt32, direction: String? = nil) {
        let this = jsObject
        _ = this[.setSelectionRange].function!(this: this, arguments: [_toJSValue(start), _toJSValue(end), _toJSValue(direction)])
    }
}

public class HTMLTimeElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLTimeElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _dateTime = ReadWriteAttribute(jsObject: jsObject, name: .dateTime)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var dateTime: String
}

public class HTMLTitleElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLTitleElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _text = ReadWriteAttribute(jsObject: jsObject, name: .text)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var text: String
}

public class HTMLTrackElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLTrackElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadWriteAttribute(jsObject: jsObject, name: .kind)
        _src = ReadWriteAttribute(jsObject: jsObject, name: .src)
        _srclang = ReadWriteAttribute(jsObject: jsObject, name: .srclang)
        _label = ReadWriteAttribute(jsObject: jsObject, name: .label)
        _default = ReadWriteAttribute(jsObject: jsObject, name: .default)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: .readyState)
        _track = ReadonlyAttribute(jsObject: jsObject, name: .track)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var kind: String

    @ReadWriteAttribute
    public var src: String

    @ReadWriteAttribute
    public var srclang: String

    @ReadWriteAttribute
    public var label: String

    @ReadWriteAttribute
    public var `default`: Bool

    public static let NONE: UInt16 = 0

    public static let LOADING: UInt16 = 1

    public static let LOADED: UInt16 = 2

    public static let ERROR: UInt16 = 3

    @ReadonlyAttribute
    public var readyState: UInt16

    @ReadonlyAttribute
    public var track: TextTrack
}

public class HTMLUListElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLUListElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _compact = ReadWriteAttribute(jsObject: jsObject, name: .compact)
        _type = ReadWriteAttribute(jsObject: jsObject, name: .type)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var compact: Bool

    @ReadWriteAttribute
    public var type: String
}

public class HTMLUnknownElement: HTMLElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLUnknownElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class HTMLVideoElement: HTMLMediaElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HTMLVideoElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        _videoWidth = ReadonlyAttribute(jsObject: jsObject, name: .videoWidth)
        _videoHeight = ReadonlyAttribute(jsObject: jsObject, name: .videoHeight)
        _poster = ReadWriteAttribute(jsObject: jsObject, name: .poster)
        _playsInline = ReadWriteAttribute(jsObject: jsObject, name: .playsInline)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    @ReadonlyAttribute
    public var videoWidth: UInt32

    @ReadonlyAttribute
    public var videoHeight: UInt32

    @ReadWriteAttribute
    public var poster: String

    @ReadWriteAttribute
    public var playsInline: Bool
}

public enum HardwareAcceleration: JSString, JSValueCompatible {
    case noPreference = "no-preference"
    case preferHardware = "prefer-hardware"
    case preferSoftware = "prefer-software"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class HashChangeEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.HashChangeEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _oldURL = ReadonlyAttribute(jsObject: jsObject, name: .oldURL)
        _newURL = ReadonlyAttribute(jsObject: jsObject, name: .newURL)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: HashChangeEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var oldURL: String

    @ReadonlyAttribute
    public var newURL: String
}

public class HashChangeEventInit: BridgedDictionary {
    public convenience init(oldURL: String, newURL: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.oldURL] = _toJSValue(oldURL)
        object[.newURL] = _toJSValue(newURL)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _oldURL = ReadWriteAttribute(jsObject: object, name: .oldURL)
        _newURL = ReadWriteAttribute(jsObject: object, name: .newURL)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var oldURL: String

    @ReadWriteAttribute
    public var newURL: String
}

public class Headers: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Headers].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: HeadersInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public func append(name: String, value: String) {
        let this = jsObject
        _ = this[.append].function!(this: this, arguments: [_toJSValue(name), _toJSValue(value)])
    }

    @inlinable public func delete(name: String) {
        let this = jsObject
        _ = this[.delete].function!(this: this, arguments: [_toJSValue(name)])
    }

    @inlinable public func get(name: String) -> String? {
        let this = jsObject
        return this[.get].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }

    @inlinable public func getSetCookie() -> [String] {
        let this = jsObject
        return this[.getSetCookie].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func has(name: String) -> Bool {
        let this = jsObject
        return this[.has].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()!
    }

    @inlinable public func set(name: String, value: String) {
        let this = jsObject
        _ = this[.set].function!(this: this, arguments: [_toJSValue(name), _toJSValue(value)])
    }

    public typealias Element = String
    public func makeIterator() -> ValueIterableIterator<Headers> {
        ValueIterableIterator(sequence: self)
    }
}

public class History: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.History].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        _scrollRestoration = ReadWriteAttribute(jsObject: jsObject, name: .scrollRestoration)
        _state = ReadonlyAttribute(jsObject: jsObject, name: .state)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @ReadWriteAttribute
    public var scrollRestoration: ScrollRestoration

    @ReadonlyAttribute
    public var state: JSValue

    @inlinable public func go(delta: Int32? = nil) {
        let this = jsObject
        _ = this[.go].function!(this: this, arguments: [_toJSValue(delta)])
    }

    @inlinable public func back() {
        let this = jsObject
        _ = this[.back].function!(this: this, arguments: [])
    }

    @inlinable public func forward() {
        let this = jsObject
        _ = this[.forward].function!(this: this, arguments: [])
    }

    @inlinable public func pushState(data: JSValue, unused: String, url: String? = nil) {
        let this = jsObject
        _ = this[.pushState].function!(this: this, arguments: [_toJSValue(data), _toJSValue(unused), _toJSValue(url)])
    }

    @inlinable public func replaceState(data: JSValue, unused: String, url: String? = nil) {
        let this = jsObject
        _ = this[.replaceState].function!(this: this, arguments: [_toJSValue(data), _toJSValue(unused), _toJSValue(url)])
    }
}

public class ImageBitmap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ImageBitmap].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadonlyAttribute(jsObject: jsObject, name: .width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: .height)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var width: UInt32

    @ReadonlyAttribute
    public var height: UInt32

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }
}

public class ImageBitmapOptions: BridgedDictionary {
    public convenience init(imageOrientation: ImageOrientation, premultiplyAlpha: PremultiplyAlpha, colorSpaceConversion: ColorSpaceConversion, resizeWidth: UInt32, resizeHeight: UInt32, resizeQuality: ResizeQuality) {
        let object = JSObject.global[.Object].function!.new()
        object[.imageOrientation] = _toJSValue(imageOrientation)
        object[.premultiplyAlpha] = _toJSValue(premultiplyAlpha)
        object[.colorSpaceConversion] = _toJSValue(colorSpaceConversion)
        object[.resizeWidth] = _toJSValue(resizeWidth)
        object[.resizeHeight] = _toJSValue(resizeHeight)
        object[.resizeQuality] = _toJSValue(resizeQuality)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _imageOrientation = ReadWriteAttribute(jsObject: object, name: .imageOrientation)
        _premultiplyAlpha = ReadWriteAttribute(jsObject: object, name: .premultiplyAlpha)
        _colorSpaceConversion = ReadWriteAttribute(jsObject: object, name: .colorSpaceConversion)
        _resizeWidth = ReadWriteAttribute(jsObject: object, name: .resizeWidth)
        _resizeHeight = ReadWriteAttribute(jsObject: object, name: .resizeHeight)
        _resizeQuality = ReadWriteAttribute(jsObject: object, name: .resizeQuality)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var imageOrientation: ImageOrientation

    @ReadWriteAttribute
    public var premultiplyAlpha: PremultiplyAlpha

    @ReadWriteAttribute
    public var colorSpaceConversion: ColorSpaceConversion

    @ReadWriteAttribute
    public var resizeWidth: UInt32

    @ReadWriteAttribute
    public var resizeHeight: UInt32

    @ReadWriteAttribute
    public var resizeQuality: ResizeQuality
}

public class ImageBitmapRenderingContext: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ImageBitmapRenderingContext].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _canvas = ReadonlyAttribute(jsObject: jsObject, name: .canvas)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var canvas: HTMLCanvasElement_or_OffscreenCanvas

    @inlinable public func transferFromImageBitmap(bitmap: ImageBitmap?) {
        let this = jsObject
        _ = this[.transferFromImageBitmap].function!(this: this, arguments: [_toJSValue(bitmap)])
    }
}

public class ImageBitmapRenderingContextSettings: BridgedDictionary {
    public convenience init(alpha: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.alpha] = _toJSValue(alpha)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _alpha = ReadWriteAttribute(jsObject: object, name: .alpha)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var alpha: Bool
}

public class ImageData: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ImageData].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadonlyAttribute(jsObject: jsObject, name: .width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: .height)
        _data = ReadonlyAttribute(jsObject: jsObject, name: .data)
        _colorSpace = ReadonlyAttribute(jsObject: jsObject, name: .colorSpace)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(sw: UInt32, sh: UInt32, settings: ImageDataSettings? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(sw), _toJSValue(sh), _toJSValue(settings)]))
    }

    @inlinable public convenience init(data: Uint8ClampedArray, sw: UInt32, sh: UInt32? = nil, settings: ImageDataSettings? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(data), _toJSValue(sw), _toJSValue(sh), _toJSValue(settings)]))
    }

    @ReadonlyAttribute
    public var width: UInt32

    @ReadonlyAttribute
    public var height: UInt32

    @ReadonlyAttribute
    public var data: Uint8ClampedArray

    @ReadonlyAttribute
    public var colorSpace: PredefinedColorSpace
}

public class ImageDataSettings: BridgedDictionary {
    public convenience init(colorSpace: PredefinedColorSpace) {
        let object = JSObject.global[.Object].function!.new()
        object[.colorSpace] = _toJSValue(colorSpace)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorSpace = ReadWriteAttribute(jsObject: object, name: .colorSpace)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace
}

public class ImageDecodeOptions: BridgedDictionary {
    public convenience init(frameIndex: UInt32, completeFramesOnly: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.frameIndex] = _toJSValue(frameIndex)
        object[.completeFramesOnly] = _toJSValue(completeFramesOnly)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _frameIndex = ReadWriteAttribute(jsObject: object, name: .frameIndex)
        _completeFramesOnly = ReadWriteAttribute(jsObject: object, name: .completeFramesOnly)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var frameIndex: UInt32

    @ReadWriteAttribute
    public var completeFramesOnly: Bool
}

public class ImageDecodeResult: BridgedDictionary {
    public convenience init(image: VideoFrame, complete: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.image] = _toJSValue(image)
        object[.complete] = _toJSValue(complete)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _image = ReadWriteAttribute(jsObject: object, name: .image)
        _complete = ReadWriteAttribute(jsObject: object, name: .complete)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var image: VideoFrame

    @ReadWriteAttribute
    public var complete: Bool
}

public class ImageDecoder: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ImageDecoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _complete = ReadonlyAttribute(jsObject: jsObject, name: .complete)
        _completed = ReadonlyAttribute(jsObject: jsObject, name: .completed)
        _tracks = ReadonlyAttribute(jsObject: jsObject, name: .tracks)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: ImageDecoderInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var complete: Bool

    @ReadonlyAttribute
    public var completed: JSPromise

    @ReadonlyAttribute
    public var tracks: ImageTrackList

    @inlinable public func decode(options: ImageDecodeOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.decode].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func decode(options: ImageDecodeOptions? = nil) async throws -> ImageDecodeResult {
        let this = jsObject
        let _promise: JSPromise = this[.decode].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[.reset].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }

    @inlinable public class func isTypeSupported(type: String) -> JSPromise {
        let this = constructor!
        return this[.isTypeSupported].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public class func isTypeSupported(type: String) async throws -> Bool {
        let this = constructor!
        let _promise: JSPromise = this[.isTypeSupported].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class ImageDecoderInit: BridgedDictionary {
    public convenience init(type: String, data: ImageBufferSource, colorSpaceConversion: ColorSpaceConversion, desiredWidth: UInt32, desiredHeight: UInt32, preferAnimation: Bool, transfer: [ArrayBuffer]) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.data] = _toJSValue(data)
        object[.colorSpaceConversion] = _toJSValue(colorSpaceConversion)
        object[.desiredWidth] = _toJSValue(desiredWidth)
        object[.desiredHeight] = _toJSValue(desiredHeight)
        object[.preferAnimation] = _toJSValue(preferAnimation)
        object[.transfer] = _toJSValue(transfer)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        _data = ReadWriteAttribute(jsObject: object, name: .data)
        _colorSpaceConversion = ReadWriteAttribute(jsObject: object, name: .colorSpaceConversion)
        _desiredWidth = ReadWriteAttribute(jsObject: object, name: .desiredWidth)
        _desiredHeight = ReadWriteAttribute(jsObject: object, name: .desiredHeight)
        _preferAnimation = ReadWriteAttribute(jsObject: object, name: .preferAnimation)
        _transfer = ReadWriteAttribute(jsObject: object, name: .transfer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var data: ImageBufferSource

    @ReadWriteAttribute
    public var colorSpaceConversion: ColorSpaceConversion

    @ReadWriteAttribute
    public var desiredWidth: UInt32

    @ReadWriteAttribute
    public var desiredHeight: UInt32

    @ReadWriteAttribute
    public var preferAnimation: Bool

    @ReadWriteAttribute
    public var transfer: [ArrayBuffer]
}

public class ImageEncodeOptions: BridgedDictionary {
    public convenience init(type: String, quality: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.quality] = _toJSValue(quality)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        _quality = ReadWriteAttribute(jsObject: object, name: .quality)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var quality: Double
}

public enum ImageOrientation: JSString, JSValueCompatible {
    case fromImage = "from-image"
    case flipY = "flipY"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ImageSmoothingQuality: JSString, JSValueCompatible {
    case low = "low"
    case medium = "medium"
    case high = "high"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ImageTrack: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ImageTrack].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _animated = ReadonlyAttribute(jsObject: jsObject, name: .animated)
        _frameCount = ReadonlyAttribute(jsObject: jsObject, name: .frameCount)
        _repetitionCount = ReadonlyAttribute(jsObject: jsObject, name: .repetitionCount)
        _selected = ReadWriteAttribute(jsObject: jsObject, name: .selected)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var animated: Bool

    @ReadonlyAttribute
    public var frameCount: UInt32

    @ReadonlyAttribute
    public var repetitionCount: Float

    @ReadWriteAttribute
    public var selected: Bool
}

public class ImageTrackList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ImageTrackList].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _ready = ReadonlyAttribute(jsObject: jsObject, name: .ready)
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        _selectedIndex = ReadonlyAttribute(jsObject: jsObject, name: .selectedIndex)
        _selectedTrack = ReadonlyAttribute(jsObject: jsObject, name: .selectedTrack)
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: Int) -> ImageTrack {
        jsObject[key].fromJSValue()!
    }

    @ReadonlyAttribute
    public var ready: JSPromise

    @ReadonlyAttribute
    public var length: UInt32

    @ReadonlyAttribute
    public var selectedIndex: Int32

    @ReadonlyAttribute
    public var selectedTrack: ImageTrack?
}

public class InputDeviceInfo: MediaDeviceInfo {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.InputDeviceInfo].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func getCapabilities() -> MediaTrackCapabilities {
        let this = jsObject
        return this[.getCapabilities].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class InputEvent: UIEvent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.InputEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadonlyAttribute(jsObject: jsObject, name: .data)
        _isComposing = ReadonlyAttribute(jsObject: jsObject, name: .isComposing)
        _inputType = ReadonlyAttribute(jsObject: jsObject, name: .inputType)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: InputEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var data: String?

    @ReadonlyAttribute
    public var isComposing: Bool

    @ReadonlyAttribute
    public var inputType: String
}

public class InputEventInit: BridgedDictionary {
    public convenience init(data: String?, isComposing: Bool, inputType: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.data] = _toJSValue(data)
        object[.isComposing] = _toJSValue(isComposing)
        object[.inputType] = _toJSValue(inputType)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _data = ReadWriteAttribute(jsObject: object, name: .data)
        _isComposing = ReadWriteAttribute(jsObject: object, name: .isComposing)
        _inputType = ReadWriteAttribute(jsObject: object, name: .inputType)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var data: String?

    @ReadWriteAttribute
    public var isComposing: Bool

    @ReadWriteAttribute
    public var inputType: String
}

public class KeyboardEvent: UIEvent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.KeyboardEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _key = ReadonlyAttribute(jsObject: jsObject, name: .key)
        _code = ReadonlyAttribute(jsObject: jsObject, name: .code)
        _location = ReadonlyAttribute(jsObject: jsObject, name: .location)
        _ctrlKey = ReadonlyAttribute(jsObject: jsObject, name: .ctrlKey)
        _shiftKey = ReadonlyAttribute(jsObject: jsObject, name: .shiftKey)
        _altKey = ReadonlyAttribute(jsObject: jsObject, name: .altKey)
        _metaKey = ReadonlyAttribute(jsObject: jsObject, name: .metaKey)
        _repeat = ReadonlyAttribute(jsObject: jsObject, name: .repeat)
        _isComposing = ReadonlyAttribute(jsObject: jsObject, name: .isComposing)
        _charCode = ReadonlyAttribute(jsObject: jsObject, name: .charCode)
        _keyCode = ReadonlyAttribute(jsObject: jsObject, name: .keyCode)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: KeyboardEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    public static let DOM_KEY_LOCATION_STANDARD: UInt32 = 0x00

    public static let DOM_KEY_LOCATION_LEFT: UInt32 = 0x01

    public static let DOM_KEY_LOCATION_RIGHT: UInt32 = 0x02

    public static let DOM_KEY_LOCATION_NUMPAD: UInt32 = 0x03

    @ReadonlyAttribute
    public var key: String

    @ReadonlyAttribute
    public var code: String

    @ReadonlyAttribute
    public var location: UInt32

    @ReadonlyAttribute
    public var ctrlKey: Bool

    @ReadonlyAttribute
    public var shiftKey: Bool

    @ReadonlyAttribute
    public var altKey: Bool

    @ReadonlyAttribute
    public var metaKey: Bool

    @ReadonlyAttribute
    public var `repeat`: Bool

    @ReadonlyAttribute
    public var isComposing: Bool

    @inlinable public func getModifierState(keyArg: String) -> Bool {
        let this = jsObject
        return this[.getModifierState].function!(this: this, arguments: [_toJSValue(keyArg)]).fromJSValue()!
    }

    @inlinable public func initKeyboardEvent(typeArg: String, bubblesArg: Bool? = nil, cancelableArg: Bool? = nil, viewArg: Window? = nil, keyArg: String? = nil, locationArg: UInt32? = nil, ctrlKey: Bool? = nil, altKey: Bool? = nil, shiftKey: Bool? = nil, metaKey: Bool? = nil) {
        let this = jsObject
        _ = this[.initKeyboardEvent].function!(this: this, arguments: [_toJSValue(typeArg), _toJSValue(bubblesArg), _toJSValue(cancelableArg), _toJSValue(viewArg), _toJSValue(keyArg), _toJSValue(locationArg), _toJSValue(ctrlKey), _toJSValue(altKey), _toJSValue(shiftKey), _toJSValue(metaKey)])
    }

    @ReadonlyAttribute
    public var charCode: UInt32

    @ReadonlyAttribute
    public var keyCode: UInt32
}

public class KeyboardEventInit: BridgedDictionary {
    public convenience init(key: String, code: String, location: UInt32, repeat: Bool, isComposing: Bool, charCode: UInt32, keyCode: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.key] = _toJSValue(key)
        object[.code] = _toJSValue(code)
        object[.location] = _toJSValue(location)
        object[.repeat] = _toJSValue(`repeat`)
        object[.isComposing] = _toJSValue(isComposing)
        object[.charCode] = _toJSValue(charCode)
        object[.keyCode] = _toJSValue(keyCode)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _key = ReadWriteAttribute(jsObject: object, name: .key)
        _code = ReadWriteAttribute(jsObject: object, name: .code)
        _location = ReadWriteAttribute(jsObject: object, name: .location)
        _repeat = ReadWriteAttribute(jsObject: object, name: .repeat)
        _isComposing = ReadWriteAttribute(jsObject: object, name: .isComposing)
        _charCode = ReadWriteAttribute(jsObject: object, name: .charCode)
        _keyCode = ReadWriteAttribute(jsObject: object, name: .keyCode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var key: String

    @ReadWriteAttribute
    public var code: String

    @ReadWriteAttribute
    public var location: UInt32

    @ReadWriteAttribute
    public var `repeat`: Bool

    @ReadWriteAttribute
    public var isComposing: Bool

    @ReadWriteAttribute
    public var charCode: UInt32

    @ReadWriteAttribute
    public var keyCode: UInt32
}

public enum LatencyMode: JSString, JSValueCompatible {
    case quality = "quality"
    case realtime = "realtime"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Location: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Location].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _href = ReadWriteAttribute(jsObject: jsObject, name: .href)
        _origin = ReadonlyAttribute(jsObject: jsObject, name: .origin)
        _protocol = ReadWriteAttribute(jsObject: jsObject, name: .protocol)
        _host = ReadWriteAttribute(jsObject: jsObject, name: .host)
        _hostname = ReadWriteAttribute(jsObject: jsObject, name: .hostname)
        _port = ReadWriteAttribute(jsObject: jsObject, name: .port)
        _pathname = ReadWriteAttribute(jsObject: jsObject, name: .pathname)
        _search = ReadWriteAttribute(jsObject: jsObject, name: .search)
        _hash = ReadWriteAttribute(jsObject: jsObject, name: .hash)
        _ancestorOrigins = ReadonlyAttribute(jsObject: jsObject, name: .ancestorOrigins)
        self.jsObject = jsObject
    }

    @ReadWriteAttribute
    public var href: String

    @ReadonlyAttribute
    public var origin: String

    @ReadWriteAttribute
    public var `protocol`: String

    @ReadWriteAttribute
    public var host: String

    @ReadWriteAttribute
    public var hostname: String

    @ReadWriteAttribute
    public var port: String

    @ReadWriteAttribute
    public var pathname: String

    @ReadWriteAttribute
    public var search: String

    @ReadWriteAttribute
    public var hash: String

    @inlinable public func assign(url: String) {
        let this = jsObject
        _ = this[.assign].function!(this: this, arguments: [_toJSValue(url)])
    }

    @inlinable public func replace(url: String) {
        let this = jsObject
        _ = this[.replace].function!(this: this, arguments: [_toJSValue(url)])
    }

    @inlinable public func reload() {
        let this = jsObject
        _ = this[.reload].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var ancestorOrigins: DOMStringList
}

public class MathMLElement: Element, GlobalEventHandlers, HTMLOrSVGElement {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MathMLElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class MediaDeviceInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.MediaDeviceInfo].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _deviceId = ReadonlyAttribute(jsObject: jsObject, name: .deviceId)
        _kind = ReadonlyAttribute(jsObject: jsObject, name: .kind)
        _label = ReadonlyAttribute(jsObject: jsObject, name: .label)
        _groupId = ReadonlyAttribute(jsObject: jsObject, name: .groupId)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var deviceId: String

    @ReadonlyAttribute
    public var kind: MediaDeviceKind

    @ReadonlyAttribute
    public var label: String

    @ReadonlyAttribute
    public var groupId: String

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum MediaDeviceKind: JSString, JSValueCompatible {
    case audioinput = "audioinput"
    case audiooutput = "audiooutput"
    case videoinput = "videoinput"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class MediaDevices: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaDevices].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _ondevicechange = ClosureAttribute1Optional(jsObject: jsObject, name: .ondevicechange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ClosureAttribute1Optional
    public var ondevicechange: EventHandler

    @inlinable public func enumerateDevices() -> JSPromise {
        let this = jsObject
        return this[.enumerateDevices].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func enumerateDevices() async throws -> [MediaDeviceInfo] {
        let this = jsObject
        let _promise: JSPromise = this[.enumerateDevices].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func getSupportedConstraints() -> MediaTrackSupportedConstraints {
        let this = jsObject
        return this[.getSupportedConstraints].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getUserMedia(constraints: MediaStreamConstraints? = nil) -> JSPromise {
        let this = jsObject
        return this[.getUserMedia].function!(this: this, arguments: [_toJSValue(constraints)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getUserMedia(constraints: MediaStreamConstraints? = nil) async throws -> MediaStream {
        let this = jsObject
        let _promise: JSPromise = this[.getUserMedia].function!(this: this, arguments: [_toJSValue(constraints)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class MediaError: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.MediaError].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _code = ReadonlyAttribute(jsObject: jsObject, name: .code)
        _message = ReadonlyAttribute(jsObject: jsObject, name: .message)
        self.jsObject = jsObject
    }

    public static let MEDIA_ERR_ABORTED: UInt16 = 1

    public static let MEDIA_ERR_NETWORK: UInt16 = 2

    public static let MEDIA_ERR_DECODE: UInt16 = 3

    public static let MEDIA_ERR_SRC_NOT_SUPPORTED: UInt16 = 4

    @ReadonlyAttribute
    public var code: UInt16

    @ReadonlyAttribute
    public var message: String
}

public class MediaQueryList: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaQueryList].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _media = ReadonlyAttribute(jsObject: jsObject, name: .media)
        _matches = ReadonlyAttribute(jsObject: jsObject, name: .matches)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: .onchange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var media: String

    @ReadonlyAttribute
    public var matches: Bool

    @inlinable public func addListener(callback: EventListener?) {
        let this = jsObject
        _ = this[.addListener].function!(this: this, arguments: [_toJSValue(callback)])
    }

    @inlinable public func removeListener(callback: EventListener?) {
        let this = jsObject
        _ = this[.removeListener].function!(this: this, arguments: [_toJSValue(callback)])
    }

    @ClosureAttribute1Optional
    public var onchange: EventHandler
}

public class MediaQueryListEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaQueryListEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _media = ReadonlyAttribute(jsObject: jsObject, name: .media)
        _matches = ReadonlyAttribute(jsObject: jsObject, name: .matches)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: MediaQueryListEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var media: String

    @ReadonlyAttribute
    public var matches: Bool
}

public class MediaQueryListEventInit: BridgedDictionary {
    public convenience init(media: String, matches: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.media] = _toJSValue(media)
        object[.matches] = _toJSValue(matches)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _media = ReadWriteAttribute(jsObject: object, name: .media)
        _matches = ReadWriteAttribute(jsObject: object, name: .matches)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var media: String

    @ReadWriteAttribute
    public var matches: Bool
}

public class MediaRecorder: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaRecorder].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _stream = ReadonlyAttribute(jsObject: jsObject, name: .stream)
        _mimeType = ReadonlyAttribute(jsObject: jsObject, name: .mimeType)
        _state = ReadonlyAttribute(jsObject: jsObject, name: .state)
        _onstart = ClosureAttribute1Optional(jsObject: jsObject, name: .onstart)
        _onstop = ClosureAttribute1Optional(jsObject: jsObject, name: .onstop)
        _ondataavailable = ClosureAttribute1Optional(jsObject: jsObject, name: .ondataavailable)
        _onpause = ClosureAttribute1Optional(jsObject: jsObject, name: .onpause)
        _onresume = ClosureAttribute1Optional(jsObject: jsObject, name: .onresume)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onerror)
        _videoBitsPerSecond = ReadonlyAttribute(jsObject: jsObject, name: .videoBitsPerSecond)
        _audioBitsPerSecond = ReadonlyAttribute(jsObject: jsObject, name: .audioBitsPerSecond)
        _audioBitrateMode = ReadonlyAttribute(jsObject: jsObject, name: .audioBitrateMode)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(stream: MediaStream, options: MediaRecorderOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(stream), _toJSValue(options)]))
    }

    @ReadonlyAttribute
    public var stream: MediaStream

    @ReadonlyAttribute
    public var mimeType: String

    @ReadonlyAttribute
    public var state: RecordingState

    @ClosureAttribute1Optional
    public var onstart: EventHandler

    @ClosureAttribute1Optional
    public var onstop: EventHandler

    @ClosureAttribute1Optional
    public var ondataavailable: EventHandler

    @ClosureAttribute1Optional
    public var onpause: EventHandler

    @ClosureAttribute1Optional
    public var onresume: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @ReadonlyAttribute
    public var videoBitsPerSecond: UInt32

    @ReadonlyAttribute
    public var audioBitsPerSecond: UInt32

    @ReadonlyAttribute
    public var audioBitrateMode: BitrateMode

    @inlinable public func start(timeslice: UInt32? = nil) {
        let this = jsObject
        _ = this[.start].function!(this: this, arguments: [_toJSValue(timeslice)])
    }

    @inlinable public func stop() {
        let this = jsObject
        _ = this[.stop].function!(this: this, arguments: [])
    }

    @inlinable public func pause() {
        let this = jsObject
        _ = this[.pause].function!(this: this, arguments: [])
    }

    @inlinable public func resume() {
        let this = jsObject
        _ = this[.resume].function!(this: this, arguments: [])
    }

    @inlinable public func requestData() {
        let this = jsObject
        _ = this[.requestData].function!(this: this, arguments: [])
    }

    @inlinable public class func isTypeSupported(type: String) -> Bool {
        let this = constructor!
        return this[.isTypeSupported].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }
}

public class MediaRecorderOptions: BridgedDictionary {
    public convenience init(mimeType: String, audioBitsPerSecond: UInt32, videoBitsPerSecond: UInt32, bitsPerSecond: UInt32, audioBitrateMode: BitrateMode, videoKeyFrameIntervalDuration: DOMHighResTimeStamp, videoKeyFrameIntervalCount: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.mimeType] = _toJSValue(mimeType)
        object[.audioBitsPerSecond] = _toJSValue(audioBitsPerSecond)
        object[.videoBitsPerSecond] = _toJSValue(videoBitsPerSecond)
        object[.bitsPerSecond] = _toJSValue(bitsPerSecond)
        object[.audioBitrateMode] = _toJSValue(audioBitrateMode)
        object[.videoKeyFrameIntervalDuration] = _toJSValue(videoKeyFrameIntervalDuration)
        object[.videoKeyFrameIntervalCount] = _toJSValue(videoKeyFrameIntervalCount)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mimeType = ReadWriteAttribute(jsObject: object, name: .mimeType)
        _audioBitsPerSecond = ReadWriteAttribute(jsObject: object, name: .audioBitsPerSecond)
        _videoBitsPerSecond = ReadWriteAttribute(jsObject: object, name: .videoBitsPerSecond)
        _bitsPerSecond = ReadWriteAttribute(jsObject: object, name: .bitsPerSecond)
        _audioBitrateMode = ReadWriteAttribute(jsObject: object, name: .audioBitrateMode)
        _videoKeyFrameIntervalDuration = ReadWriteAttribute(jsObject: object, name: .videoKeyFrameIntervalDuration)
        _videoKeyFrameIntervalCount = ReadWriteAttribute(jsObject: object, name: .videoKeyFrameIntervalCount)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mimeType: String

    @ReadWriteAttribute
    public var audioBitsPerSecond: UInt32

    @ReadWriteAttribute
    public var videoBitsPerSecond: UInt32

    @ReadWriteAttribute
    public var bitsPerSecond: UInt32

    @ReadWriteAttribute
    public var audioBitrateMode: BitrateMode

    @ReadWriteAttribute
    public var videoKeyFrameIntervalDuration: DOMHighResTimeStamp

    @ReadWriteAttribute
    public var videoKeyFrameIntervalCount: UInt32
}

public class MediaSource: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaSource].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _handle = ReadonlyAttribute(jsObject: jsObject, name: .handle)
        _sourceBuffers = ReadonlyAttribute(jsObject: jsObject, name: .sourceBuffers)
        _activeSourceBuffers = ReadonlyAttribute(jsObject: jsObject, name: .activeSourceBuffers)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: .readyState)
        _duration = ReadWriteAttribute(jsObject: jsObject, name: .duration)
        _onsourceopen = ClosureAttribute1Optional(jsObject: jsObject, name: .onsourceopen)
        _onsourceended = ClosureAttribute1Optional(jsObject: jsObject, name: .onsourceended)
        _onsourceclose = ClosureAttribute1Optional(jsObject: jsObject, name: .onsourceclose)
        _canConstructInDedicatedWorker = ReadonlyAttribute(jsObject: jsObject, name: .canConstructInDedicatedWorker)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var handle: MediaSourceHandle

    @ReadonlyAttribute
    public var sourceBuffers: SourceBufferList

    @ReadonlyAttribute
    public var activeSourceBuffers: SourceBufferList

    @ReadonlyAttribute
    public var readyState: ReadyState

    @ReadWriteAttribute
    public var duration: Double

    @ClosureAttribute1Optional
    public var onsourceopen: EventHandler

    @ClosureAttribute1Optional
    public var onsourceended: EventHandler

    @ClosureAttribute1Optional
    public var onsourceclose: EventHandler

    @ReadonlyAttribute
    public var canConstructInDedicatedWorker: Bool

    @inlinable public func addSourceBuffer(type: String) -> SourceBuffer {
        let this = jsObject
        return this[.addSourceBuffer].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    @inlinable public func removeSourceBuffer(sourceBuffer: SourceBuffer) {
        let this = jsObject
        _ = this[.removeSourceBuffer].function!(this: this, arguments: [_toJSValue(sourceBuffer)])
    }

    @inlinable public func endOfStream(error: EndOfStreamError? = nil) {
        let this = jsObject
        _ = this[.endOfStream].function!(this: this, arguments: [_toJSValue(error)])
    }

    @inlinable public func setLiveSeekableRange(start: Double, end: Double) {
        let this = jsObject
        _ = this[.setLiveSeekableRange].function!(this: this, arguments: [_toJSValue(start), _toJSValue(end)])
    }

    @inlinable public func clearLiveSeekableRange() {
        let this = jsObject
        _ = this[.clearLiveSeekableRange].function!(this: this, arguments: [])
    }

    @inlinable public class func isTypeSupported(type: String) -> Bool {
        let this = constructor!
        return this[.isTypeSupported].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }
}

public class MediaSourceHandle: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.MediaSourceHandle].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class MediaStream: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaStream].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _id = ReadonlyAttribute(jsObject: jsObject, name: .id)
        _active = ReadonlyAttribute(jsObject: jsObject, name: .active)
        _onaddtrack = ClosureAttribute1Optional(jsObject: jsObject, name: .onaddtrack)
        _onremovetrack = ClosureAttribute1Optional(jsObject: jsObject, name: .onremovetrack)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @inlinable public convenience init(stream: MediaStream) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(stream)]))
    }

    @inlinable public convenience init(tracks: [MediaStreamTrack]) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(tracks)]))
    }

    @ReadonlyAttribute
    public var id: String

    @inlinable public func getAudioTracks() -> [MediaStreamTrack] {
        let this = jsObject
        return this[.getAudioTracks].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getVideoTracks() -> [MediaStreamTrack] {
        let this = jsObject
        return this[.getVideoTracks].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getTracks() -> [MediaStreamTrack] {
        let this = jsObject
        return this[.getTracks].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getTrackById(trackId: String) -> MediaStreamTrack? {
        let this = jsObject
        return this[.getTrackById].function!(this: this, arguments: [_toJSValue(trackId)]).fromJSValue()
    }

    @inlinable public func addTrack(track: MediaStreamTrack) {
        let this = jsObject
        _ = this[.addTrack].function!(this: this, arguments: [_toJSValue(track)])
    }

    @inlinable public func removeTrack(track: MediaStreamTrack) {
        let this = jsObject
        _ = this[.removeTrack].function!(this: this, arguments: [_toJSValue(track)])
    }

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var active: Bool

    @ClosureAttribute1Optional
    public var onaddtrack: EventHandler

    @ClosureAttribute1Optional
    public var onremovetrack: EventHandler
}

public class MediaStreamConstraints: BridgedDictionary {
    public convenience init(video: Bool_or_MediaTrackConstraints, audio: Bool_or_MediaTrackConstraints) {
        let object = JSObject.global[.Object].function!.new()
        object[.video] = _toJSValue(video)
        object[.audio] = _toJSValue(audio)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _video = ReadWriteAttribute(jsObject: object, name: .video)
        _audio = ReadWriteAttribute(jsObject: object, name: .audio)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var video: Bool_or_MediaTrackConstraints

    @ReadWriteAttribute
    public var audio: Bool_or_MediaTrackConstraints
}

public class MediaStreamTrack: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaStreamTrack].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadonlyAttribute(jsObject: jsObject, name: .kind)
        _id = ReadonlyAttribute(jsObject: jsObject, name: .id)
        _label = ReadonlyAttribute(jsObject: jsObject, name: .label)
        _enabled = ReadWriteAttribute(jsObject: jsObject, name: .enabled)
        _muted = ReadonlyAttribute(jsObject: jsObject, name: .muted)
        _onmute = ClosureAttribute1Optional(jsObject: jsObject, name: .onmute)
        _onunmute = ClosureAttribute1Optional(jsObject: jsObject, name: .onunmute)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: .readyState)
        _onended = ClosureAttribute1Optional(jsObject: jsObject, name: .onended)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var kind: String

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var label: String

    @ReadWriteAttribute
    public var enabled: Bool

    @ReadonlyAttribute
    public var muted: Bool

    @ClosureAttribute1Optional
    public var onmute: EventHandler

    @ClosureAttribute1Optional
    public var onunmute: EventHandler

    @ReadonlyAttribute
    public var readyState: MediaStreamTrackState

    @ClosureAttribute1Optional
    public var onended: EventHandler

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func stop() {
        let this = jsObject
        _ = this[.stop].function!(this: this, arguments: [])
    }

    @inlinable public func getCapabilities() -> MediaTrackCapabilities {
        let this = jsObject
        return this[.getCapabilities].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getConstraints() -> MediaTrackConstraints {
        let this = jsObject
        return this[.getConstraints].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getSettings() -> MediaTrackSettings {
        let this = jsObject
        return this[.getSettings].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func applyConstraints(constraints: MediaTrackConstraints? = nil) -> JSPromise {
        let this = jsObject
        return this[.applyConstraints].function!(this: this, arguments: [_toJSValue(constraints)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func applyConstraints(constraints: MediaTrackConstraints? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.applyConstraints].function!(this: this, arguments: [_toJSValue(constraints)]).fromJSValue()!
        _ = try await _promise.value
    }
}

public class MediaStreamTrackEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaStreamTrackEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _track = ReadonlyAttribute(jsObject: jsObject, name: .track)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: MediaStreamTrackEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var track: MediaStreamTrack
}

public class MediaStreamTrackEventInit: BridgedDictionary {
    public convenience init(track: MediaStreamTrack) {
        let object = JSObject.global[.Object].function!.new()
        object[.track] = _toJSValue(track)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _track = ReadWriteAttribute(jsObject: object, name: .track)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var track: MediaStreamTrack
}

public enum MediaStreamTrackState: JSString, JSValueCompatible {
    case live = "live"
    case ended = "ended"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class MediaTrackCapabilities: BridgedDictionary {
    public convenience init(width: ULongRange, height: ULongRange, aspectRatio: DoubleRange, frameRate: DoubleRange, facingMode: [String], resizeMode: [String], sampleRate: ULongRange, sampleSize: ULongRange, echoCancellation: [Bool], autoGainControl: [Bool], noiseSuppression: [Bool], latency: DoubleRange, channelCount: ULongRange, deviceId: String, groupId: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.width] = _toJSValue(width)
        object[.height] = _toJSValue(height)
        object[.aspectRatio] = _toJSValue(aspectRatio)
        object[.frameRate] = _toJSValue(frameRate)
        object[.facingMode] = _toJSValue(facingMode)
        object[.resizeMode] = _toJSValue(resizeMode)
        object[.sampleRate] = _toJSValue(sampleRate)
        object[.sampleSize] = _toJSValue(sampleSize)
        object[.echoCancellation] = _toJSValue(echoCancellation)
        object[.autoGainControl] = _toJSValue(autoGainControl)
        object[.noiseSuppression] = _toJSValue(noiseSuppression)
        object[.latency] = _toJSValue(latency)
        object[.channelCount] = _toJSValue(channelCount)
        object[.deviceId] = _toJSValue(deviceId)
        object[.groupId] = _toJSValue(groupId)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _width = ReadWriteAttribute(jsObject: object, name: .width)
        _height = ReadWriteAttribute(jsObject: object, name: .height)
        _aspectRatio = ReadWriteAttribute(jsObject: object, name: .aspectRatio)
        _frameRate = ReadWriteAttribute(jsObject: object, name: .frameRate)
        _facingMode = ReadWriteAttribute(jsObject: object, name: .facingMode)
        _resizeMode = ReadWriteAttribute(jsObject: object, name: .resizeMode)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: .sampleRate)
        _sampleSize = ReadWriteAttribute(jsObject: object, name: .sampleSize)
        _echoCancellation = ReadWriteAttribute(jsObject: object, name: .echoCancellation)
        _autoGainControl = ReadWriteAttribute(jsObject: object, name: .autoGainControl)
        _noiseSuppression = ReadWriteAttribute(jsObject: object, name: .noiseSuppression)
        _latency = ReadWriteAttribute(jsObject: object, name: .latency)
        _channelCount = ReadWriteAttribute(jsObject: object, name: .channelCount)
        _deviceId = ReadWriteAttribute(jsObject: object, name: .deviceId)
        _groupId = ReadWriteAttribute(jsObject: object, name: .groupId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var width: ULongRange

    @ReadWriteAttribute
    public var height: ULongRange

    @ReadWriteAttribute
    public var aspectRatio: DoubleRange

    @ReadWriteAttribute
    public var frameRate: DoubleRange

    @ReadWriteAttribute
    public var facingMode: [String]

    @ReadWriteAttribute
    public var resizeMode: [String]

    @ReadWriteAttribute
    public var sampleRate: ULongRange

    @ReadWriteAttribute
    public var sampleSize: ULongRange

    @ReadWriteAttribute
    public var echoCancellation: [Bool]

    @ReadWriteAttribute
    public var autoGainControl: [Bool]

    @ReadWriteAttribute
    public var noiseSuppression: [Bool]

    @ReadWriteAttribute
    public var latency: DoubleRange

    @ReadWriteAttribute
    public var channelCount: ULongRange

    @ReadWriteAttribute
    public var deviceId: String

    @ReadWriteAttribute
    public var groupId: String
}

public class MediaTrackConstraintSet: BridgedDictionary {
    public convenience init(width: ConstrainULong, height: ConstrainULong, aspectRatio: ConstrainDouble, frameRate: ConstrainDouble, facingMode: ConstrainDOMString, resizeMode: ConstrainDOMString, sampleRate: ConstrainULong, sampleSize: ConstrainULong, echoCancellation: ConstrainBoolean, autoGainControl: ConstrainBoolean, noiseSuppression: ConstrainBoolean, latency: ConstrainDouble, channelCount: ConstrainULong, deviceId: ConstrainDOMString, groupId: ConstrainDOMString) {
        let object = JSObject.global[.Object].function!.new()
        object[.width] = _toJSValue(width)
        object[.height] = _toJSValue(height)
        object[.aspectRatio] = _toJSValue(aspectRatio)
        object[.frameRate] = _toJSValue(frameRate)
        object[.facingMode] = _toJSValue(facingMode)
        object[.resizeMode] = _toJSValue(resizeMode)
        object[.sampleRate] = _toJSValue(sampleRate)
        object[.sampleSize] = _toJSValue(sampleSize)
        object[.echoCancellation] = _toJSValue(echoCancellation)
        object[.autoGainControl] = _toJSValue(autoGainControl)
        object[.noiseSuppression] = _toJSValue(noiseSuppression)
        object[.latency] = _toJSValue(latency)
        object[.channelCount] = _toJSValue(channelCount)
        object[.deviceId] = _toJSValue(deviceId)
        object[.groupId] = _toJSValue(groupId)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _width = ReadWriteAttribute(jsObject: object, name: .width)
        _height = ReadWriteAttribute(jsObject: object, name: .height)
        _aspectRatio = ReadWriteAttribute(jsObject: object, name: .aspectRatio)
        _frameRate = ReadWriteAttribute(jsObject: object, name: .frameRate)
        _facingMode = ReadWriteAttribute(jsObject: object, name: .facingMode)
        _resizeMode = ReadWriteAttribute(jsObject: object, name: .resizeMode)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: .sampleRate)
        _sampleSize = ReadWriteAttribute(jsObject: object, name: .sampleSize)
        _echoCancellation = ReadWriteAttribute(jsObject: object, name: .echoCancellation)
        _autoGainControl = ReadWriteAttribute(jsObject: object, name: .autoGainControl)
        _noiseSuppression = ReadWriteAttribute(jsObject: object, name: .noiseSuppression)
        _latency = ReadWriteAttribute(jsObject: object, name: .latency)
        _channelCount = ReadWriteAttribute(jsObject: object, name: .channelCount)
        _deviceId = ReadWriteAttribute(jsObject: object, name: .deviceId)
        _groupId = ReadWriteAttribute(jsObject: object, name: .groupId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var width: ConstrainULong

    @ReadWriteAttribute
    public var height: ConstrainULong

    @ReadWriteAttribute
    public var aspectRatio: ConstrainDouble

    @ReadWriteAttribute
    public var frameRate: ConstrainDouble

    @ReadWriteAttribute
    public var facingMode: ConstrainDOMString

    @ReadWriteAttribute
    public var resizeMode: ConstrainDOMString

    @ReadWriteAttribute
    public var sampleRate: ConstrainULong

    @ReadWriteAttribute
    public var sampleSize: ConstrainULong

    @ReadWriteAttribute
    public var echoCancellation: ConstrainBoolean

    @ReadWriteAttribute
    public var autoGainControl: ConstrainBoolean

    @ReadWriteAttribute
    public var noiseSuppression: ConstrainBoolean

    @ReadWriteAttribute
    public var latency: ConstrainDouble

    @ReadWriteAttribute
    public var channelCount: ConstrainULong

    @ReadWriteAttribute
    public var deviceId: ConstrainDOMString

    @ReadWriteAttribute
    public var groupId: ConstrainDOMString
}

public class MediaTrackConstraints: BridgedDictionary {
    public convenience init(advanced: [MediaTrackConstraintSet]) {
        let object = JSObject.global[.Object].function!.new()
        object[.advanced] = _toJSValue(advanced)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _advanced = ReadWriteAttribute(jsObject: object, name: .advanced)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var advanced: [MediaTrackConstraintSet]
}

public class MediaTrackSettings: BridgedDictionary {
    public convenience init(width: UInt32, height: UInt32, aspectRatio: Double, frameRate: Double, facingMode: String, resizeMode: String, sampleRate: UInt32, sampleSize: UInt32, echoCancellation: Bool, autoGainControl: Bool, noiseSuppression: Bool, latency: Double, channelCount: UInt32, deviceId: String, groupId: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.width] = _toJSValue(width)
        object[.height] = _toJSValue(height)
        object[.aspectRatio] = _toJSValue(aspectRatio)
        object[.frameRate] = _toJSValue(frameRate)
        object[.facingMode] = _toJSValue(facingMode)
        object[.resizeMode] = _toJSValue(resizeMode)
        object[.sampleRate] = _toJSValue(sampleRate)
        object[.sampleSize] = _toJSValue(sampleSize)
        object[.echoCancellation] = _toJSValue(echoCancellation)
        object[.autoGainControl] = _toJSValue(autoGainControl)
        object[.noiseSuppression] = _toJSValue(noiseSuppression)
        object[.latency] = _toJSValue(latency)
        object[.channelCount] = _toJSValue(channelCount)
        object[.deviceId] = _toJSValue(deviceId)
        object[.groupId] = _toJSValue(groupId)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _width = ReadWriteAttribute(jsObject: object, name: .width)
        _height = ReadWriteAttribute(jsObject: object, name: .height)
        _aspectRatio = ReadWriteAttribute(jsObject: object, name: .aspectRatio)
        _frameRate = ReadWriteAttribute(jsObject: object, name: .frameRate)
        _facingMode = ReadWriteAttribute(jsObject: object, name: .facingMode)
        _resizeMode = ReadWriteAttribute(jsObject: object, name: .resizeMode)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: .sampleRate)
        _sampleSize = ReadWriteAttribute(jsObject: object, name: .sampleSize)
        _echoCancellation = ReadWriteAttribute(jsObject: object, name: .echoCancellation)
        _autoGainControl = ReadWriteAttribute(jsObject: object, name: .autoGainControl)
        _noiseSuppression = ReadWriteAttribute(jsObject: object, name: .noiseSuppression)
        _latency = ReadWriteAttribute(jsObject: object, name: .latency)
        _channelCount = ReadWriteAttribute(jsObject: object, name: .channelCount)
        _deviceId = ReadWriteAttribute(jsObject: object, name: .deviceId)
        _groupId = ReadWriteAttribute(jsObject: object, name: .groupId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    @ReadWriteAttribute
    public var aspectRatio: Double

    @ReadWriteAttribute
    public var frameRate: Double

    @ReadWriteAttribute
    public var facingMode: String

    @ReadWriteAttribute
    public var resizeMode: String

    @ReadWriteAttribute
    public var sampleRate: UInt32

    @ReadWriteAttribute
    public var sampleSize: UInt32

    @ReadWriteAttribute
    public var echoCancellation: Bool

    @ReadWriteAttribute
    public var autoGainControl: Bool

    @ReadWriteAttribute
    public var noiseSuppression: Bool

    @ReadWriteAttribute
    public var latency: Double

    @ReadWriteAttribute
    public var channelCount: UInt32

    @ReadWriteAttribute
    public var deviceId: String

    @ReadWriteAttribute
    public var groupId: String
}

public class MediaTrackSupportedConstraints: BridgedDictionary {
    public convenience init(width: Bool, height: Bool, aspectRatio: Bool, frameRate: Bool, facingMode: Bool, resizeMode: Bool, sampleRate: Bool, sampleSize: Bool, echoCancellation: Bool, autoGainControl: Bool, noiseSuppression: Bool, latency: Bool, channelCount: Bool, deviceId: Bool, groupId: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.width] = _toJSValue(width)
        object[.height] = _toJSValue(height)
        object[.aspectRatio] = _toJSValue(aspectRatio)
        object[.frameRate] = _toJSValue(frameRate)
        object[.facingMode] = _toJSValue(facingMode)
        object[.resizeMode] = _toJSValue(resizeMode)
        object[.sampleRate] = _toJSValue(sampleRate)
        object[.sampleSize] = _toJSValue(sampleSize)
        object[.echoCancellation] = _toJSValue(echoCancellation)
        object[.autoGainControl] = _toJSValue(autoGainControl)
        object[.noiseSuppression] = _toJSValue(noiseSuppression)
        object[.latency] = _toJSValue(latency)
        object[.channelCount] = _toJSValue(channelCount)
        object[.deviceId] = _toJSValue(deviceId)
        object[.groupId] = _toJSValue(groupId)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _width = ReadWriteAttribute(jsObject: object, name: .width)
        _height = ReadWriteAttribute(jsObject: object, name: .height)
        _aspectRatio = ReadWriteAttribute(jsObject: object, name: .aspectRatio)
        _frameRate = ReadWriteAttribute(jsObject: object, name: .frameRate)
        _facingMode = ReadWriteAttribute(jsObject: object, name: .facingMode)
        _resizeMode = ReadWriteAttribute(jsObject: object, name: .resizeMode)
        _sampleRate = ReadWriteAttribute(jsObject: object, name: .sampleRate)
        _sampleSize = ReadWriteAttribute(jsObject: object, name: .sampleSize)
        _echoCancellation = ReadWriteAttribute(jsObject: object, name: .echoCancellation)
        _autoGainControl = ReadWriteAttribute(jsObject: object, name: .autoGainControl)
        _noiseSuppression = ReadWriteAttribute(jsObject: object, name: .noiseSuppression)
        _latency = ReadWriteAttribute(jsObject: object, name: .latency)
        _channelCount = ReadWriteAttribute(jsObject: object, name: .channelCount)
        _deviceId = ReadWriteAttribute(jsObject: object, name: .deviceId)
        _groupId = ReadWriteAttribute(jsObject: object, name: .groupId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var width: Bool

    @ReadWriteAttribute
    public var height: Bool

    @ReadWriteAttribute
    public var aspectRatio: Bool

    @ReadWriteAttribute
    public var frameRate: Bool

    @ReadWriteAttribute
    public var facingMode: Bool

    @ReadWriteAttribute
    public var resizeMode: Bool

    @ReadWriteAttribute
    public var sampleRate: Bool

    @ReadWriteAttribute
    public var sampleSize: Bool

    @ReadWriteAttribute
    public var echoCancellation: Bool

    @ReadWriteAttribute
    public var autoGainControl: Bool

    @ReadWriteAttribute
    public var noiseSuppression: Bool

    @ReadWriteAttribute
    public var latency: Bool

    @ReadWriteAttribute
    public var channelCount: Bool

    @ReadWriteAttribute
    public var deviceId: Bool

    @ReadWriteAttribute
    public var groupId: Bool
}

public class MessageChannel: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.MessageChannel].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _port1 = ReadonlyAttribute(jsObject: jsObject, name: .port1)
        _port2 = ReadonlyAttribute(jsObject: jsObject, name: .port2)
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var port1: MessagePort

    @ReadonlyAttribute
    public var port2: MessagePort
}

public class MessageEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MessageEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _data = ReadonlyAttribute(jsObject: jsObject, name: .data)
        _origin = ReadonlyAttribute(jsObject: jsObject, name: .origin)
        _lastEventId = ReadonlyAttribute(jsObject: jsObject, name: .lastEventId)
        _source = ReadonlyAttribute(jsObject: jsObject, name: .source)
        _ports = ReadonlyAttribute(jsObject: jsObject, name: .ports)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: MessageEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var data: JSValue

    @ReadonlyAttribute
    public var origin: String

    @ReadonlyAttribute
    public var lastEventId: String

    @ReadonlyAttribute
    public var source: MessageEventSource?

    @ReadonlyAttribute
    public var ports: [MessagePort]

    @inlinable public func initMessageEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil, data: JSValue? = nil, origin: String? = nil, lastEventId: String? = nil, source: MessageEventSource? = nil, ports: [MessagePort]? = nil) {
        let this = jsObject
        _ = this[.initMessageEvent].function!(this: this, arguments: [_toJSValue(type), _toJSValue(bubbles), _toJSValue(cancelable), _toJSValue(data), _toJSValue(origin), _toJSValue(lastEventId), _toJSValue(source), _toJSValue(ports)])
    }
}

public class MessageEventInit: BridgedDictionary {
    public convenience init(data: JSValue, origin: String, lastEventId: String, source: MessageEventSource?, ports: [MessagePort]) {
        let object = JSObject.global[.Object].function!.new()
        object[.data] = _toJSValue(data)
        object[.origin] = _toJSValue(origin)
        object[.lastEventId] = _toJSValue(lastEventId)
        object[.source] = _toJSValue(source)
        object[.ports] = _toJSValue(ports)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _data = ReadWriteAttribute(jsObject: object, name: .data)
        _origin = ReadWriteAttribute(jsObject: object, name: .origin)
        _lastEventId = ReadWriteAttribute(jsObject: object, name: .lastEventId)
        _source = ReadWriteAttribute(jsObject: object, name: .source)
        _ports = ReadWriteAttribute(jsObject: object, name: .ports)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var data: JSValue

    @ReadWriteAttribute
    public var origin: String

    @ReadWriteAttribute
    public var lastEventId: String

    @ReadWriteAttribute
    public var source: MessageEventSource?

    @ReadWriteAttribute
    public var ports: [MessagePort]
}

public class MessagePort: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MessagePort].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: .onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func postMessage(message: JSValue, transfer: [JSObject]) {
        let this = jsObject
        _ = this[.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(transfer)])
    }

    @inlinable public func postMessage(message: JSValue, options: StructuredSerializeOptions? = nil) {
        let this = jsObject
        _ = this[.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(options)])
    }

    @inlinable public func start() {
        let this = jsObject
        _ = this[.start].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public class MimeType: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.MimeType].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _description = ReadonlyAttribute(jsObject: jsObject, name: .description)
        _suffixes = ReadonlyAttribute(jsObject: jsObject, name: .suffixes)
        _enabledPlugin = ReadonlyAttribute(jsObject: jsObject, name: .enabledPlugin)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var description: String

    @ReadonlyAttribute
    public var suffixes: String

    @ReadonlyAttribute
    public var enabledPlugin: Plugin
}

public class MimeTypeArray: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.MimeTypeArray].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> MimeType? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(index: UInt32) -> MimeType? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> MimeType? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func namedItem(name: String) -> MimeType? {
        let this = jsObject
        return this[.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public class MouseEvent: UIEvent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MouseEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _screenX = ReadonlyAttribute(jsObject: jsObject, name: .screenX)
        _screenY = ReadonlyAttribute(jsObject: jsObject, name: .screenY)
        _clientX = ReadonlyAttribute(jsObject: jsObject, name: .clientX)
        _clientY = ReadonlyAttribute(jsObject: jsObject, name: .clientY)
        _ctrlKey = ReadonlyAttribute(jsObject: jsObject, name: .ctrlKey)
        _shiftKey = ReadonlyAttribute(jsObject: jsObject, name: .shiftKey)
        _altKey = ReadonlyAttribute(jsObject: jsObject, name: .altKey)
        _metaKey = ReadonlyAttribute(jsObject: jsObject, name: .metaKey)
        _button = ReadonlyAttribute(jsObject: jsObject, name: .button)
        _buttons = ReadonlyAttribute(jsObject: jsObject, name: .buttons)
        _relatedTarget = ReadonlyAttribute(jsObject: jsObject, name: .relatedTarget)
        _pageX = ReadonlyAttribute(jsObject: jsObject, name: .pageX)
        _pageY = ReadonlyAttribute(jsObject: jsObject, name: .pageY)
        _x = ReadonlyAttribute(jsObject: jsObject, name: .x)
        _y = ReadonlyAttribute(jsObject: jsObject, name: .y)
        _offsetX = ReadonlyAttribute(jsObject: jsObject, name: .offsetX)
        _offsetY = ReadonlyAttribute(jsObject: jsObject, name: .offsetY)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: MouseEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var screenX: Int32

    @ReadonlyAttribute
    public var screenY: Int32

    @ReadonlyAttribute
    public var clientX: Int32

    @ReadonlyAttribute
    public var clientY: Int32

    @ReadonlyAttribute
    public var ctrlKey: Bool

    @ReadonlyAttribute
    public var shiftKey: Bool

    @ReadonlyAttribute
    public var altKey: Bool

    @ReadonlyAttribute
    public var metaKey: Bool

    @ReadonlyAttribute
    public var button: Int16

    @ReadonlyAttribute
    public var buttons: UInt16

    @ReadonlyAttribute
    public var relatedTarget: EventTarget?

    @inlinable public func getModifierState(keyArg: String) -> Bool {
        let this = jsObject
        return this[.getModifierState].function!(this: this, arguments: [_toJSValue(keyArg)]).fromJSValue()!
    }

    @inlinable public func initMouseEvent(typeArg: String, bubblesArg: Bool? = nil, cancelableArg: Bool? = nil, viewArg: Window? = nil, detailArg: Int32? = nil, screenXArg: Int32? = nil, screenYArg: Int32? = nil, clientXArg: Int32? = nil, clientYArg: Int32? = nil, ctrlKeyArg: Bool? = nil, altKeyArg: Bool? = nil, shiftKeyArg: Bool? = nil, metaKeyArg: Bool? = nil, buttonArg: Int16? = nil, relatedTargetArg: EventTarget? = nil) {
        let this = jsObject
        _ = this[.initMouseEvent].function!(this: this, arguments: [_toJSValue(typeArg), _toJSValue(bubblesArg), _toJSValue(cancelableArg), _toJSValue(viewArg), _toJSValue(detailArg), _toJSValue(screenXArg), _toJSValue(screenYArg), _toJSValue(clientXArg), _toJSValue(clientYArg), _toJSValue(ctrlKeyArg), _toJSValue(altKeyArg), _toJSValue(shiftKeyArg), _toJSValue(metaKeyArg), _toJSValue(buttonArg), _toJSValue(relatedTargetArg)])
    }

    @ReadonlyAttribute
    public var pageX: Double

    @ReadonlyAttribute
    public var pageY: Double

    @ReadonlyAttribute
    public var x: Double

    @ReadonlyAttribute
    public var y: Double

    @ReadonlyAttribute
    public var offsetX: Double

    @ReadonlyAttribute
    public var offsetY: Double
}

public class MouseEventInit: BridgedDictionary {
    public convenience init(screenX: Int32, screenY: Int32, clientX: Int32, clientY: Int32, button: Int16, buttons: UInt16, relatedTarget: EventTarget?) {
        let object = JSObject.global[.Object].function!.new()
        object[.screenX] = _toJSValue(screenX)
        object[.screenY] = _toJSValue(screenY)
        object[.clientX] = _toJSValue(clientX)
        object[.clientY] = _toJSValue(clientY)
        object[.button] = _toJSValue(button)
        object[.buttons] = _toJSValue(buttons)
        object[.relatedTarget] = _toJSValue(relatedTarget)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _screenX = ReadWriteAttribute(jsObject: object, name: .screenX)
        _screenY = ReadWriteAttribute(jsObject: object, name: .screenY)
        _clientX = ReadWriteAttribute(jsObject: object, name: .clientX)
        _clientY = ReadWriteAttribute(jsObject: object, name: .clientY)
        _button = ReadWriteAttribute(jsObject: object, name: .button)
        _buttons = ReadWriteAttribute(jsObject: object, name: .buttons)
        _relatedTarget = ReadWriteAttribute(jsObject: object, name: .relatedTarget)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var screenX: Int32

    @ReadWriteAttribute
    public var screenY: Int32

    @ReadWriteAttribute
    public var clientX: Int32

    @ReadWriteAttribute
    public var clientY: Int32

    @ReadWriteAttribute
    public var button: Int16

    @ReadWriteAttribute
    public var buttons: UInt16

    @ReadWriteAttribute
    public var relatedTarget: EventTarget?
}

public class MultiCacheQueryOptions: BridgedDictionary {
    public convenience init(cacheName: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.cacheName] = _toJSValue(cacheName)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _cacheName = ReadWriteAttribute(jsObject: object, name: .cacheName)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var cacheName: String
}

public class MutationEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MutationEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _relatedNode = ReadonlyAttribute(jsObject: jsObject, name: .relatedNode)
        _prevValue = ReadonlyAttribute(jsObject: jsObject, name: .prevValue)
        _newValue = ReadonlyAttribute(jsObject: jsObject, name: .newValue)
        _attrName = ReadonlyAttribute(jsObject: jsObject, name: .attrName)
        _attrChange = ReadonlyAttribute(jsObject: jsObject, name: .attrChange)
        super.init(unsafelyWrapping: jsObject)
    }

    public static let MODIFICATION: UInt16 = 1

    public static let ADDITION: UInt16 = 2

    public static let REMOVAL: UInt16 = 3

    @ReadonlyAttribute
    public var relatedNode: Node?

    @ReadonlyAttribute
    public var prevValue: String

    @ReadonlyAttribute
    public var newValue: String

    @ReadonlyAttribute
    public var attrName: String

    @ReadonlyAttribute
    public var attrChange: UInt16

    @inlinable public func initMutationEvent(typeArg: String, bubblesArg: Bool? = nil, cancelableArg: Bool? = nil, relatedNodeArg: Node? = nil, prevValueArg: String? = nil, newValueArg: String? = nil, attrNameArg: String? = nil, attrChangeArg: UInt16? = nil) {
        let this = jsObject
        _ = this[.initMutationEvent].function!(this: this, arguments: [_toJSValue(typeArg), _toJSValue(bubblesArg), _toJSValue(cancelableArg), _toJSValue(relatedNodeArg), _toJSValue(prevValueArg), _toJSValue(newValueArg), _toJSValue(attrNameArg), _toJSValue(attrChangeArg)])
    }
}

public class MutationObserver: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.MutationObserver].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(callback: @escaping MutationCallback) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(callback)]))
    }

    @inlinable public func observe(target: Node, options: MutationObserverInit? = nil) {
        let this = jsObject
        _ = this[.observe].function!(this: this, arguments: [_toJSValue(target), _toJSValue(options)])
    }

    @inlinable public func disconnect() {
        let this = jsObject
        _ = this[.disconnect].function!(this: this, arguments: [])
    }

    @inlinable public func takeRecords() -> [MutationRecord] {
        let this = jsObject
        return this[.takeRecords].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class MutationObserverInit: BridgedDictionary {
    public convenience init(childList: Bool, attributes: Bool, characterData: Bool, subtree: Bool, attributeOldValue: Bool, characterDataOldValue: Bool, attributeFilter: [String]) {
        let object = JSObject.global[.Object].function!.new()
        object[.childList] = _toJSValue(childList)
        object[.attributes] = _toJSValue(attributes)
        object[.characterData] = _toJSValue(characterData)
        object[.subtree] = _toJSValue(subtree)
        object[.attributeOldValue] = _toJSValue(attributeOldValue)
        object[.characterDataOldValue] = _toJSValue(characterDataOldValue)
        object[.attributeFilter] = _toJSValue(attributeFilter)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _childList = ReadWriteAttribute(jsObject: object, name: .childList)
        _attributes = ReadWriteAttribute(jsObject: object, name: .attributes)
        _characterData = ReadWriteAttribute(jsObject: object, name: .characterData)
        _subtree = ReadWriteAttribute(jsObject: object, name: .subtree)
        _attributeOldValue = ReadWriteAttribute(jsObject: object, name: .attributeOldValue)
        _characterDataOldValue = ReadWriteAttribute(jsObject: object, name: .characterDataOldValue)
        _attributeFilter = ReadWriteAttribute(jsObject: object, name: .attributeFilter)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var childList: Bool

    @ReadWriteAttribute
    public var attributes: Bool

    @ReadWriteAttribute
    public var characterData: Bool

    @ReadWriteAttribute
    public var subtree: Bool

    @ReadWriteAttribute
    public var attributeOldValue: Bool

    @ReadWriteAttribute
    public var characterDataOldValue: Bool

    @ReadWriteAttribute
    public var attributeFilter: [String]
}

public class MutationRecord: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.MutationRecord].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _target = ReadonlyAttribute(jsObject: jsObject, name: .target)
        _addedNodes = ReadonlyAttribute(jsObject: jsObject, name: .addedNodes)
        _removedNodes = ReadonlyAttribute(jsObject: jsObject, name: .removedNodes)
        _previousSibling = ReadonlyAttribute(jsObject: jsObject, name: .previousSibling)
        _nextSibling = ReadonlyAttribute(jsObject: jsObject, name: .nextSibling)
        _attributeName = ReadonlyAttribute(jsObject: jsObject, name: .attributeName)
        _attributeNamespace = ReadonlyAttribute(jsObject: jsObject, name: .attributeNamespace)
        _oldValue = ReadonlyAttribute(jsObject: jsObject, name: .oldValue)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var type: String

    @ReadonlyAttribute
    public var target: Node

    @ReadonlyAttribute
    public var addedNodes: NodeList

    @ReadonlyAttribute
    public var removedNodes: NodeList

    @ReadonlyAttribute
    public var previousSibling: Node?

    @ReadonlyAttribute
    public var nextSibling: Node?

    @ReadonlyAttribute
    public var attributeName: String?

    @ReadonlyAttribute
    public var attributeNamespace: String?

    @ReadonlyAttribute
    public var oldValue: String?
}

public class NamedNodeMap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.NamedNodeMap].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Attr? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(index: UInt32) -> Attr? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> Attr? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func getNamedItem(qualifiedName: String) -> Attr? {
        let this = jsObject
        return this[.getNamedItem].function!(this: this, arguments: [_toJSValue(qualifiedName)]).fromJSValue()
    }

    @inlinable public func getNamedItemNS(namespace: String?, localName: String) -> Attr? {
        let this = jsObject
        return this[.getNamedItemNS].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(localName)]).fromJSValue()
    }

    @inlinable public func setNamedItem(attr: Attr) -> Attr? {
        let this = jsObject
        return this[.setNamedItem].function!(this: this, arguments: [_toJSValue(attr)]).fromJSValue()
    }

    @inlinable public func setNamedItemNS(attr: Attr) -> Attr? {
        let this = jsObject
        return this[.setNamedItemNS].function!(this: this, arguments: [_toJSValue(attr)]).fromJSValue()
    }

    @inlinable public func removeNamedItem(qualifiedName: String) -> Attr {
        let this = jsObject
        return this[.removeNamedItem].function!(this: this, arguments: [_toJSValue(qualifiedName)]).fromJSValue()!
    }

    @inlinable public func removeNamedItemNS(namespace: String?, localName: String) -> Attr {
        let this = jsObject
        return this[.removeNamedItemNS].function!(this: this, arguments: [_toJSValue(namespace), _toJSValue(localName)]).fromJSValue()!
    }
}

public class NavigateEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.NavigateEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _navigationType = ReadonlyAttribute(jsObject: jsObject, name: .navigationType)
        _destination = ReadonlyAttribute(jsObject: jsObject, name: .destination)
        _canIntercept = ReadonlyAttribute(jsObject: jsObject, name: .canIntercept)
        _userInitiated = ReadonlyAttribute(jsObject: jsObject, name: .userInitiated)
        _hashChange = ReadonlyAttribute(jsObject: jsObject, name: .hashChange)
        _signal = ReadonlyAttribute(jsObject: jsObject, name: .signal)
        _formData = ReadonlyAttribute(jsObject: jsObject, name: .formData)
        _downloadRequest = ReadonlyAttribute(jsObject: jsObject, name: .downloadRequest)
        _info = ReadonlyAttribute(jsObject: jsObject, name: .info)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: NavigateEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var navigationType: NavigationType

    @ReadonlyAttribute
    public var destination: NavigationDestination

    @ReadonlyAttribute
    public var canIntercept: Bool

    @ReadonlyAttribute
    public var userInitiated: Bool

    @ReadonlyAttribute
    public var hashChange: Bool

    @ReadonlyAttribute
    public var signal: AbortSignal

    @ReadonlyAttribute
    public var formData: FormData?

    @ReadonlyAttribute
    public var downloadRequest: String?

    @ReadonlyAttribute
    public var info: JSValue

    @inlinable public func intercept(options: NavigationInterceptOptions? = nil) {
        let this = jsObject
        _ = this[.intercept].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable public func scroll() {
        let this = jsObject
        _ = this[.scroll].function!(this: this, arguments: [])
    }
}

public class NavigateEventInit: BridgedDictionary {
    public convenience init(navigationType: NavigationType, destination: NavigationDestination, canIntercept: Bool, userInitiated: Bool, hashChange: Bool, signal: AbortSignal, formData: FormData?, downloadRequest: String?, info: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        object[.navigationType] = _toJSValue(navigationType)
        object[.destination] = _toJSValue(destination)
        object[.canIntercept] = _toJSValue(canIntercept)
        object[.userInitiated] = _toJSValue(userInitiated)
        object[.hashChange] = _toJSValue(hashChange)
        object[.signal] = _toJSValue(signal)
        object[.formData] = _toJSValue(formData)
        object[.downloadRequest] = _toJSValue(downloadRequest)
        object[.info] = _toJSValue(info)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _navigationType = ReadWriteAttribute(jsObject: object, name: .navigationType)
        _destination = ReadWriteAttribute(jsObject: object, name: .destination)
        _canIntercept = ReadWriteAttribute(jsObject: object, name: .canIntercept)
        _userInitiated = ReadWriteAttribute(jsObject: object, name: .userInitiated)
        _hashChange = ReadWriteAttribute(jsObject: object, name: .hashChange)
        _signal = ReadWriteAttribute(jsObject: object, name: .signal)
        _formData = ReadWriteAttribute(jsObject: object, name: .formData)
        _downloadRequest = ReadWriteAttribute(jsObject: object, name: .downloadRequest)
        _info = ReadWriteAttribute(jsObject: object, name: .info)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var navigationType: NavigationType

    @ReadWriteAttribute
    public var destination: NavigationDestination

    @ReadWriteAttribute
    public var canIntercept: Bool

    @ReadWriteAttribute
    public var userInitiated: Bool

    @ReadWriteAttribute
    public var hashChange: Bool

    @ReadWriteAttribute
    public var signal: AbortSignal

    @ReadWriteAttribute
    public var formData: FormData?

    @ReadWriteAttribute
    public var downloadRequest: String?

    @ReadWriteAttribute
    public var info: JSValue
}

public class Navigation: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.Navigation].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _currentEntry = ReadonlyAttribute(jsObject: jsObject, name: .currentEntry)
        _transition = ReadonlyAttribute(jsObject: jsObject, name: .transition)
        _canGoBack = ReadonlyAttribute(jsObject: jsObject, name: .canGoBack)
        _canGoForward = ReadonlyAttribute(jsObject: jsObject, name: .canGoForward)
        _onnavigate = ClosureAttribute1Optional(jsObject: jsObject, name: .onnavigate)
        _onnavigatesuccess = ClosureAttribute1Optional(jsObject: jsObject, name: .onnavigatesuccess)
        _onnavigateerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onnavigateerror)
        _oncurrententrychange = ClosureAttribute1Optional(jsObject: jsObject, name: .oncurrententrychange)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func entries() -> [NavigationHistoryEntry] {
        let this = jsObject
        return this[.entries].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var currentEntry: NavigationHistoryEntry?

    @inlinable public func updateCurrentEntry(options: NavigationUpdateCurrentEntryOptions) {
        let this = jsObject
        _ = this[.updateCurrentEntry].function!(this: this, arguments: [_toJSValue(options)])
    }

    @ReadonlyAttribute
    public var transition: NavigationTransition?

    @ReadonlyAttribute
    public var canGoBack: Bool

    @ReadonlyAttribute
    public var canGoForward: Bool

    @inlinable public func navigate(url: String, options: NavigationNavigateOptions? = nil) -> NavigationResult {
        let this = jsObject
        return this[.navigate].function!(this: this, arguments: [_toJSValue(url), _toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func reload(options: NavigationReloadOptions? = nil) -> NavigationResult {
        let this = jsObject
        return this[.reload].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func traverseTo(key: String, options: NavigationOptions? = nil) -> NavigationResult {
        let this = jsObject
        return this[.traverseTo].function!(this: this, arguments: [_toJSValue(key), _toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func back(options: NavigationOptions? = nil) -> NavigationResult {
        let this = jsObject
        return this[.back].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func forward(options: NavigationOptions? = nil) -> NavigationResult {
        let this = jsObject
        return this[.forward].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var onnavigate: EventHandler

    @ClosureAttribute1Optional
    public var onnavigatesuccess: EventHandler

    @ClosureAttribute1Optional
    public var onnavigateerror: EventHandler

    @ClosureAttribute1Optional
    public var oncurrententrychange: EventHandler
}

public class NavigationCurrentEntryChangeEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.NavigationCurrentEntryChangeEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _navigationType = ReadonlyAttribute(jsObject: jsObject, name: .navigationType)
        _from = ReadonlyAttribute(jsObject: jsObject, name: .from)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: NavigationCurrentEntryChangeEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var navigationType: NavigationType?

    @ReadonlyAttribute
    public var from: NavigationHistoryEntry
}

public class NavigationCurrentEntryChangeEventInit: BridgedDictionary {
    public convenience init(navigationType: NavigationType?, from: NavigationHistoryEntry) {
        let object = JSObject.global[.Object].function!.new()
        object[.navigationType] = _toJSValue(navigationType)
        object[.from] = _toJSValue(from)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _navigationType = ReadWriteAttribute(jsObject: object, name: .navigationType)
        _from = ReadWriteAttribute(jsObject: object, name: .from)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var navigationType: NavigationType?

    @ReadWriteAttribute
    public var from: NavigationHistoryEntry
}

public class NavigationDestination: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.NavigationDestination].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _url = ReadonlyAttribute(jsObject: jsObject, name: .url)
        _key = ReadonlyAttribute(jsObject: jsObject, name: .key)
        _id = ReadonlyAttribute(jsObject: jsObject, name: .id)
        _index = ReadonlyAttribute(jsObject: jsObject, name: .index)
        _sameDocument = ReadonlyAttribute(jsObject: jsObject, name: .sameDocument)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var key: String

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var index: Int64

    @ReadonlyAttribute
    public var sameDocument: Bool

    @inlinable public func getState() -> JSValue {
        let this = jsObject
        return this[.getState].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum NavigationFocusReset: JSString, JSValueCompatible {
    case afterTransition = "after-transition"
    case manual = "manual"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum NavigationHistoryBehavior: JSString, JSValueCompatible {
    case auto = "auto"
    case push = "push"
    case replace = "replace"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class NavigationHistoryEntry: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.NavigationHistoryEntry].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _url = ReadonlyAttribute(jsObject: jsObject, name: .url)
        _key = ReadonlyAttribute(jsObject: jsObject, name: .key)
        _id = ReadonlyAttribute(jsObject: jsObject, name: .id)
        _index = ReadonlyAttribute(jsObject: jsObject, name: .index)
        _sameDocument = ReadonlyAttribute(jsObject: jsObject, name: .sameDocument)
        _ondispose = ClosureAttribute1Optional(jsObject: jsObject, name: .ondispose)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var url: String?

    @ReadonlyAttribute
    public var key: String

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var index: Int64

    @ReadonlyAttribute
    public var sameDocument: Bool

    @inlinable public func getState() -> JSValue {
        let this = jsObject
        return this[.getState].function!(this: this, arguments: []).fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var ondispose: EventHandler
}

public class NavigationInterceptOptions: BridgedDictionary {
    public convenience init(handler: @escaping NavigationInterceptHandler, focusReset: NavigationFocusReset, scroll: NavigationScrollBehavior) {
        let object = JSObject.global[.Object].function!.new()
        ClosureAttribute0[.handler, in: object] = handler
        object[.focusReset] = _toJSValue(focusReset)
        object[.scroll] = _toJSValue(scroll)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _handler = ClosureAttribute0(jsObject: object, name: .handler)
        _focusReset = ReadWriteAttribute(jsObject: object, name: .focusReset)
        _scroll = ReadWriteAttribute(jsObject: object, name: .scroll)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute0
    public var handler: NavigationInterceptHandler

    @ReadWriteAttribute
    public var focusReset: NavigationFocusReset

    @ReadWriteAttribute
    public var scroll: NavigationScrollBehavior
}

public class NavigationNavigateOptions: BridgedDictionary {
    public convenience init(state: JSValue, history: NavigationHistoryBehavior) {
        let object = JSObject.global[.Object].function!.new()
        object[.state] = _toJSValue(state)
        object[.history] = _toJSValue(history)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _state = ReadWriteAttribute(jsObject: object, name: .state)
        _history = ReadWriteAttribute(jsObject: object, name: .history)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var state: JSValue

    @ReadWriteAttribute
    public var history: NavigationHistoryBehavior
}

public class NavigationOptions: BridgedDictionary {
    public convenience init(info: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        object[.info] = _toJSValue(info)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _info = ReadWriteAttribute(jsObject: object, name: .info)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var info: JSValue
}

public class NavigationPreloadManager: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.NavigationPreloadManager].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func enable() -> JSPromise {
        let this = jsObject
        return this[.enable].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func enable() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.enable].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func disable() -> JSPromise {
        let this = jsObject
        return this[.disable].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func disable() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.disable].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func setHeaderValue(value: String) -> JSPromise {
        let this = jsObject
        return this[.setHeaderValue].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func setHeaderValue(value: String) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.setHeaderValue].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func getState() -> JSPromise {
        let this = jsObject
        return this[.getState].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getState() async throws -> NavigationPreloadState {
        let this = jsObject
        let _promise: JSPromise = this[.getState].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class NavigationPreloadState: BridgedDictionary {
    public convenience init(enabled: Bool, headerValue: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.enabled] = _toJSValue(enabled)
        object[.headerValue] = _toJSValue(headerValue)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _enabled = ReadWriteAttribute(jsObject: object, name: .enabled)
        _headerValue = ReadWriteAttribute(jsObject: object, name: .headerValue)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var enabled: Bool

    @ReadWriteAttribute
    public var headerValue: String
}

public class NavigationReloadOptions: BridgedDictionary {
    public convenience init(state: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        object[.state] = _toJSValue(state)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _state = ReadWriteAttribute(jsObject: object, name: .state)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var state: JSValue
}

public class NavigationResult: BridgedDictionary {
    public convenience init(committed: JSPromise, finished: JSPromise) {
        let object = JSObject.global[.Object].function!.new()
        object[.committed] = _toJSValue(committed)
        object[.finished] = _toJSValue(finished)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _committed = ReadWriteAttribute(jsObject: object, name: .committed)
        _finished = ReadWriteAttribute(jsObject: object, name: .finished)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var committed: JSPromise

    @ReadWriteAttribute
    public var finished: JSPromise
}

public enum NavigationScrollBehavior: JSString, JSValueCompatible {
    case afterTransition = "after-transition"
    case manual = "manual"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class NavigationTransition: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.NavigationTransition].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _navigationType = ReadonlyAttribute(jsObject: jsObject, name: .navigationType)
        _from = ReadonlyAttribute(jsObject: jsObject, name: .from)
        _finished = ReadonlyAttribute(jsObject: jsObject, name: .finished)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var navigationType: NavigationType

    @ReadonlyAttribute
    public var from: NavigationHistoryEntry

    @ReadonlyAttribute
    public var finished: JSPromise
}

public enum NavigationType: JSString, JSValueCompatible {
    case push = "push"
    case replace = "replace"
    case reload = "reload"
    case traverse = "traverse"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class NavigationUpdateCurrentEntryOptions: BridgedDictionary {
    public convenience init(state: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        object[.state] = _toJSValue(state)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _state = ReadWriteAttribute(jsObject: object, name: .state)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var state: JSValue
}

public class Navigator: JSBridgedClass, NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorContentUtils, NavigatorCookies, NavigatorPlugins, NavigatorConcurrentHardware {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Navigator].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _userActivation = ReadonlyAttribute(jsObject: jsObject, name: .userActivation)
        _mediaDevices = ReadonlyAttribute(jsObject: jsObject, name: .mediaDevices)
        _serviceWorker = ReadonlyAttribute(jsObject: jsObject, name: .serviceWorker)
        _permissions = ReadonlyAttribute(jsObject: jsObject, name: .permissions)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var userActivation: UserActivation

    @ReadonlyAttribute
    public var mediaDevices: MediaDevices

    @inlinable public func getUserMedia(constraints: MediaStreamConstraints, successCallback: @escaping NavigatorUserMediaSuccessCallback, errorCallback: @escaping NavigatorUserMediaErrorCallback) {
        let this = jsObject
        _ = this[.getUserMedia].function!(this: this, arguments: [_toJSValue(constraints), _toJSValue(successCallback), _toJSValue(errorCallback)])
    }

    @ReadonlyAttribute
    public var serviceWorker: ServiceWorkerContainer

    @ReadonlyAttribute
    public var permissions: Permissions
}

public protocol NavigatorConcurrentHardware: JSBridgedClass {}
public extension NavigatorConcurrentHardware {
    @inlinable var hardwareConcurrency: UInt64 { jsObject[.hardwareConcurrency].fromJSValue()! }
}

public protocol NavigatorContentUtils: JSBridgedClass {}
public extension NavigatorContentUtils {
    @inlinable func registerProtocolHandler(scheme: String, url: String) {
        let this = jsObject
        _ = this[.registerProtocolHandler].function!(this: this, arguments: [_toJSValue(scheme), _toJSValue(url)])
    }

    @inlinable func unregisterProtocolHandler(scheme: String, url: String) {
        let this = jsObject
        _ = this[.unregisterProtocolHandler].function!(this: this, arguments: [_toJSValue(scheme), _toJSValue(url)])
    }
}

public protocol NavigatorCookies: JSBridgedClass {}
public extension NavigatorCookies {
    @inlinable var cookieEnabled: Bool { jsObject[.cookieEnabled].fromJSValue()! }
}

public protocol NavigatorID: JSBridgedClass {}
public extension NavigatorID {
    @inlinable var appCodeName: String { jsObject[.appCodeName].fromJSValue()! }

    @inlinable var appName: String { jsObject[.appName].fromJSValue()! }

    @inlinable var appVersion: String { jsObject[.appVersion].fromJSValue()! }

    @inlinable var platform: String { jsObject[.platform].fromJSValue()! }

    @inlinable var product: String { jsObject[.product].fromJSValue()! }

    @inlinable var productSub: String { jsObject[.productSub].fromJSValue()! }

    @inlinable var userAgent: String { jsObject[.userAgent].fromJSValue()! }

    @inlinable var vendor: String { jsObject[.vendor].fromJSValue()! }

    @inlinable var vendorSub: String { jsObject[.vendorSub].fromJSValue()! }

    @inlinable func taintEnabled() -> Bool {
        let this = jsObject
        return this[.taintEnabled].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable var oscpu: String { jsObject[.oscpu].fromJSValue()! }
}

public protocol NavigatorLanguage: JSBridgedClass {}
public extension NavigatorLanguage {
    @inlinable var language: String { jsObject[.language].fromJSValue()! }

    @inlinable var languages: [String] { jsObject[.languages].fromJSValue()! }
}

public protocol NavigatorOnLine: JSBridgedClass {}
public extension NavigatorOnLine {
    @inlinable var onLine: Bool { jsObject[.onLine].fromJSValue()! }
}

public protocol NavigatorPlugins: JSBridgedClass {}
public extension NavigatorPlugins {
    @inlinable var plugins: PluginArray { jsObject[.plugins].fromJSValue()! }

    @inlinable var mimeTypes: MimeTypeArray { jsObject[.mimeTypes].fromJSValue()! }

    @inlinable func javaEnabled() -> Bool {
        let this = jsObject
        return this[.javaEnabled].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable var pdfViewerEnabled: Bool { jsObject[.pdfViewerEnabled].fromJSValue()! }
}

open class Node: EventTarget {
    @inlinable override open class var constructor: JSFunction? { JSObject.global[.Node].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _nodeType = ReadonlyAttribute(jsObject: jsObject, name: .nodeType)
        _nodeName = ReadonlyAttribute(jsObject: jsObject, name: .nodeName)
        _baseURI = ReadonlyAttribute(jsObject: jsObject, name: .baseURI)
        _isConnected = ReadonlyAttribute(jsObject: jsObject, name: .isConnected)
        _ownerDocument = ReadonlyAttribute(jsObject: jsObject, name: .ownerDocument)
        _parentNode = ReadonlyAttribute(jsObject: jsObject, name: .parentNode)
        _parentElement = ReadonlyAttribute(jsObject: jsObject, name: .parentElement)
        _childNodes = ReadonlyAttribute(jsObject: jsObject, name: .childNodes)
        _firstChild = ReadonlyAttribute(jsObject: jsObject, name: .firstChild)
        _lastChild = ReadonlyAttribute(jsObject: jsObject, name: .lastChild)
        _previousSibling = ReadonlyAttribute(jsObject: jsObject, name: .previousSibling)
        _nextSibling = ReadonlyAttribute(jsObject: jsObject, name: .nextSibling)
        _nodeValue = ReadWriteAttribute(jsObject: jsObject, name: .nodeValue)
        _textContent = ReadWriteAttribute(jsObject: jsObject, name: .textContent)
        super.init(unsafelyWrapping: jsObject)
    }

    public static let ELEMENT_NODE: UInt16 = 1

    public static let ATTRIBUTE_NODE: UInt16 = 2

    public static let TEXT_NODE: UInt16 = 3

    public static let CDATA_SECTION_NODE: UInt16 = 4

    public static let ENTITY_REFERENCE_NODE: UInt16 = 5

    public static let ENTITY_NODE: UInt16 = 6

    public static let PROCESSING_INSTRUCTION_NODE: UInt16 = 7

    public static let COMMENT_NODE: UInt16 = 8

    public static let DOCUMENT_NODE: UInt16 = 9

    public static let DOCUMENT_TYPE_NODE: UInt16 = 10

    public static let DOCUMENT_FRAGMENT_NODE: UInt16 = 11

    public static let NOTATION_NODE: UInt16 = 12

    @ReadonlyAttribute
    public var nodeType: UInt16

    @ReadonlyAttribute
    public var nodeName: String

    @ReadonlyAttribute
    public var baseURI: String

    @ReadonlyAttribute
    public var isConnected: Bool

    @ReadonlyAttribute
    public var ownerDocument: Document?

    @inlinable public func getRootNode(options: GetRootNodeOptions? = nil) -> Self {
        let this = jsObject
        return this[.getRootNode].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var parentNode: Node?

    @ReadonlyAttribute
    public var parentElement: Element?

    @inlinable public func hasChildNodes() -> Bool {
        let this = jsObject
        return this[.hasChildNodes].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var childNodes: NodeList

    @ReadonlyAttribute
    public var firstChild: Node?

    @ReadonlyAttribute
    public var lastChild: Node?

    @ReadonlyAttribute
    public var previousSibling: Node?

    @ReadonlyAttribute
    public var nextSibling: Node?

    @ReadWriteAttribute
    public var nodeValue: String?

    @ReadWriteAttribute
    public var textContent: String?

    @inlinable public func normalize() {
        let this = jsObject
        _ = this[.normalize].function!(this: this, arguments: [])
    }

    @inlinable public func cloneNode(deep: Bool? = nil) -> Self {
        let this = jsObject
        return this[.cloneNode].function!(this: this, arguments: [_toJSValue(deep)]).fromJSValue()!
    }

    @inlinable public func isEqualNode(otherNode: Node?) -> Bool {
        let this = jsObject
        return this[.isEqualNode].function!(this: this, arguments: [_toJSValue(otherNode)]).fromJSValue()!
    }

    @inlinable public func isSameNode(otherNode: Node?) -> Bool {
        let this = jsObject
        return this[.isSameNode].function!(this: this, arguments: [_toJSValue(otherNode)]).fromJSValue()!
    }

    public static let DOCUMENT_POSITION_DISCONNECTED: UInt16 = 0x01

    public static let DOCUMENT_POSITION_PRECEDING: UInt16 = 0x02

    public static let DOCUMENT_POSITION_FOLLOWING: UInt16 = 0x04

    public static let DOCUMENT_POSITION_CONTAINS: UInt16 = 0x08

    public static let DOCUMENT_POSITION_CONTAINED_BY: UInt16 = 0x10

    public static let DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: UInt16 = 0x20

    @inlinable public func compareDocumentPosition(other: Node) -> UInt16 {
        let this = jsObject
        return this[.compareDocumentPosition].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public func contains(other: Node?) -> Bool {
        let this = jsObject
        return this[.contains].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public func lookupPrefix(namespace: String?) -> String? {
        let this = jsObject
        return this[.lookupPrefix].function!(this: this, arguments: [_toJSValue(namespace)]).fromJSValue()
    }

    @inlinable public func lookupNamespaceURI(prefix: String?) -> String? {
        let this = jsObject
        return this[.lookupNamespaceURI].function!(this: this, arguments: [_toJSValue(prefix)]).fromJSValue()
    }

    @inlinable public func isDefaultNamespace(namespace: String?) -> Bool {
        let this = jsObject
        return this[.isDefaultNamespace].function!(this: this, arguments: [_toJSValue(namespace)]).fromJSValue()!
    }

    @inlinable public func insertBefore(node: Node, child: Node?) -> Self {
        let this = jsObject
        return this[.insertBefore].function!(this: this, arguments: [_toJSValue(node), _toJSValue(child)]).fromJSValue()!
    }

    @inlinable public func appendChild(node: Node) -> Self {
        let this = jsObject
        return this[.appendChild].function!(this: this, arguments: [_toJSValue(node)]).fromJSValue()!
    }

    @inlinable public func replaceChild(node: Node, child: Node) -> Self {
        let this = jsObject
        return this[.replaceChild].function!(this: this, arguments: [_toJSValue(node), _toJSValue(child)]).fromJSValue()!
    }

    @inlinable public func removeChild(child: Node) -> Self {
        let this = jsObject
        return this[.removeChild].function!(this: this, arguments: [_toJSValue(child)]).fromJSValue()!
    }
}

public class NodeIterator: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.NodeIterator].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _root = ReadonlyAttribute(jsObject: jsObject, name: .root)
        _referenceNode = ReadonlyAttribute(jsObject: jsObject, name: .referenceNode)
        _pointerBeforeReferenceNode = ReadonlyAttribute(jsObject: jsObject, name: .pointerBeforeReferenceNode)
        _whatToShow = ReadonlyAttribute(jsObject: jsObject, name: .whatToShow)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var root: Node

    @ReadonlyAttribute
    public var referenceNode: Node

    @ReadonlyAttribute
    public var pointerBeforeReferenceNode: Bool

    @ReadonlyAttribute
    public var whatToShow: UInt32

    // XXX: member 'filter' is ignored

    @inlinable public func nextNode() -> Node? {
        let this = jsObject
        return this[.nextNode].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public func previousNode() -> Node? {
        let this = jsObject
        return this[.previousNode].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public func detach() {
        let this = jsObject
        _ = this[.detach].function!(this: this, arguments: [])
    }
}

public class NodeList: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.NodeList].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @inlinable public subscript(key: Int) -> Node? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(index: UInt32) -> Node? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @ReadonlyAttribute
    public var length: UInt32

    public typealias Element = Node
    public func makeIterator() -> ValueIterableIterator<NodeList> {
        ValueIterableIterator(sequence: self)
    }
}

public protocol NonDocumentTypeChildNode: JSBridgedClass {}
public extension NonDocumentTypeChildNode {
    @inlinable var previousElementSibling: Element? { jsObject[.previousElementSibling].fromJSValue() }

    @inlinable var nextElementSibling: Element? { jsObject[.nextElementSibling].fromJSValue() }
}

public protocol NonElementParentNode: JSBridgedClass {}
public extension NonElementParentNode {
    @inlinable func getElementById(elementId: String) -> Element? {
        let this = jsObject
        return this[.getElementById].function!(this: this, arguments: [_toJSValue(elementId)]).fromJSValue()
    }
}

public class OffscreenCanvas: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.OffscreenCanvas].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadWriteAttribute(jsObject: jsObject, name: .width)
        _height = ReadWriteAttribute(jsObject: jsObject, name: .height)
        _oncontextlost = ClosureAttribute1Optional(jsObject: jsObject, name: .oncontextlost)
        _oncontextrestored = ClosureAttribute1Optional(jsObject: jsObject, name: .oncontextrestored)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(width: UInt64, height: UInt64) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(width), _toJSValue(height)]))
    }

    @ReadWriteAttribute
    public var width: UInt64

    @ReadWriteAttribute
    public var height: UInt64

    // XXX: member 'getContext' is ignored

    @inlinable public func transferToImageBitmap() -> ImageBitmap {
        let this = jsObject
        return this[.transferToImageBitmap].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func convertToBlob(options: ImageEncodeOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.convertToBlob].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func convertToBlob(options: ImageEncodeOptions? = nil) async throws -> Blob {
        let this = jsObject
        let _promise: JSPromise = this[.convertToBlob].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var oncontextlost: EventHandler

    @ClosureAttribute1Optional
    public var oncontextrestored: EventHandler
}



public class OverconstrainedError: DOMException {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.OverconstrainedError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _constraint = ReadonlyAttribute(jsObject: jsObject, name: .constraint)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(constraint: String, message: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(constraint), _toJSValue(message)]))
    }

    @ReadonlyAttribute
    public var constraint: String
}

public class PageTransitionEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.PageTransitionEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _persisted = ReadonlyAttribute(jsObject: jsObject, name: .persisted)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: PageTransitionEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var persisted: Bool
}

public class PageTransitionEventInit: BridgedDictionary {
    public convenience init(persisted: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.persisted] = _toJSValue(persisted)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _persisted = ReadWriteAttribute(jsObject: object, name: .persisted)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var persisted: Bool
}

public protocol ParentNode: JSBridgedClass {}
public extension ParentNode {
    @inlinable var children: HTMLCollection { jsObject[.children].fromJSValue()! }

    @inlinable var firstElementChild: Element? { jsObject[.firstElementChild].fromJSValue() }

    @inlinable var lastElementChild: Element? { jsObject[.lastElementChild].fromJSValue() }

    @inlinable var childElementCount: UInt32 { jsObject[.childElementCount].fromJSValue()! }

    @inlinable func prepend(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[.prepend].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable func append(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[.append].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable func replaceChildren(nodes: Node_or_String...) {
        let this = jsObject
        _ = this[.replaceChildren].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable func querySelector(selectors: String) -> Element? {
        let this = jsObject
        return this[.querySelector].function!(this: this, arguments: [_toJSValue(selectors)]).fromJSValue()
    }

    @inlinable func querySelectorAll(selectors: String) -> NodeList {
        let this = jsObject
        return this[.querySelectorAll].function!(this: this, arguments: [_toJSValue(selectors)]).fromJSValue()!
    }
}

public class Path2D: JSBridgedClass, CanvasPath {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Path2D].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(path: Path2D_or_String? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(path)]))
    }

    @inlinable public func addPath(path: Path2D, transform: DOMMatrix2DInit? = nil) {
        let this = jsObject
        _ = this[.addPath].function!(this: this, arguments: [_toJSValue(path), _toJSValue(transform)])
    }
}

public class Performance: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.Performance].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _timeOrigin = ReadonlyAttribute(jsObject: jsObject, name: .timeOrigin)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public func now() -> DOMHighResTimeStamp {
        let this = jsObject
        return this[.now].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var timeOrigin: DOMHighResTimeStamp

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getEntries() -> PerformanceEntryList {
        let this = jsObject
        return this[.getEntries].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getEntriesByType(type: String) -> PerformanceEntryList {
        let this = jsObject
        return this[.getEntriesByType].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    @inlinable public func getEntriesByName(name: String, type: String? = nil) -> PerformanceEntryList {
        let this = jsObject
        return this[.getEntriesByName].function!(this: this, arguments: [_toJSValue(name), _toJSValue(type)]).fromJSValue()!
    }
}

public class PerformanceEntry: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.PerformanceEntry].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: .name)
        _entryType = ReadonlyAttribute(jsObject: jsObject, name: .entryType)
        _startTime = ReadonlyAttribute(jsObject: jsObject, name: .startTime)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: .duration)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var entryType: String

    @ReadonlyAttribute
    public var startTime: DOMHighResTimeStamp

    @ReadonlyAttribute
    public var duration: DOMHighResTimeStamp

    @inlinable public func toJSON() -> JSObject {
        let this = jsObject
        return this[.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class PerformanceObserver: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.PerformanceObserver].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _supportedEntryTypes = ReadonlyAttribute(jsObject: jsObject, name: .supportedEntryTypes)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(callback: @escaping PerformanceObserverCallback) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(callback)]))
    }

    @inlinable public func observe(options: PerformanceObserverInit? = nil) {
        let this = jsObject
        _ = this[.observe].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable public func disconnect() {
        let this = jsObject
        _ = this[.disconnect].function!(this: this, arguments: [])
    }

    @inlinable public func takeRecords() -> PerformanceEntryList {
        let this = jsObject
        return this[.takeRecords].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var supportedEntryTypes: [String]
}

public class PerformanceObserverCallbackOptions: BridgedDictionary {
    public convenience init(droppedEntriesCount: UInt64) {
        let object = JSObject.global[.Object].function!.new()
        object[.droppedEntriesCount] = _toJSValue(droppedEntriesCount)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _droppedEntriesCount = ReadWriteAttribute(jsObject: object, name: .droppedEntriesCount)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var droppedEntriesCount: UInt64
}

public class PerformanceObserverEntryList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.PerformanceObserverEntryList].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func getEntries() -> PerformanceEntryList {
        let this = jsObject
        return this[.getEntries].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getEntriesByType(type: String) -> PerformanceEntryList {
        let this = jsObject
        return this[.getEntriesByType].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    @inlinable public func getEntriesByName(name: String, type: String? = nil) -> PerformanceEntryList {
        let this = jsObject
        return this[.getEntriesByName].function!(this: this, arguments: [_toJSValue(name), _toJSValue(type)]).fromJSValue()!
    }
}

public class PerformanceObserverInit: BridgedDictionary {
    public convenience init(entryTypes: [String], type: String, buffered: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.entryTypes] = _toJSValue(entryTypes)
        object[.type] = _toJSValue(type)
        object[.buffered] = _toJSValue(buffered)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _entryTypes = ReadWriteAttribute(jsObject: object, name: .entryTypes)
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        _buffered = ReadWriteAttribute(jsObject: object, name: .buffered)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var entryTypes: [String]

    @ReadWriteAttribute
    public var type: String

    @ReadWriteAttribute
    public var buffered: Bool
}

public class PermissionDescriptor: BridgedDictionary {
    public convenience init(name: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.name] = _toJSValue(name)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _name = ReadWriteAttribute(jsObject: object, name: .name)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var name: String
}

public class PermissionSetParameters: BridgedDictionary {
    public convenience init(descriptor: PermissionDescriptor, state: PermissionState) {
        let object = JSObject.global[.Object].function!.new()
        object[.descriptor] = _toJSValue(descriptor)
        object[.state] = _toJSValue(state)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _descriptor = ReadWriteAttribute(jsObject: object, name: .descriptor)
        _state = ReadWriteAttribute(jsObject: object, name: .state)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var descriptor: PermissionDescriptor

    @ReadWriteAttribute
    public var state: PermissionState
}

public enum PermissionState: JSString, JSValueCompatible {
    case granted = "granted"
    case denied = "denied"
    case prompt = "prompt"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class PermissionStatus: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.PermissionStatus].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: .state)
        _name = ReadonlyAttribute(jsObject: jsObject, name: .name)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: .onchange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var state: PermissionState

    @ReadonlyAttribute
    public var name: String

    @ClosureAttribute1Optional
    public var onchange: EventHandler
}

public class Permissions: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Permissions].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func query(permissionDesc: JSObject) -> JSPromise {
        let this = jsObject
        return this[.query].function!(this: this, arguments: [_toJSValue(permissionDesc)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func query(permissionDesc: JSObject) async throws -> PermissionStatus {
        let this = jsObject
        let _promise: JSPromise = this[.query].function!(this: this, arguments: [_toJSValue(permissionDesc)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class PlaneLayout: BridgedDictionary {
    public convenience init(offset: UInt32, stride: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.offset] = _toJSValue(offset)
        object[.stride] = _toJSValue(stride)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: .offset)
        _stride = ReadWriteAttribute(jsObject: object, name: .stride)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: UInt32

    @ReadWriteAttribute
    public var stride: UInt32
}

public class Plugin: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Plugin].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: .name)
        _description = ReadonlyAttribute(jsObject: jsObject, name: .description)
        _filename = ReadonlyAttribute(jsObject: jsObject, name: .filename)
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var name: String

    @ReadonlyAttribute
    public var description: String

    @ReadonlyAttribute
    public var filename: String

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> MimeType? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(index: UInt32) -> MimeType? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> MimeType? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func namedItem(name: String) -> MimeType? {
        let this = jsObject
        return this[.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public class PluginArray: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.PluginArray].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @inlinable public func refresh() {
        let this = jsObject
        _ = this[.refresh].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Plugin? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(index: UInt32) -> Plugin? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> Plugin? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func namedItem(name: String) -> Plugin? {
        let this = jsObject
        return this[.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public class PopStateEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.PopStateEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: .state)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: PopStateEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var state: JSValue
}

public class PopStateEventInit: BridgedDictionary {
    public convenience init(state: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        object[.state] = _toJSValue(state)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _state = ReadWriteAttribute(jsObject: object, name: .state)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var state: JSValue
}

public protocol PopoverInvokerElement: JSBridgedClass {}
public extension PopoverInvokerElement {
    @inlinable var popoverTargetElement: Element? {
        get { jsObject[.popoverTargetElement].fromJSValue() }
        nonmutating set { jsObject[.popoverTargetElement] = _toJSValue(newValue) }
    }

    @inlinable var popoverTargetAction: String {
        get { jsObject[.popoverTargetAction].fromJSValue()! }
        nonmutating set { jsObject[.popoverTargetAction] = _toJSValue(newValue) }
    }
}

public enum PredefinedColorSpace: JSString, JSValueCompatible {
    case srgb = "srgb"
    case displayP3 = "display-p3"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum PremultiplyAlpha: JSString, JSValueCompatible {
    case none = "none"
    case premultiply = "premultiply"
    case `default` = "default"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ProcessingInstruction: CharacterData {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ProcessingInstruction].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _target = ReadonlyAttribute(jsObject: jsObject, name: .target)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var target: String
}

public class ProgressEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ProgressEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _lengthComputable = ReadonlyAttribute(jsObject: jsObject, name: .lengthComputable)
        _loaded = ReadonlyAttribute(jsObject: jsObject, name: .loaded)
        _total = ReadonlyAttribute(jsObject: jsObject, name: .total)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: ProgressEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var lengthComputable: Bool

    @ReadonlyAttribute
    public var loaded: UInt64

    @ReadonlyAttribute
    public var total: UInt64
}

public class ProgressEventInit: BridgedDictionary {
    public convenience init(lengthComputable: Bool, loaded: UInt64, total: UInt64) {
        let object = JSObject.global[.Object].function!.new()
        object[.lengthComputable] = _toJSValue(lengthComputable)
        object[.loaded] = _toJSValue(loaded)
        object[.total] = _toJSValue(total)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _lengthComputable = ReadWriteAttribute(jsObject: object, name: .lengthComputable)
        _loaded = ReadWriteAttribute(jsObject: object, name: .loaded)
        _total = ReadWriteAttribute(jsObject: object, name: .total)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var lengthComputable: Bool

    @ReadWriteAttribute
    public var loaded: UInt64

    @ReadWriteAttribute
    public var total: UInt64
}

public class PromiseRejectionEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.PromiseRejectionEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _promise = ReadonlyAttribute(jsObject: jsObject, name: .promise)
        _reason = ReadonlyAttribute(jsObject: jsObject, name: .reason)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: PromiseRejectionEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var promise: JSPromise

    @ReadonlyAttribute
    public var reason: JSValue
}

public class PromiseRejectionEventInit: BridgedDictionary {
    public convenience init(promise: JSPromise, reason: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        object[.promise] = _toJSValue(promise)
        object[.reason] = _toJSValue(reason)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _promise = ReadWriteAttribute(jsObject: object, name: .promise)
        _reason = ReadWriteAttribute(jsObject: object, name: .reason)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var promise: JSPromise

    @ReadWriteAttribute
    public var reason: JSValue
}

public class QueuingStrategy: BridgedDictionary {
    public convenience init(highWaterMark: Double, size: @escaping QueuingStrategySize) {
        let object = JSObject.global[.Object].function!.new()
        object[.highWaterMark] = _toJSValue(highWaterMark)
        ClosureAttribute1[.size, in: object] = size
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _highWaterMark = ReadWriteAttribute(jsObject: object, name: .highWaterMark)
        _size = ClosureAttribute1(jsObject: object, name: .size)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var highWaterMark: Double

    @ClosureAttribute1
    public var size: QueuingStrategySize
}

public class QueuingStrategyInit: BridgedDictionary {
    public convenience init(highWaterMark: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.highWaterMark] = _toJSValue(highWaterMark)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _highWaterMark = ReadWriteAttribute(jsObject: object, name: .highWaterMark)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var highWaterMark: Double
}

public class RadioNodeList: NodeList {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.RadioNodeList].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _value = ReadWriteAttribute(jsObject: jsObject, name: .value)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadWriteAttribute
    public var value: String
}

public class Range: AbstractRange {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.Range].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _commonAncestorContainer = ReadonlyAttribute(jsObject: jsObject, name: .commonAncestorContainer)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ReadonlyAttribute
    public var commonAncestorContainer: Node

    @inlinable public func setStart(node: Node, offset: UInt32) {
        let this = jsObject
        _ = this[.setStart].function!(this: this, arguments: [_toJSValue(node), _toJSValue(offset)])
    }

    @inlinable public func setEnd(node: Node, offset: UInt32) {
        let this = jsObject
        _ = this[.setEnd].function!(this: this, arguments: [_toJSValue(node), _toJSValue(offset)])
    }

    @inlinable public func setStartBefore(node: Node) {
        let this = jsObject
        _ = this[.setStartBefore].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable public func setStartAfter(node: Node) {
        let this = jsObject
        _ = this[.setStartAfter].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable public func setEndBefore(node: Node) {
        let this = jsObject
        _ = this[.setEndBefore].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable public func setEndAfter(node: Node) {
        let this = jsObject
        _ = this[.setEndAfter].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable public func collapse(toStart: Bool? = nil) {
        let this = jsObject
        _ = this[.collapse].function!(this: this, arguments: [_toJSValue(toStart)])
    }

    @inlinable public func selectNode(node: Node) {
        let this = jsObject
        _ = this[.selectNode].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable public func selectNodeContents(node: Node) {
        let this = jsObject
        _ = this[.selectNodeContents].function!(this: this, arguments: [_toJSValue(node)])
    }

    public static let START_TO_START: UInt16 = 0

    public static let START_TO_END: UInt16 = 1

    public static let END_TO_END: UInt16 = 2

    public static let END_TO_START: UInt16 = 3

    @inlinable public func compareBoundaryPoints(how: UInt16, sourceRange: Range) -> Int16 {
        let this = jsObject
        return this[.compareBoundaryPoints].function!(this: this, arguments: [_toJSValue(how), _toJSValue(sourceRange)]).fromJSValue()!
    }

    @inlinable public func deleteContents() {
        let this = jsObject
        _ = this[.deleteContents].function!(this: this, arguments: [])
    }

    @inlinable public func extractContents() -> DocumentFragment {
        let this = jsObject
        return this[.extractContents].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func cloneContents() -> DocumentFragment {
        let this = jsObject
        return this[.cloneContents].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func insertNode(node: Node) {
        let this = jsObject
        _ = this[.insertNode].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable public func surroundContents(newParent: Node) {
        let this = jsObject
        _ = this[.surroundContents].function!(this: this, arguments: [_toJSValue(newParent)])
    }

    @inlinable public func cloneRange() -> Self {
        let this = jsObject
        return this[.cloneRange].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func detach() {
        let this = jsObject
        _ = this[.detach].function!(this: this, arguments: [])
    }

    @inlinable public func isPointInRange(node: Node, offset: UInt32) -> Bool {
        let this = jsObject
        return this[.isPointInRange].function!(this: this, arguments: [_toJSValue(node), _toJSValue(offset)]).fromJSValue()!
    }

    @inlinable public func comparePoint(node: Node, offset: UInt32) -> Int16 {
        let this = jsObject
        return this[.comparePoint].function!(this: this, arguments: [_toJSValue(node), _toJSValue(offset)]).fromJSValue()!
    }

    @inlinable public func intersectsNode(node: Node) -> Bool {
        let this = jsObject
        return this[.intersectsNode].function!(this: this, arguments: [_toJSValue(node)]).fromJSValue()!
    }

    @inlinable public var description: String {
        jsObject[.toString]!().fromJSValue()!
    }

    @inlinable public func getClientRects() -> DOMRectList {
        let this = jsObject
        return this[.getClientRects].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func getBoundingClientRect() -> DOMRect {
        let this = jsObject
        return this[.getBoundingClientRect].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class ReadableByteStreamController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ReadableByteStreamController].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _byobRequest = ReadonlyAttribute(jsObject: jsObject, name: .byobRequest)
        _desiredSize = ReadonlyAttribute(jsObject: jsObject, name: .desiredSize)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var byobRequest: ReadableStreamBYOBRequest?

    @ReadonlyAttribute
    public var desiredSize: Double?

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }

    @inlinable public func enqueue(chunk: ArrayBufferView) {
        let this = jsObject
        _ = this[.enqueue].function!(this: this, arguments: [_toJSValue(chunk)])
    }

    @inlinable public func error(e: JSValue? = nil) {
        let this = jsObject
        _ = this[.error].function!(this: this, arguments: [_toJSValue(e)])
    }
}

public class ReadableStream: JSBridgedClass, AsyncSequence {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ReadableStream].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _locked = ReadonlyAttribute(jsObject: jsObject, name: .locked)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(underlyingSource: JSObject? = nil, strategy: QueuingStrategy? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(underlyingSource), _toJSValue(strategy)]))
    }

    @inlinable public class func from(asyncIterable: JSValue) -> Self {
        let this = constructor!
        return this[.from].function!(this: this, arguments: [_toJSValue(asyncIterable)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var locked: Bool

    @inlinable public func cancel(reason: JSValue? = nil) -> JSPromise {
        let this = jsObject
        return this[.cancel].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func cancel(reason: JSValue? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.cancel].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func getReader(options: ReadableStreamGetReaderOptions? = nil) -> ReadableStreamReader {
        let this = jsObject
        return this[.getReader].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func pipeThrough(transform: ReadableWritablePair, options: StreamPipeOptions? = nil) -> Self {
        let this = jsObject
        return this[.pipeThrough].function!(this: this, arguments: [_toJSValue(transform), _toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func pipeTo(destination: WritableStream, options: StreamPipeOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.pipeTo].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func pipeTo(destination: WritableStream, options: StreamPipeOptions? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.pipeTo].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(options)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func tee() -> [ReadableStream] {
        let this = jsObject
        return this[.tee].function!(this: this, arguments: []).fromJSValue()!
    }

    public typealias Element = JSValue
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func makeAsyncIterator() -> ValueIterableAsyncIterator<ReadableStream> {
        ValueIterableAsyncIterator(sequence: self)
    }
}

public class ReadableStreamBYOBReader: JSBridgedClass, ReadableStreamGenericReader {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ReadableStreamBYOBReader].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(stream: ReadableStream) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(stream)]))
    }

    @inlinable public func read(view: ArrayBufferView) -> JSPromise {
        let this = jsObject
        return this[.read].function!(this: this, arguments: [_toJSValue(view)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func read(view: ArrayBufferView) async throws -> ReadableStreamReadResult {
        let this = jsObject
        let _promise: JSPromise = this[.read].function!(this: this, arguments: [_toJSValue(view)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func releaseLock() {
        let this = jsObject
        _ = this[.releaseLock].function!(this: this, arguments: [])
    }
}

public class ReadableStreamBYOBRequest: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ReadableStreamBYOBRequest].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _view = ReadonlyAttribute(jsObject: jsObject, name: .view)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var view: ArrayBufferView?

    @inlinable public func respond(bytesWritten: UInt64) {
        let this = jsObject
        _ = this[.respond].function!(this: this, arguments: [_toJSValue(bytesWritten)])
    }

    @inlinable public func respondWithNewView(view: ArrayBufferView) {
        let this = jsObject
        _ = this[.respondWithNewView].function!(this: this, arguments: [_toJSValue(view)])
    }
}

public class ReadableStreamDefaultController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ReadableStreamDefaultController].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _desiredSize = ReadonlyAttribute(jsObject: jsObject, name: .desiredSize)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var desiredSize: Double?

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }

    @inlinable public func enqueue(chunk: JSValue? = nil) {
        let this = jsObject
        _ = this[.enqueue].function!(this: this, arguments: [_toJSValue(chunk)])
    }

    @inlinable public func error(e: JSValue? = nil) {
        let this = jsObject
        _ = this[.error].function!(this: this, arguments: [_toJSValue(e)])
    }
}

public class ReadableStreamDefaultReader: JSBridgedClass, ReadableStreamGenericReader {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ReadableStreamDefaultReader].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init(stream: ReadableStream) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(stream)]))
    }

    @inlinable public func read() -> JSPromise {
        let this = jsObject
        return this[.read].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func read() async throws -> ReadableStreamReadResult {
        let this = jsObject
        let _promise: JSPromise = this[.read].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func releaseLock() {
        let this = jsObject
        _ = this[.releaseLock].function!(this: this, arguments: [])
    }
}

public protocol ReadableStreamGenericReader: JSBridgedClass {}
public extension ReadableStreamGenericReader {
    @inlinable var closed: JSPromise { jsObject[.closed].fromJSValue()! }

    @inlinable func cancel(reason: JSValue? = nil) -> JSPromise {
        let this = jsObject
        return this[.cancel].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable func cancel(reason: JSValue? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.cancel].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
        _ = try await _promise.value
    }
}

public class ReadableStreamGetReaderOptions: BridgedDictionary {
    public convenience init(mode: ReadableStreamReaderMode) {
        let object = JSObject.global[.Object].function!.new()
        object[.mode] = _toJSValue(mode)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mode = ReadWriteAttribute(jsObject: object, name: .mode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mode: ReadableStreamReaderMode
}

public class ReadableStreamIteratorOptions: BridgedDictionary {
    public convenience init(preventCancel: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.preventCancel] = _toJSValue(preventCancel)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _preventCancel = ReadWriteAttribute(jsObject: object, name: .preventCancel)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var preventCancel: Bool
}

public class ReadableStreamReadResult: BridgedDictionary {
    public convenience init(value: JSValue, done: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.value] = _toJSValue(value)
        object[.done] = _toJSValue(done)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _value = ReadWriteAttribute(jsObject: object, name: .value)
        _done = ReadWriteAttribute(jsObject: object, name: .done)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var value: JSValue

    @ReadWriteAttribute
    public var done: Bool
}

public enum ReadableStreamReaderMode: JSString, JSValueCompatible {
    case byob = "byob"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ReadableStreamType: JSString, JSValueCompatible {
    case bytes = "bytes"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ReadableWritablePair: BridgedDictionary {
    public convenience init(readable: ReadableStream, writable: WritableStream) {
        let object = JSObject.global[.Object].function!.new()
        object[.readable] = _toJSValue(readable)
        object[.writable] = _toJSValue(writable)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _readable = ReadWriteAttribute(jsObject: object, name: .readable)
        _writable = ReadWriteAttribute(jsObject: object, name: .writable)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var readable: ReadableStream

    @ReadWriteAttribute
    public var writable: WritableStream
}

public enum ReadyState: JSString, JSValueCompatible {
    case closed = "closed"
    case open = "open"
    case ended = "ended"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RecordingState: JSString, JSValueCompatible {
    case inactive = "inactive"
    case recording = "recording"
    case paused = "paused"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ReferrerPolicy: JSString, JSValueCompatible {
    case _empty = ""
    case noReferrer = "no-referrer"
    case noReferrerWhenDowngrade = "no-referrer-when-downgrade"
    case sameOrigin = "same-origin"
    case origin = "origin"
    case strictOrigin = "strict-origin"
    case originWhenCrossOrigin = "origin-when-cross-origin"
    case strictOriginWhenCrossOrigin = "strict-origin-when-cross-origin"
    case unsafeUrl = "unsafe-url"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class RegistrationOptions: BridgedDictionary {
    public convenience init(scope: String, type: WorkerType, updateViaCache: ServiceWorkerUpdateViaCache) {
        let object = JSObject.global[.Object].function!.new()
        object[.scope] = _toJSValue(scope)
        object[.type] = _toJSValue(type)
        object[.updateViaCache] = _toJSValue(updateViaCache)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _scope = ReadWriteAttribute(jsObject: object, name: .scope)
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        _updateViaCache = ReadWriteAttribute(jsObject: object, name: .updateViaCache)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var scope: String

    @ReadWriteAttribute
    public var type: WorkerType

    @ReadWriteAttribute
    public var updateViaCache: ServiceWorkerUpdateViaCache
}

public class Request: JSBridgedClass, Body {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Request].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _method = ReadonlyAttribute(jsObject: jsObject, name: .method)
        _url = ReadonlyAttribute(jsObject: jsObject, name: .url)
        _headers = ReadonlyAttribute(jsObject: jsObject, name: .headers)
        _destination = ReadonlyAttribute(jsObject: jsObject, name: .destination)
        _referrer = ReadonlyAttribute(jsObject: jsObject, name: .referrer)
        _referrerPolicy = ReadonlyAttribute(jsObject: jsObject, name: .referrerPolicy)
        _mode = ReadonlyAttribute(jsObject: jsObject, name: .mode)
        _credentials = ReadonlyAttribute(jsObject: jsObject, name: .credentials)
        _cache = ReadonlyAttribute(jsObject: jsObject, name: .cache)
        _redirect = ReadonlyAttribute(jsObject: jsObject, name: .redirect)
        _integrity = ReadonlyAttribute(jsObject: jsObject, name: .integrity)
        _keepalive = ReadonlyAttribute(jsObject: jsObject, name: .keepalive)
        _isReloadNavigation = ReadonlyAttribute(jsObject: jsObject, name: .isReloadNavigation)
        _isHistoryNavigation = ReadonlyAttribute(jsObject: jsObject, name: .isHistoryNavigation)
        _signal = ReadonlyAttribute(jsObject: jsObject, name: .signal)
        _duplex = ReadonlyAttribute(jsObject: jsObject, name: .duplex)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(input: RequestInfo, init: RequestInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(input), _toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var method: String

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var headers: Headers

    @ReadonlyAttribute
    public var destination: RequestDestination

    @ReadonlyAttribute
    public var referrer: String

    @ReadonlyAttribute
    public var referrerPolicy: ReferrerPolicy

    @ReadonlyAttribute
    public var mode: RequestMode

    @ReadonlyAttribute
    public var credentials: RequestCredentials

    @ReadonlyAttribute
    public var cache: RequestCache

    @ReadonlyAttribute
    public var redirect: RequestRedirect

    @ReadonlyAttribute
    public var integrity: String

    @ReadonlyAttribute
    public var keepalive: Bool

    @ReadonlyAttribute
    public var isReloadNavigation: Bool

    @ReadonlyAttribute
    public var isHistoryNavigation: Bool

    @ReadonlyAttribute
    public var signal: AbortSignal

    @ReadonlyAttribute
    public var duplex: RequestDuplex

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[.clone].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum RequestCache: JSString, JSValueCompatible {
    case `default` = "default"
    case noStore = "no-store"
    case reload = "reload"
    case noCache = "no-cache"
    case forceCache = "force-cache"
    case onlyIfCached = "only-if-cached"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RequestCredentials: JSString, JSValueCompatible {
    case omit = "omit"
    case sameOrigin = "same-origin"
    case include = "include"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RequestDestination: JSString, JSValueCompatible {
    case _empty = ""
    case audio = "audio"
    case audioworklet = "audioworklet"
    case document = "document"
    case embed = "embed"
    case font = "font"
    case frame = "frame"
    case iframe = "iframe"
    case image = "image"
    case manifest = "manifest"
    case object = "object"
    case paintworklet = "paintworklet"
    case report = "report"
    case script = "script"
    case sharedworker = "sharedworker"
    case style = "style"
    case track = "track"
    case video = "video"
    case worker = "worker"
    case xslt = "xslt"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RequestDuplex: JSString, JSValueCompatible {
    case half = "half"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class RequestInit: BridgedDictionary {
    public convenience init(method: String, headers: HeadersInit, body: BodyInit?, referrer: String, referrerPolicy: ReferrerPolicy, mode: RequestMode, credentials: RequestCredentials, cache: RequestCache, redirect: RequestRedirect, integrity: String, keepalive: Bool, signal: AbortSignal?, duplex: RequestDuplex, priority: RequestPriority, window: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        object[.method] = _toJSValue(method)
        object[.headers] = _toJSValue(headers)
        object[.body] = _toJSValue(body)
        object[.referrer] = _toJSValue(referrer)
        object[.referrerPolicy] = _toJSValue(referrerPolicy)
        object[.mode] = _toJSValue(mode)
        object[.credentials] = _toJSValue(credentials)
        object[.cache] = _toJSValue(cache)
        object[.redirect] = _toJSValue(redirect)
        object[.integrity] = _toJSValue(integrity)
        object[.keepalive] = _toJSValue(keepalive)
        object[.signal] = _toJSValue(signal)
        object[.duplex] = _toJSValue(duplex)
        object[.priority] = _toJSValue(priority)
        object[.window] = _toJSValue(window)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _method = ReadWriteAttribute(jsObject: object, name: .method)
        _headers = ReadWriteAttribute(jsObject: object, name: .headers)
        _body = ReadWriteAttribute(jsObject: object, name: .body)
        _referrer = ReadWriteAttribute(jsObject: object, name: .referrer)
        _referrerPolicy = ReadWriteAttribute(jsObject: object, name: .referrerPolicy)
        _mode = ReadWriteAttribute(jsObject: object, name: .mode)
        _credentials = ReadWriteAttribute(jsObject: object, name: .credentials)
        _cache = ReadWriteAttribute(jsObject: object, name: .cache)
        _redirect = ReadWriteAttribute(jsObject: object, name: .redirect)
        _integrity = ReadWriteAttribute(jsObject: object, name: .integrity)
        _keepalive = ReadWriteAttribute(jsObject: object, name: .keepalive)
        _signal = ReadWriteAttribute(jsObject: object, name: .signal)
        _duplex = ReadWriteAttribute(jsObject: object, name: .duplex)
        _priority = ReadWriteAttribute(jsObject: object, name: .priority)
        _window = ReadWriteAttribute(jsObject: object, name: .window)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var method: String

    @ReadWriteAttribute
    public var headers: HeadersInit

    @ReadWriteAttribute
    public var body: BodyInit?

    @ReadWriteAttribute
    public var referrer: String

    @ReadWriteAttribute
    public var referrerPolicy: ReferrerPolicy

    @ReadWriteAttribute
    public var mode: RequestMode

    @ReadWriteAttribute
    public var credentials: RequestCredentials

    @ReadWriteAttribute
    public var cache: RequestCache

    @ReadWriteAttribute
    public var redirect: RequestRedirect

    @ReadWriteAttribute
    public var integrity: String

    @ReadWriteAttribute
    public var keepalive: Bool

    @ReadWriteAttribute
    public var signal: AbortSignal?

    @ReadWriteAttribute
    public var duplex: RequestDuplex

    @ReadWriteAttribute
    public var priority: RequestPriority

    @ReadWriteAttribute
    public var window: JSValue
}

public enum RequestMode: JSString, JSValueCompatible {
    case navigate = "navigate"
    case sameOrigin = "same-origin"
    case noCors = "no-cors"
    case cors = "cors"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RequestPriority: JSString, JSValueCompatible {
    case high = "high"
    case low = "low"
    case auto = "auto"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RequestRedirect: JSString, JSValueCompatible {
    case follow = "follow"
    case error = "error"
    case manual = "manual"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ResizeQuality: JSString, JSValueCompatible {
    case pixelated = "pixelated"
    case low = "low"
    case medium = "medium"
    case high = "high"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Response: JSBridgedClass, Body {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Response].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _url = ReadonlyAttribute(jsObject: jsObject, name: .url)
        _redirected = ReadonlyAttribute(jsObject: jsObject, name: .redirected)
        _status = ReadonlyAttribute(jsObject: jsObject, name: .status)
        _ok = ReadonlyAttribute(jsObject: jsObject, name: .ok)
        _statusText = ReadonlyAttribute(jsObject: jsObject, name: .statusText)
        _headers = ReadonlyAttribute(jsObject: jsObject, name: .headers)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(body: BodyInit? = nil, init: ResponseInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(body), _toJSValue(`init`)]))
    }

    @inlinable public class func error() -> Self {
        let this = constructor!
        return this[.error].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public class func redirect(url: String, status: UInt16? = nil) -> Self {
        let this = constructor!
        return this[.redirect].function!(this: this, arguments: [_toJSValue(url), _toJSValue(status)]).fromJSValue()!
    }

    @inlinable public class func json(data: JSValue, init: ResponseInit? = nil) -> Self {
        let this = constructor!
        return this[.json].function!(this: this, arguments: [_toJSValue(data), _toJSValue(`init`)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var type: ResponseType

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var redirected: Bool

    @ReadonlyAttribute
    public var status: UInt16

    @ReadonlyAttribute
    public var ok: Bool

    @ReadonlyAttribute
    public var statusText: String

    @ReadonlyAttribute
    public var headers: Headers

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[.clone].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class ResponseInit: BridgedDictionary {
    public convenience init(status: UInt16, statusText: String, headers: HeadersInit) {
        let object = JSObject.global[.Object].function!.new()
        object[.status] = _toJSValue(status)
        object[.statusText] = _toJSValue(statusText)
        object[.headers] = _toJSValue(headers)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _status = ReadWriteAttribute(jsObject: object, name: .status)
        _statusText = ReadWriteAttribute(jsObject: object, name: .statusText)
        _headers = ReadWriteAttribute(jsObject: object, name: .headers)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var status: UInt16

    @ReadWriteAttribute
    public var statusText: String

    @ReadWriteAttribute
    public var headers: HeadersInit
}

public enum ResponseType: JSString, JSValueCompatible {
    case basic = "basic"
    case cors = "cors"
    case `default` = "default"
    case error = "error"
    case opaque = "opaque"
    case opaqueredirect = "opaqueredirect"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Screen: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Screen].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _availWidth = ReadonlyAttribute(jsObject: jsObject, name: .availWidth)
        _availHeight = ReadonlyAttribute(jsObject: jsObject, name: .availHeight)
        _width = ReadonlyAttribute(jsObject: jsObject, name: .width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: .height)
        _colorDepth = ReadonlyAttribute(jsObject: jsObject, name: .colorDepth)
        _pixelDepth = ReadonlyAttribute(jsObject: jsObject, name: .pixelDepth)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var availWidth: Int32

    @ReadonlyAttribute
    public var availHeight: Int32

    @ReadonlyAttribute
    public var width: Int32

    @ReadonlyAttribute
    public var height: Int32

    @ReadonlyAttribute
    public var colorDepth: UInt32

    @ReadonlyAttribute
    public var pixelDepth: UInt32
}

public enum ScrollBehavior: JSString, JSValueCompatible {
    case auto = "auto"
    case instant = "instant"
    case smooth = "smooth"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ScrollIntoViewOptions: BridgedDictionary {
    public convenience init(block: ScrollLogicalPosition, inline: ScrollLogicalPosition) {
        let object = JSObject.global[.Object].function!.new()
        object[.block] = _toJSValue(block)
        object[.inline] = _toJSValue(inline)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _block = ReadWriteAttribute(jsObject: object, name: .block)
        _inline = ReadWriteAttribute(jsObject: object, name: .inline)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var block: ScrollLogicalPosition

    @ReadWriteAttribute
    public var inline: ScrollLogicalPosition
}

public enum ScrollLogicalPosition: JSString, JSValueCompatible {
    case start = "start"
    case center = "center"
    case end = "end"
    case nearest = "nearest"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ScrollOptions: BridgedDictionary {
    public convenience init(behavior: ScrollBehavior) {
        let object = JSObject.global[.Object].function!.new()
        object[.behavior] = _toJSValue(behavior)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _behavior = ReadWriteAttribute(jsObject: object, name: .behavior)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var behavior: ScrollBehavior
}

public enum ScrollRestoration: JSString, JSValueCompatible {
    case auto = "auto"
    case manual = "manual"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ScrollToOptions: BridgedDictionary {
    public convenience init(left: Double, top: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.left] = _toJSValue(left)
        object[.top] = _toJSValue(top)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _left = ReadWriteAttribute(jsObject: object, name: .left)
        _top = ReadWriteAttribute(jsObject: object, name: .top)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var left: Double

    @ReadWriteAttribute
    public var top: Double
}

public enum SelectionMode: JSString, JSValueCompatible {
    case select = "select"
    case start = "start"
    case end = "end"
    case preserve = "preserve"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ServiceWorker: EventTarget, AbstractWorker {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ServiceWorker].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _scriptURL = ReadonlyAttribute(jsObject: jsObject, name: .scriptURL)
        _state = ReadonlyAttribute(jsObject: jsObject, name: .state)
        _onstatechange = ClosureAttribute1Optional(jsObject: jsObject, name: .onstatechange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var scriptURL: String

    @ReadonlyAttribute
    public var state: ServiceWorkerState

    @inlinable public func postMessage(message: JSValue, transfer: [JSObject]) {
        let this = jsObject
        _ = this[.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(transfer)])
    }

    @inlinable public func postMessage(message: JSValue, options: StructuredSerializeOptions? = nil) {
        let this = jsObject
        _ = this[.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(options)])
    }

    @ClosureAttribute1Optional
    public var onstatechange: EventHandler
}

public class ServiceWorkerContainer: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ServiceWorkerContainer].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _controller = ReadonlyAttribute(jsObject: jsObject, name: .controller)
        _ready = ReadonlyAttribute(jsObject: jsObject, name: .ready)
        _oncontrollerchange = ClosureAttribute1Optional(jsObject: jsObject, name: .oncontrollerchange)
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: .onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var controller: ServiceWorker?

    @ReadonlyAttribute
    public var ready: JSPromise

    @inlinable public func register(scriptURL: String, options: RegistrationOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.register].function!(this: this, arguments: [_toJSValue(scriptURL), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func register(scriptURL: String, options: RegistrationOptions? = nil) async throws -> ServiceWorkerRegistration {
        let this = jsObject
        let _promise: JSPromise = this[.register].function!(this: this, arguments: [_toJSValue(scriptURL), _toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func getRegistration(clientURL: String? = nil) -> JSPromise {
        let this = jsObject
        return this[.getRegistration].function!(this: this, arguments: [_toJSValue(clientURL)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getRegistration(clientURL: String? = nil) async throws -> ServiceWorkerRegistration? {
        let this = jsObject
        let _promise: JSPromise = this[.getRegistration].function!(this: this, arguments: [_toJSValue(clientURL)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func getRegistrations() -> JSPromise {
        let this = jsObject
        return this[.getRegistrations].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getRegistrations() async throws -> [ServiceWorkerRegistration] {
        let this = jsObject
        let _promise: JSPromise = this[.getRegistrations].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func startMessages() {
        let this = jsObject
        _ = this[.startMessages].function!(this: this, arguments: [])
    }

    @ClosureAttribute1Optional
    public var oncontrollerchange: EventHandler

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public class ServiceWorkerRegistration: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ServiceWorkerRegistration].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _installing = ReadonlyAttribute(jsObject: jsObject, name: .installing)
        _waiting = ReadonlyAttribute(jsObject: jsObject, name: .waiting)
        _active = ReadonlyAttribute(jsObject: jsObject, name: .active)
        _navigationPreload = ReadonlyAttribute(jsObject: jsObject, name: .navigationPreload)
        _scope = ReadonlyAttribute(jsObject: jsObject, name: .scope)
        _updateViaCache = ReadonlyAttribute(jsObject: jsObject, name: .updateViaCache)
        _onupdatefound = ClosureAttribute1Optional(jsObject: jsObject, name: .onupdatefound)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var installing: ServiceWorker?

    @ReadonlyAttribute
    public var waiting: ServiceWorker?

    @ReadonlyAttribute
    public var active: ServiceWorker?

    @ReadonlyAttribute
    public var navigationPreload: NavigationPreloadManager

    @ReadonlyAttribute
    public var scope: String

    @ReadonlyAttribute
    public var updateViaCache: ServiceWorkerUpdateViaCache

    @inlinable public func update() -> JSPromise {
        let this = jsObject
        return this[.update].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func update() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.update].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func unregister() -> JSPromise {
        let this = jsObject
        return this[.unregister].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func unregister() async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[.unregister].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @ClosureAttribute1Optional
    public var onupdatefound: EventHandler
}

public enum ServiceWorkerState: JSString, JSValueCompatible {
    case parsed = "parsed"
    case installing = "installing"
    case installed = "installed"
    case activating = "activating"
    case activated = "activated"
    case redundant = "redundant"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ServiceWorkerUpdateViaCache: JSString, JSValueCompatible {
    case imports = "imports"
    case all = "all"
    case none = "none"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

open class ShadowRoot: DocumentFragment, DocumentOrShadowRoot {
    @inlinable override open class var constructor: JSFunction? { JSObject.global[.ShadowRoot].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _mode = ReadonlyAttribute(jsObject: jsObject, name: .mode)
        _delegatesFocus = ReadonlyAttribute(jsObject: jsObject, name: .delegatesFocus)
        _slotAssignment = ReadonlyAttribute(jsObject: jsObject, name: .slotAssignment)
        _host = ReadonlyAttribute(jsObject: jsObject, name: .host)
        _onslotchange = ClosureAttribute1Optional(jsObject: jsObject, name: .onslotchange)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var mode: ShadowRootMode

    @ReadonlyAttribute
    public var delegatesFocus: Bool

    @ReadonlyAttribute
    public var slotAssignment: SlotAssignmentMode

    @ReadonlyAttribute
    public var host: Element

    @ClosureAttribute1Optional
    public var onslotchange: EventHandler
}

public class ShadowRootInit: BridgedDictionary {
    public convenience init(mode: ShadowRootMode, delegatesFocus: Bool, slotAssignment: SlotAssignmentMode) {
        let object = JSObject.global[.Object].function!.new()
        object[.mode] = _toJSValue(mode)
        object[.delegatesFocus] = _toJSValue(delegatesFocus)
        object[.slotAssignment] = _toJSValue(slotAssignment)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _mode = ReadWriteAttribute(jsObject: object, name: .mode)
        _delegatesFocus = ReadWriteAttribute(jsObject: object, name: .delegatesFocus)
        _slotAssignment = ReadWriteAttribute(jsObject: object, name: .slotAssignment)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var mode: ShadowRootMode

    @ReadWriteAttribute
    public var delegatesFocus: Bool

    @ReadWriteAttribute
    public var slotAssignment: SlotAssignmentMode
}

public enum ShadowRootMode: JSString, JSValueCompatible {
    case open = "open"
    case closed = "closed"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class SharedWorker: EventTarget, AbstractWorker {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SharedWorker].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _port = ReadonlyAttribute(jsObject: jsObject, name: .port)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(scriptURL: String, options: String_or_WorkerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(scriptURL), _toJSValue(options)]))
    }

    @ReadonlyAttribute
    public var port: MessagePort
}

public enum SlotAssignmentMode: JSString, JSValueCompatible {
    case manual = "manual"
    case named = "named"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol Slottable: JSBridgedClass {}
public extension Slottable {
    @inlinable var assignedSlot: HTMLSlotElement? { jsObject[.assignedSlot].fromJSValue() }
}

public class SourceBuffer: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SourceBuffer].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _mode = ReadWriteAttribute(jsObject: jsObject, name: .mode)
        _updating = ReadonlyAttribute(jsObject: jsObject, name: .updating)
        _buffered = ReadonlyAttribute(jsObject: jsObject, name: .buffered)
        _timestampOffset = ReadWriteAttribute(jsObject: jsObject, name: .timestampOffset)
        _audioTracks = ReadonlyAttribute(jsObject: jsObject, name: .audioTracks)
        _videoTracks = ReadonlyAttribute(jsObject: jsObject, name: .videoTracks)
        _textTracks = ReadonlyAttribute(jsObject: jsObject, name: .textTracks)
        _appendWindowStart = ReadWriteAttribute(jsObject: jsObject, name: .appendWindowStart)
        _appendWindowEnd = ReadWriteAttribute(jsObject: jsObject, name: .appendWindowEnd)
        _onupdatestart = ClosureAttribute1Optional(jsObject: jsObject, name: .onupdatestart)
        _onupdate = ClosureAttribute1Optional(jsObject: jsObject, name: .onupdate)
        _onupdateend = ClosureAttribute1Optional(jsObject: jsObject, name: .onupdateend)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onerror)
        _onabort = ClosureAttribute1Optional(jsObject: jsObject, name: .onabort)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadWriteAttribute
    public var mode: AppendMode

    @ReadonlyAttribute
    public var updating: Bool

    @ReadonlyAttribute
    public var buffered: TimeRanges

    @ReadWriteAttribute
    public var timestampOffset: Double

    @ReadonlyAttribute
    public var audioTracks: AudioTrackList

    @ReadonlyAttribute
    public var videoTracks: VideoTrackList

    @ReadonlyAttribute
    public var textTracks: TextTrackList

    @ReadWriteAttribute
    public var appendWindowStart: Double

    @ReadWriteAttribute
    public var appendWindowEnd: Double

    @ClosureAttribute1Optional
    public var onupdatestart: EventHandler

    @ClosureAttribute1Optional
    public var onupdate: EventHandler

    @ClosureAttribute1Optional
    public var onupdateend: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @ClosureAttribute1Optional
    public var onabort: EventHandler

    @inlinable public func appendBuffer(data: BufferSource) {
        let this = jsObject
        _ = this[.appendBuffer].function!(this: this, arguments: [_toJSValue(data)])
    }

    @inlinable public func abort() {
        let this = jsObject
        _ = this[.abort].function!(this: this, arguments: [])
    }

    @inlinable public func changeType(type: String) {
        let this = jsObject
        _ = this[.changeType].function!(this: this, arguments: [_toJSValue(type)])
    }

    @inlinable public func remove(start: Double, end: Double) {
        let this = jsObject
        _ = this[.remove].function!(this: this, arguments: [_toJSValue(start), _toJSValue(end)])
    }
}

public class SourceBufferList: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SourceBufferList].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        _onaddsourcebuffer = ClosureAttribute1Optional(jsObject: jsObject, name: .onaddsourcebuffer)
        _onremovesourcebuffer = ClosureAttribute1Optional(jsObject: jsObject, name: .onremovesourcebuffer)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var length: UInt32

    @ClosureAttribute1Optional
    public var onaddsourcebuffer: EventHandler

    @ClosureAttribute1Optional
    public var onremovesourcebuffer: EventHandler

    @inlinable public subscript(key: Int) -> SourceBuffer {
        jsObject[key].fromJSValue()!
    }
}

public class StaticRange: AbstractRange {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.StaticRange].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(init: StaticRangeInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }
}

public class StaticRangeInit: BridgedDictionary {
    public convenience init(startContainer: Node, startOffset: UInt32, endContainer: Node, endOffset: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.startContainer] = _toJSValue(startContainer)
        object[.startOffset] = _toJSValue(startOffset)
        object[.endContainer] = _toJSValue(endContainer)
        object[.endOffset] = _toJSValue(endOffset)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _startContainer = ReadWriteAttribute(jsObject: object, name: .startContainer)
        _startOffset = ReadWriteAttribute(jsObject: object, name: .startOffset)
        _endContainer = ReadWriteAttribute(jsObject: object, name: .endContainer)
        _endOffset = ReadWriteAttribute(jsObject: object, name: .endOffset)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var startContainer: Node

    @ReadWriteAttribute
    public var startOffset: UInt32

    @ReadWriteAttribute
    public var endContainer: Node

    @ReadWriteAttribute
    public var endOffset: UInt32
}

public class Storage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Storage].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public func key(index: UInt32) -> String? {
        let this = jsObject
        return this[.key].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public func getItem(key: String) -> String? {
        let this = jsObject
        return this[.getItem].function!(this: this, arguments: [_toJSValue(key)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> String? {
        get {
            jsObject[key].fromJSValue()
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }

    @inlinable public func removeValue(forKey key: String) {
        _ = JSObject.global.Reflect.deleteProperty(jsObject, _toJSValue(key))
    }

    @inlinable public func clear() {
        let this = jsObject
        _ = this[.clear].function!(this: this, arguments: [])
    }
}

public class StorageEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.StorageEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _key = ReadonlyAttribute(jsObject: jsObject, name: .key)
        _oldValue = ReadonlyAttribute(jsObject: jsObject, name: .oldValue)
        _newValue = ReadonlyAttribute(jsObject: jsObject, name: .newValue)
        _url = ReadonlyAttribute(jsObject: jsObject, name: .url)
        _storageArea = ReadonlyAttribute(jsObject: jsObject, name: .storageArea)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: StorageEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var key: String?

    @ReadonlyAttribute
    public var oldValue: String?

    @ReadonlyAttribute
    public var newValue: String?

    @ReadonlyAttribute
    public var url: String

    @ReadonlyAttribute
    public var storageArea: Storage?

    @inlinable public func initStorageEvent(type: String, bubbles: Bool? = nil, cancelable: Bool? = nil, key: String? = nil, oldValue: String? = nil, newValue: String? = nil, url: String? = nil, storageArea: Storage? = nil) {
        let this = jsObject
        _ = this[.initStorageEvent].function!(this: this, arguments: [_toJSValue(type), _toJSValue(bubbles), _toJSValue(cancelable), _toJSValue(key), _toJSValue(oldValue), _toJSValue(newValue), _toJSValue(url), _toJSValue(storageArea)])
    }
}

public class StorageEventInit: BridgedDictionary {
    public convenience init(key: String?, oldValue: String?, newValue: String?, url: String, storageArea: Storage?) {
        let object = JSObject.global[.Object].function!.new()
        object[.key] = _toJSValue(key)
        object[.oldValue] = _toJSValue(oldValue)
        object[.newValue] = _toJSValue(newValue)
        object[.url] = _toJSValue(url)
        object[.storageArea] = _toJSValue(storageArea)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _key = ReadWriteAttribute(jsObject: object, name: .key)
        _oldValue = ReadWriteAttribute(jsObject: object, name: .oldValue)
        _newValue = ReadWriteAttribute(jsObject: object, name: .newValue)
        _url = ReadWriteAttribute(jsObject: object, name: .url)
        _storageArea = ReadWriteAttribute(jsObject: object, name: .storageArea)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var key: String?

    @ReadWriteAttribute
    public var oldValue: String?

    @ReadWriteAttribute
    public var newValue: String?

    @ReadWriteAttribute
    public var url: String

    @ReadWriteAttribute
    public var storageArea: Storage?
}

public class StreamPipeOptions: BridgedDictionary {
    public convenience init(preventClose: Bool, preventAbort: Bool, preventCancel: Bool, signal: AbortSignal) {
        let object = JSObject.global[.Object].function!.new()
        object[.preventClose] = _toJSValue(preventClose)
        object[.preventAbort] = _toJSValue(preventAbort)
        object[.preventCancel] = _toJSValue(preventCancel)
        object[.signal] = _toJSValue(signal)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _preventClose = ReadWriteAttribute(jsObject: object, name: .preventClose)
        _preventAbort = ReadWriteAttribute(jsObject: object, name: .preventAbort)
        _preventCancel = ReadWriteAttribute(jsObject: object, name: .preventCancel)
        _signal = ReadWriteAttribute(jsObject: object, name: .signal)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var preventClose: Bool

    @ReadWriteAttribute
    public var preventAbort: Bool

    @ReadWriteAttribute
    public var preventCancel: Bool

    @ReadWriteAttribute
    public var signal: AbortSignal
}

public class StructuredSerializeOptions: BridgedDictionary {
    public convenience init(transfer: [JSObject]) {
        let object = JSObject.global[.Object].function!.new()
        object[.transfer] = _toJSValue(transfer)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _transfer = ReadWriteAttribute(jsObject: object, name: .transfer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var transfer: [JSObject]
}

public class SubmitEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SubmitEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _submitter = ReadonlyAttribute(jsObject: jsObject, name: .submitter)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: SubmitEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var submitter: HTMLElement?
}

public class SubmitEventInit: BridgedDictionary {
    public convenience init(submitter: HTMLElement?) {
        let object = JSObject.global[.Object].function!.new()
        object[.submitter] = _toJSValue(submitter)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _submitter = ReadWriteAttribute(jsObject: object, name: .submitter)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var submitter: HTMLElement?
}

public class SvcOutputMetadata: BridgedDictionary {
    public convenience init(temporalLayerId: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.temporalLayerId] = _toJSValue(temporalLayerId)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _temporalLayerId = ReadWriteAttribute(jsObject: object, name: .temporalLayerId)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var temporalLayerId: UInt32
}

public class Text: CharacterData, Slottable, GeometryUtils {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.Text].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _wholeText = ReadonlyAttribute(jsObject: jsObject, name: .wholeText)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(data: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(data)]))
    }

    @inlinable public func splitText(offset: UInt32) -> Self {
        let this = jsObject
        return this[.splitText].function!(this: this, arguments: [_toJSValue(offset)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var wholeText: String
}

public class TextMetrics: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.TextMetrics].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadonlyAttribute(jsObject: jsObject, name: .width)
        _actualBoundingBoxLeft = ReadonlyAttribute(jsObject: jsObject, name: .actualBoundingBoxLeft)
        _actualBoundingBoxRight = ReadonlyAttribute(jsObject: jsObject, name: .actualBoundingBoxRight)
        _fontBoundingBoxAscent = ReadonlyAttribute(jsObject: jsObject, name: .fontBoundingBoxAscent)
        _fontBoundingBoxDescent = ReadonlyAttribute(jsObject: jsObject, name: .fontBoundingBoxDescent)
        _actualBoundingBoxAscent = ReadonlyAttribute(jsObject: jsObject, name: .actualBoundingBoxAscent)
        _actualBoundingBoxDescent = ReadonlyAttribute(jsObject: jsObject, name: .actualBoundingBoxDescent)
        _emHeightAscent = ReadonlyAttribute(jsObject: jsObject, name: .emHeightAscent)
        _emHeightDescent = ReadonlyAttribute(jsObject: jsObject, name: .emHeightDescent)
        _hangingBaseline = ReadonlyAttribute(jsObject: jsObject, name: .hangingBaseline)
        _alphabeticBaseline = ReadonlyAttribute(jsObject: jsObject, name: .alphabeticBaseline)
        _ideographicBaseline = ReadonlyAttribute(jsObject: jsObject, name: .ideographicBaseline)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var width: Double

    @ReadonlyAttribute
    public var actualBoundingBoxLeft: Double

    @ReadonlyAttribute
    public var actualBoundingBoxRight: Double

    @ReadonlyAttribute
    public var fontBoundingBoxAscent: Double

    @ReadonlyAttribute
    public var fontBoundingBoxDescent: Double

    @ReadonlyAttribute
    public var actualBoundingBoxAscent: Double

    @ReadonlyAttribute
    public var actualBoundingBoxDescent: Double

    @ReadonlyAttribute
    public var emHeightAscent: Double

    @ReadonlyAttribute
    public var emHeightDescent: Double

    @ReadonlyAttribute
    public var hangingBaseline: Double

    @ReadonlyAttribute
    public var alphabeticBaseline: Double

    @ReadonlyAttribute
    public var ideographicBaseline: Double
}

public class TextTrack: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.TextTrack].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _kind = ReadonlyAttribute(jsObject: jsObject, name: .kind)
        _label = ReadonlyAttribute(jsObject: jsObject, name: .label)
        _language = ReadonlyAttribute(jsObject: jsObject, name: .language)
        _id = ReadonlyAttribute(jsObject: jsObject, name: .id)
        _inBandMetadataTrackDispatchType = ReadonlyAttribute(jsObject: jsObject, name: .inBandMetadataTrackDispatchType)
        _mode = ReadWriteAttribute(jsObject: jsObject, name: .mode)
        _cues = ReadonlyAttribute(jsObject: jsObject, name: .cues)
        _activeCues = ReadonlyAttribute(jsObject: jsObject, name: .activeCues)
        _oncuechange = ClosureAttribute1Optional(jsObject: jsObject, name: .oncuechange)
        _sourceBuffer = ReadonlyAttribute(jsObject: jsObject, name: .sourceBuffer)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var kind: TextTrackKind

    @ReadonlyAttribute
    public var label: String

    @ReadonlyAttribute
    public var language: String

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var inBandMetadataTrackDispatchType: String

    @ReadWriteAttribute
    public var mode: TextTrackMode

    @ReadonlyAttribute
    public var cues: TextTrackCueList?

    @ReadonlyAttribute
    public var activeCues: TextTrackCueList?

    @inlinable public func addCue(cue: TextTrackCue) {
        let this = jsObject
        _ = this[.addCue].function!(this: this, arguments: [_toJSValue(cue)])
    }

    @inlinable public func removeCue(cue: TextTrackCue) {
        let this = jsObject
        _ = this[.removeCue].function!(this: this, arguments: [_toJSValue(cue)])
    }

    @ClosureAttribute1Optional
    public var oncuechange: EventHandler

    @ReadonlyAttribute
    public var sourceBuffer: SourceBuffer?
}

public class TextTrackCue: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.TextTrackCue].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _track = ReadonlyAttribute(jsObject: jsObject, name: .track)
        _id = ReadWriteAttribute(jsObject: jsObject, name: .id)
        _startTime = ReadWriteAttribute(jsObject: jsObject, name: .startTime)
        _endTime = ReadWriteAttribute(jsObject: jsObject, name: .endTime)
        _pauseOnExit = ReadWriteAttribute(jsObject: jsObject, name: .pauseOnExit)
        _onenter = ClosureAttribute1Optional(jsObject: jsObject, name: .onenter)
        _onexit = ClosureAttribute1Optional(jsObject: jsObject, name: .onexit)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var track: TextTrack?

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var startTime: Double

    @ReadWriteAttribute
    public var endTime: Double

    @ReadWriteAttribute
    public var pauseOnExit: Bool

    @ClosureAttribute1Optional
    public var onenter: EventHandler

    @ClosureAttribute1Optional
    public var onexit: EventHandler
}

public class TextTrackCueList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.TextTrackCueList].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> TextTrackCue {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getCueById(id: String) -> TextTrackCue? {
        let this = jsObject
        return this[.getCueById].function!(this: this, arguments: [_toJSValue(id)]).fromJSValue()
    }
}

public enum TextTrackKind: JSString, JSValueCompatible {
    case subtitles = "subtitles"
    case captions = "captions"
    case descriptions = "descriptions"
    case chapters = "chapters"
    case metadata = "metadata"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class TextTrackList: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.TextTrackList].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: .onchange)
        _onaddtrack = ClosureAttribute1Optional(jsObject: jsObject, name: .onaddtrack)
        _onremovetrack = ClosureAttribute1Optional(jsObject: jsObject, name: .onremovetrack)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> TextTrack {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getTrackById(id: String) -> TextTrack? {
        let this = jsObject
        return this[.getTrackById].function!(this: this, arguments: [_toJSValue(id)]).fromJSValue()
    }

    @ClosureAttribute1Optional
    public var onchange: EventHandler

    @ClosureAttribute1Optional
    public var onaddtrack: EventHandler

    @ClosureAttribute1Optional
    public var onremovetrack: EventHandler
}

public enum TextTrackMode: JSString, JSValueCompatible {
    case disabled = "disabled"
    case hidden = "hidden"
    case showing = "showing"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class TimeRanges: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.TimeRanges].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public func start(index: UInt32) -> Double {
        let this = jsObject
        return this[.start].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }

    @inlinable public func end(index: UInt32) -> Double {
        let this = jsObject
        return this[.end].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
}

public class ToggleEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ToggleEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _oldState = ReadonlyAttribute(jsObject: jsObject, name: .oldState)
        _newState = ReadonlyAttribute(jsObject: jsObject, name: .newState)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: ToggleEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var oldState: String

    @ReadonlyAttribute
    public var newState: String
}

public class ToggleEventInit: BridgedDictionary {
    public convenience init(oldState: String, newState: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.oldState] = _toJSValue(oldState)
        object[.newState] = _toJSValue(newState)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _oldState = ReadWriteAttribute(jsObject: object, name: .oldState)
        _newState = ReadWriteAttribute(jsObject: object, name: .newState)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var oldState: String

    @ReadWriteAttribute
    public var newState: String
}

public class Touch: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Touch].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _identifier = ReadonlyAttribute(jsObject: jsObject, name: .identifier)
        _target = ReadonlyAttribute(jsObject: jsObject, name: .target)
        _screenX = ReadonlyAttribute(jsObject: jsObject, name: .screenX)
        _screenY = ReadonlyAttribute(jsObject: jsObject, name: .screenY)
        _clientX = ReadonlyAttribute(jsObject: jsObject, name: .clientX)
        _clientY = ReadonlyAttribute(jsObject: jsObject, name: .clientY)
        _pageX = ReadonlyAttribute(jsObject: jsObject, name: .pageX)
        _pageY = ReadonlyAttribute(jsObject: jsObject, name: .pageY)
        _radiusX = ReadonlyAttribute(jsObject: jsObject, name: .radiusX)
        _radiusY = ReadonlyAttribute(jsObject: jsObject, name: .radiusY)
        _rotationAngle = ReadonlyAttribute(jsObject: jsObject, name: .rotationAngle)
        _force = ReadonlyAttribute(jsObject: jsObject, name: .force)
        _altitudeAngle = ReadonlyAttribute(jsObject: jsObject, name: .altitudeAngle)
        _azimuthAngle = ReadonlyAttribute(jsObject: jsObject, name: .azimuthAngle)
        _touchType = ReadonlyAttribute(jsObject: jsObject, name: .touchType)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(touchInitDict: TouchInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(touchInitDict)]))
    }

    @ReadonlyAttribute
    public var identifier: Int32

    @ReadonlyAttribute
    public var target: EventTarget

    @ReadonlyAttribute
    public var screenX: Double

    @ReadonlyAttribute
    public var screenY: Double

    @ReadonlyAttribute
    public var clientX: Double

    @ReadonlyAttribute
    public var clientY: Double

    @ReadonlyAttribute
    public var pageX: Double

    @ReadonlyAttribute
    public var pageY: Double

    @ReadonlyAttribute
    public var radiusX: Float

    @ReadonlyAttribute
    public var radiusY: Float

    @ReadonlyAttribute
    public var rotationAngle: Float

    @ReadonlyAttribute
    public var force: Float

    @ReadonlyAttribute
    public var altitudeAngle: Float

    @ReadonlyAttribute
    public var azimuthAngle: Float

    @ReadonlyAttribute
    public var touchType: TouchType
}

public class TouchEvent: UIEvent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.TouchEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _touches = ReadonlyAttribute(jsObject: jsObject, name: .touches)
        _targetTouches = ReadonlyAttribute(jsObject: jsObject, name: .targetTouches)
        _changedTouches = ReadonlyAttribute(jsObject: jsObject, name: .changedTouches)
        _altKey = ReadonlyAttribute(jsObject: jsObject, name: .altKey)
        _metaKey = ReadonlyAttribute(jsObject: jsObject, name: .metaKey)
        _ctrlKey = ReadonlyAttribute(jsObject: jsObject, name: .ctrlKey)
        _shiftKey = ReadonlyAttribute(jsObject: jsObject, name: .shiftKey)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: TouchEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var touches: TouchList

    @ReadonlyAttribute
    public var targetTouches: TouchList

    @ReadonlyAttribute
    public var changedTouches: TouchList

    @ReadonlyAttribute
    public var altKey: Bool

    @ReadonlyAttribute
    public var metaKey: Bool

    @ReadonlyAttribute
    public var ctrlKey: Bool

    @ReadonlyAttribute
    public var shiftKey: Bool

    @inlinable public subscript(key: String) -> Bool {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getModifierState(keyArg: String) -> Bool {
        let this = jsObject
        return this[.getModifierState].function!(this: this, arguments: [_toJSValue(keyArg)]).fromJSValue()!
    }
}

public class TouchEventInit: BridgedDictionary {
    public convenience init(touches: [Touch], targetTouches: [Touch], changedTouches: [Touch]) {
        let object = JSObject.global[.Object].function!.new()
        object[.touches] = _toJSValue(touches)
        object[.targetTouches] = _toJSValue(targetTouches)
        object[.changedTouches] = _toJSValue(changedTouches)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _touches = ReadWriteAttribute(jsObject: object, name: .touches)
        _targetTouches = ReadWriteAttribute(jsObject: object, name: .targetTouches)
        _changedTouches = ReadWriteAttribute(jsObject: object, name: .changedTouches)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var touches: [Touch]

    @ReadWriteAttribute
    public var targetTouches: [Touch]

    @ReadWriteAttribute
    public var changedTouches: [Touch]
}

public class TouchInit: BridgedDictionary {
    public convenience init(identifier: Int32, target: EventTarget, clientX: Double, clientY: Double, screenX: Double, screenY: Double, pageX: Double, pageY: Double, radiusX: Float, radiusY: Float, rotationAngle: Float, force: Float, altitudeAngle: Double, azimuthAngle: Double, touchType: TouchType) {
        let object = JSObject.global[.Object].function!.new()
        object[.identifier] = _toJSValue(identifier)
        object[.target] = _toJSValue(target)
        object[.clientX] = _toJSValue(clientX)
        object[.clientY] = _toJSValue(clientY)
        object[.screenX] = _toJSValue(screenX)
        object[.screenY] = _toJSValue(screenY)
        object[.pageX] = _toJSValue(pageX)
        object[.pageY] = _toJSValue(pageY)
        object[.radiusX] = _toJSValue(radiusX)
        object[.radiusY] = _toJSValue(radiusY)
        object[.rotationAngle] = _toJSValue(rotationAngle)
        object[.force] = _toJSValue(force)
        object[.altitudeAngle] = _toJSValue(altitudeAngle)
        object[.azimuthAngle] = _toJSValue(azimuthAngle)
        object[.touchType] = _toJSValue(touchType)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _identifier = ReadWriteAttribute(jsObject: object, name: .identifier)
        _target = ReadWriteAttribute(jsObject: object, name: .target)
        _clientX = ReadWriteAttribute(jsObject: object, name: .clientX)
        _clientY = ReadWriteAttribute(jsObject: object, name: .clientY)
        _screenX = ReadWriteAttribute(jsObject: object, name: .screenX)
        _screenY = ReadWriteAttribute(jsObject: object, name: .screenY)
        _pageX = ReadWriteAttribute(jsObject: object, name: .pageX)
        _pageY = ReadWriteAttribute(jsObject: object, name: .pageY)
        _radiusX = ReadWriteAttribute(jsObject: object, name: .radiusX)
        _radiusY = ReadWriteAttribute(jsObject: object, name: .radiusY)
        _rotationAngle = ReadWriteAttribute(jsObject: object, name: .rotationAngle)
        _force = ReadWriteAttribute(jsObject: object, name: .force)
        _altitudeAngle = ReadWriteAttribute(jsObject: object, name: .altitudeAngle)
        _azimuthAngle = ReadWriteAttribute(jsObject: object, name: .azimuthAngle)
        _touchType = ReadWriteAttribute(jsObject: object, name: .touchType)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var identifier: Int32

    @ReadWriteAttribute
    public var target: EventTarget

    @ReadWriteAttribute
    public var clientX: Double

    @ReadWriteAttribute
    public var clientY: Double

    @ReadWriteAttribute
    public var screenX: Double

    @ReadWriteAttribute
    public var screenY: Double

    @ReadWriteAttribute
    public var pageX: Double

    @ReadWriteAttribute
    public var pageY: Double

    @ReadWriteAttribute
    public var radiusX: Float

    @ReadWriteAttribute
    public var radiusY: Float

    @ReadWriteAttribute
    public var rotationAngle: Float

    @ReadWriteAttribute
    public var force: Float

    @ReadWriteAttribute
    public var altitudeAngle: Double

    @ReadWriteAttribute
    public var azimuthAngle: Double

    @ReadWriteAttribute
    public var touchType: TouchType
}

public class TouchList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.TouchList].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> Touch? {
        jsObject[key].fromJSValue()
    }

    @inlinable public func item(index: UInt32) -> Touch? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
}

public enum TouchType: JSString, JSValueCompatible {
    case direct = "direct"
    case stylus = "stylus"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class TrackEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.TrackEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _track = ReadonlyAttribute(jsObject: jsObject, name: .track)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: TrackEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var track: AudioTrack_or_TextTrack_or_VideoTrack?
}

public class TrackEventInit: BridgedDictionary {
    public convenience init(track: AudioTrack_or_TextTrack_or_VideoTrack?) {
        let object = JSObject.global[.Object].function!.new()
        object[.track] = _toJSValue(track)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _track = ReadWriteAttribute(jsObject: object, name: .track)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var track: AudioTrack_or_TextTrack_or_VideoTrack?
}

public class TransformStream: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.TransformStream].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _readable = ReadonlyAttribute(jsObject: jsObject, name: .readable)
        _writable = ReadonlyAttribute(jsObject: jsObject, name: .writable)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(transformer: JSObject? = nil, writableStrategy: QueuingStrategy? = nil, readableStrategy: QueuingStrategy? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(transformer), _toJSValue(writableStrategy), _toJSValue(readableStrategy)]))
    }

    @ReadonlyAttribute
    public var readable: ReadableStream

    @ReadonlyAttribute
    public var writable: WritableStream
}

public class TransformStreamDefaultController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.TransformStreamDefaultController].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _desiredSize = ReadonlyAttribute(jsObject: jsObject, name: .desiredSize)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var desiredSize: Double?

    @inlinable public func enqueue(chunk: JSValue? = nil) {
        let this = jsObject
        _ = this[.enqueue].function!(this: this, arguments: [_toJSValue(chunk)])
    }

    @inlinable public func error(reason: JSValue? = nil) {
        let this = jsObject
        _ = this[.error].function!(this: this, arguments: [_toJSValue(reason)])
    }

    @inlinable public func terminate() {
        let this = jsObject
        _ = this[.terminate].function!(this: this, arguments: [])
    }
}

public class Transformer: BridgedDictionary {
    public convenience init(start: @escaping TransformerStartCallback, transform: @escaping TransformerTransformCallback, flush: @escaping TransformerFlushCallback, readableType: JSValue, writableType: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        ClosureAttribute1[.start, in: object] = start
        ClosureAttribute2[.transform, in: object] = transform
        ClosureAttribute1[.flush, in: object] = flush
        object[.readableType] = _toJSValue(readableType)
        object[.writableType] = _toJSValue(writableType)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _start = ClosureAttribute1(jsObject: object, name: .start)
        _transform = ClosureAttribute2(jsObject: object, name: .transform)
        _flush = ClosureAttribute1(jsObject: object, name: .flush)
        _readableType = ReadWriteAttribute(jsObject: object, name: .readableType)
        _writableType = ReadWriteAttribute(jsObject: object, name: .writableType)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute1
    public var start: TransformerStartCallback

    @ClosureAttribute2
    public var transform: TransformerTransformCallback

    @ClosureAttribute1
    public var flush: TransformerFlushCallback

    @ReadWriteAttribute
    public var readableType: JSValue

    @ReadWriteAttribute
    public var writableType: JSValue
}

public class TreeWalker: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.TreeWalker].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _root = ReadonlyAttribute(jsObject: jsObject, name: .root)
        _whatToShow = ReadonlyAttribute(jsObject: jsObject, name: .whatToShow)
        _currentNode = ReadWriteAttribute(jsObject: jsObject, name: .currentNode)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var root: Node

    @ReadonlyAttribute
    public var whatToShow: UInt32

    // XXX: member 'filter' is ignored

    @ReadWriteAttribute
    public var currentNode: Node

    @inlinable public func parentNode() -> Node? {
        let this = jsObject
        return this[.parentNode].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public func firstChild() -> Node? {
        let this = jsObject
        return this[.firstChild].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public func lastChild() -> Node? {
        let this = jsObject
        return this[.lastChild].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public func previousSibling() -> Node? {
        let this = jsObject
        return this[.previousSibling].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public func nextSibling() -> Node? {
        let this = jsObject
        return this[.nextSibling].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public func previousNode() -> Node? {
        let this = jsObject
        return this[.previousNode].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public func nextNode() -> Node? {
        let this = jsObject
        return this[.nextNode].function!(this: this, arguments: []).fromJSValue()
    }
}

public typealias EventHandler = EventHandlerNonNull?
public typealias OnErrorEventHandler = OnErrorEventHandlerNonNull?
public typealias OnBeforeUnloadEventHandler = OnBeforeUnloadEventHandlerNonNull?

public typealias DOMHighResTimeStamp = Double
public typealias EpochTimeStamp = UInt64

public typealias PerformanceEntryList = [PerformanceEntry]
public typealias MutationCallback = ([MutationRecord], MutationObserver) -> Void
public typealias BlobCallback = (Blob?) -> Void
public typealias FunctionStringCallback = (String) -> Void
public typealias NavigationInterceptHandler = () -> JSPromise
public typealias EventHandlerNonNull = (Event) -> JSValue
public typealias OnErrorEventHandlerNonNull = (Event_or_String, String, UInt32, UInt32, JSValue) -> JSValue
public typealias OnBeforeUnloadEventHandlerNonNull = (Event) -> String?
public typealias FrameRequestCallback = (DOMHighResTimeStamp) -> Void
public typealias UnderlyingSourceStartCallback = (ReadableStreamController) -> JSValue
public typealias UnderlyingSourcePullCallback = (ReadableStreamController) -> JSPromise
public typealias UnderlyingSourceCancelCallback = (JSValue) -> JSPromise
public typealias UnderlyingSinkStartCallback = (WritableStreamDefaultController) -> JSValue
public typealias UnderlyingSinkWriteCallback = (JSValue, WritableStreamDefaultController) -> JSPromise
public typealias UnderlyingSinkCloseCallback = () -> JSPromise
public typealias UnderlyingSinkAbortCallback = (JSValue) -> JSPromise
public typealias TransformerStartCallback = (TransformStreamDefaultController) -> JSValue
public typealias TransformerFlushCallback = (TransformStreamDefaultController) -> JSPromise
public typealias TransformerTransformCallback = (JSValue, TransformStreamDefaultController) -> JSPromise
public typealias QueuingStrategySize = (JSValue) -> Double
public typealias NavigatorUserMediaSuccessCallback = (MediaStream) -> Void
public typealias NavigatorUserMediaErrorCallback = (DOMException) -> Void
public typealias AudioDataOutputCallback = (AudioData) -> Void
public typealias VideoFrameOutputCallback = (VideoFrame) -> Void
public typealias EncodedAudioChunkOutputCallback = (EncodedAudioChunk, EncodedAudioChunkMetadata) -> Void
public typealias EncodedVideoChunkOutputCallback = (EncodedVideoChunk, EncodedVideoChunkMetadata) -> Void
public typealias WebCodecsErrorCallback = (DOMException) -> Void
public typealias PerformanceObserverCallback = (PerformanceObserverEntryList, PerformanceObserver, PerformanceObserverCallbackOptions) -> Void
public class UIEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.UIEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _view = ReadonlyAttribute(jsObject: jsObject, name: .view)
        _detail = ReadonlyAttribute(jsObject: jsObject, name: .detail)
        _which = ReadonlyAttribute(jsObject: jsObject, name: .which)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: UIEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @ReadonlyAttribute
    public var view: Window?

    @ReadonlyAttribute
    public var detail: Int32

    @inlinable public func initUIEvent(typeArg: String, bubblesArg: Bool? = nil, cancelableArg: Bool? = nil, viewArg: Window? = nil, detailArg: Int32? = nil) {
        let this = jsObject
        _ = this[.initUIEvent].function!(this: this, arguments: [_toJSValue(typeArg), _toJSValue(bubblesArg), _toJSValue(cancelableArg), _toJSValue(viewArg), _toJSValue(detailArg)])
    }

    @ReadonlyAttribute
    public var which: UInt32
}

public class UIEventInit: BridgedDictionary {
    public convenience init(view: Window?, detail: Int32, which: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.view] = _toJSValue(view)
        object[.detail] = _toJSValue(detail)
        object[.which] = _toJSValue(which)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _view = ReadWriteAttribute(jsObject: object, name: .view)
        _detail = ReadWriteAttribute(jsObject: object, name: .detail)
        _which = ReadWriteAttribute(jsObject: object, name: .which)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var view: Window?

    @ReadWriteAttribute
    public var detail: Int32

    @ReadWriteAttribute
    public var which: UInt32
}

public class ULongRange: BridgedDictionary {
    public convenience init(max: UInt32, min: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.max] = _toJSValue(max)
        object[.min] = _toJSValue(min)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _max = ReadWriteAttribute(jsObject: object, name: .max)
        _min = ReadWriteAttribute(jsObject: object, name: .min)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var max: UInt32

    @ReadWriteAttribute
    public var min: UInt32
}

public extension URL {
    @inlinable class func createObjectURL(obj: Blob_or_MediaSource) -> String {
        let this = constructor!
        return this[.createObjectURL].function!(this: this, arguments: [_toJSValue(obj)]).fromJSValue()!
    }

    @inlinable class func revokeObjectURL(url: String) {
        let this = constructor!
        _ = this[.revokeObjectURL].function!(this: this, arguments: [_toJSValue(url)])
    }
}

public class UnderlyingSink: BridgedDictionary {
    public convenience init(start: @escaping UnderlyingSinkStartCallback, write: @escaping UnderlyingSinkWriteCallback, close: @escaping UnderlyingSinkCloseCallback, abort: @escaping UnderlyingSinkAbortCallback, type: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        ClosureAttribute1[.start, in: object] = start
        ClosureAttribute2[.write, in: object] = write
        ClosureAttribute0[.close, in: object] = close
        ClosureAttribute1[.abort, in: object] = abort
        object[.type] = _toJSValue(type)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _start = ClosureAttribute1(jsObject: object, name: .start)
        _write = ClosureAttribute2(jsObject: object, name: .write)
        _close = ClosureAttribute0(jsObject: object, name: .close)
        _abort = ClosureAttribute1(jsObject: object, name: .abort)
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute1
    public var start: UnderlyingSinkStartCallback

    @ClosureAttribute2
    public var write: UnderlyingSinkWriteCallback

    @ClosureAttribute0
    public var close: UnderlyingSinkCloseCallback

    @ClosureAttribute1
    public var abort: UnderlyingSinkAbortCallback

    @ReadWriteAttribute
    public var type: JSValue
}

public class UnderlyingSource: BridgedDictionary {
    public convenience init(start: @escaping UnderlyingSourceStartCallback, pull: @escaping UnderlyingSourcePullCallback, cancel: @escaping UnderlyingSourceCancelCallback, type: ReadableStreamType, autoAllocateChunkSize: UInt64) {
        let object = JSObject.global[.Object].function!.new()
        ClosureAttribute1[.start, in: object] = start
        ClosureAttribute1[.pull, in: object] = pull
        ClosureAttribute1[.cancel, in: object] = cancel
        object[.type] = _toJSValue(type)
        object[.autoAllocateChunkSize] = _toJSValue(autoAllocateChunkSize)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _start = ClosureAttribute1(jsObject: object, name: .start)
        _pull = ClosureAttribute1(jsObject: object, name: .pull)
        _cancel = ClosureAttribute1(jsObject: object, name: .cancel)
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        _autoAllocateChunkSize = ReadWriteAttribute(jsObject: object, name: .autoAllocateChunkSize)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute1
    public var start: UnderlyingSourceStartCallback

    @ClosureAttribute1
    public var pull: UnderlyingSourcePullCallback

    @ClosureAttribute1
    public var cancel: UnderlyingSourceCancelCallback

    @ReadWriteAttribute
    public var type: ReadableStreamType

    @ReadWriteAttribute
    public var autoAllocateChunkSize: UInt64
}

public class UserActivation: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.UserActivation].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _hasBeenActive = ReadonlyAttribute(jsObject: jsObject, name: .hasBeenActive)
        _isActive = ReadonlyAttribute(jsObject: jsObject, name: .isActive)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var hasBeenActive: Bool

    @ReadonlyAttribute
    public var isActive: Bool
}

public class ValidityState: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ValidityState].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _valueMissing = ReadonlyAttribute(jsObject: jsObject, name: .valueMissing)
        _typeMismatch = ReadonlyAttribute(jsObject: jsObject, name: .typeMismatch)
        _patternMismatch = ReadonlyAttribute(jsObject: jsObject, name: .patternMismatch)
        _tooLong = ReadonlyAttribute(jsObject: jsObject, name: .tooLong)
        _tooShort = ReadonlyAttribute(jsObject: jsObject, name: .tooShort)
        _rangeUnderflow = ReadonlyAttribute(jsObject: jsObject, name: .rangeUnderflow)
        _rangeOverflow = ReadonlyAttribute(jsObject: jsObject, name: .rangeOverflow)
        _stepMismatch = ReadonlyAttribute(jsObject: jsObject, name: .stepMismatch)
        _badInput = ReadonlyAttribute(jsObject: jsObject, name: .badInput)
        _customError = ReadonlyAttribute(jsObject: jsObject, name: .customError)
        _valid = ReadonlyAttribute(jsObject: jsObject, name: .valid)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var valueMissing: Bool

    @ReadonlyAttribute
    public var typeMismatch: Bool

    @ReadonlyAttribute
    public var patternMismatch: Bool

    @ReadonlyAttribute
    public var tooLong: Bool

    @ReadonlyAttribute
    public var tooShort: Bool

    @ReadonlyAttribute
    public var rangeUnderflow: Bool

    @ReadonlyAttribute
    public var rangeOverflow: Bool

    @ReadonlyAttribute
    public var stepMismatch: Bool

    @ReadonlyAttribute
    public var badInput: Bool

    @ReadonlyAttribute
    public var customError: Bool

    @ReadonlyAttribute
    public var valid: Bool
}

public class ValidityStateFlags: BridgedDictionary {
    public convenience init(valueMissing: Bool, typeMismatch: Bool, patternMismatch: Bool, tooLong: Bool, tooShort: Bool, rangeUnderflow: Bool, rangeOverflow: Bool, stepMismatch: Bool, badInput: Bool, customError: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.valueMissing] = _toJSValue(valueMissing)
        object[.typeMismatch] = _toJSValue(typeMismatch)
        object[.patternMismatch] = _toJSValue(patternMismatch)
        object[.tooLong] = _toJSValue(tooLong)
        object[.tooShort] = _toJSValue(tooShort)
        object[.rangeUnderflow] = _toJSValue(rangeUnderflow)
        object[.rangeOverflow] = _toJSValue(rangeOverflow)
        object[.stepMismatch] = _toJSValue(stepMismatch)
        object[.badInput] = _toJSValue(badInput)
        object[.customError] = _toJSValue(customError)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _valueMissing = ReadWriteAttribute(jsObject: object, name: .valueMissing)
        _typeMismatch = ReadWriteAttribute(jsObject: object, name: .typeMismatch)
        _patternMismatch = ReadWriteAttribute(jsObject: object, name: .patternMismatch)
        _tooLong = ReadWriteAttribute(jsObject: object, name: .tooLong)
        _tooShort = ReadWriteAttribute(jsObject: object, name: .tooShort)
        _rangeUnderflow = ReadWriteAttribute(jsObject: object, name: .rangeUnderflow)
        _rangeOverflow = ReadWriteAttribute(jsObject: object, name: .rangeOverflow)
        _stepMismatch = ReadWriteAttribute(jsObject: object, name: .stepMismatch)
        _badInput = ReadWriteAttribute(jsObject: object, name: .badInput)
        _customError = ReadWriteAttribute(jsObject: object, name: .customError)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var valueMissing: Bool

    @ReadWriteAttribute
    public var typeMismatch: Bool

    @ReadWriteAttribute
    public var patternMismatch: Bool

    @ReadWriteAttribute
    public var tooLong: Bool

    @ReadWriteAttribute
    public var tooShort: Bool

    @ReadWriteAttribute
    public var rangeUnderflow: Bool

    @ReadWriteAttribute
    public var rangeOverflow: Bool

    @ReadWriteAttribute
    public var stepMismatch: Bool

    @ReadWriteAttribute
    public var badInput: Bool

    @ReadWriteAttribute
    public var customError: Bool
}

public enum VideoColorPrimaries: JSString, JSValueCompatible {
    case bt709 = "bt709"
    case bt470bg = "bt470bg"
    case smpte170m = "smpte170m"
    case bt2020 = "bt2020"
    case smpte432 = "smpte432"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class VideoColorSpace: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.VideoColorSpace].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _primaries = ReadonlyAttribute(jsObject: jsObject, name: .primaries)
        _transfer = ReadonlyAttribute(jsObject: jsObject, name: .transfer)
        _matrix = ReadonlyAttribute(jsObject: jsObject, name: .matrix)
        _fullRange = ReadonlyAttribute(jsObject: jsObject, name: .fullRange)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(init: VideoColorSpaceInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var primaries: VideoColorPrimaries?

    @ReadonlyAttribute
    public var transfer: VideoTransferCharacteristics?

    @ReadonlyAttribute
    public var matrix: VideoMatrixCoefficients?

    @ReadonlyAttribute
    public var fullRange: Bool?

    @inlinable public func toJSON() -> VideoColorSpaceInit {
        let this = jsObject
        return this[.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class VideoColorSpaceInit: BridgedDictionary {
    public convenience init(primaries: VideoColorPrimaries?, transfer: VideoTransferCharacteristics?, matrix: VideoMatrixCoefficients?, fullRange: Bool?) {
        let object = JSObject.global[.Object].function!.new()
        object[.primaries] = _toJSValue(primaries)
        object[.transfer] = _toJSValue(transfer)
        object[.matrix] = _toJSValue(matrix)
        object[.fullRange] = _toJSValue(fullRange)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _primaries = ReadWriteAttribute(jsObject: object, name: .primaries)
        _transfer = ReadWriteAttribute(jsObject: object, name: .transfer)
        _matrix = ReadWriteAttribute(jsObject: object, name: .matrix)
        _fullRange = ReadWriteAttribute(jsObject: object, name: .fullRange)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var primaries: VideoColorPrimaries?

    @ReadWriteAttribute
    public var transfer: VideoTransferCharacteristics?

    @ReadWriteAttribute
    public var matrix: VideoMatrixCoefficients?

    @ReadWriteAttribute
    public var fullRange: Bool?
}

public class VideoDecoder: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.VideoDecoder].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: .state)
        _decodeQueueSize = ReadonlyAttribute(jsObject: jsObject, name: .decodeQueueSize)
        _ondequeue = ClosureAttribute1Optional(jsObject: jsObject, name: .ondequeue)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(init: VideoDecoderInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var state: CodecState

    @ReadonlyAttribute
    public var decodeQueueSize: UInt32

    @ClosureAttribute1Optional
    public var ondequeue: EventHandler

    @inlinable public func configure(config: VideoDecoderConfig) {
        let this = jsObject
        _ = this[.configure].function!(this: this, arguments: [_toJSValue(config)])
    }

    @inlinable public func decode(chunk: EncodedVideoChunk) {
        let this = jsObject
        _ = this[.decode].function!(this: this, arguments: [_toJSValue(chunk)])
    }

    @inlinable public func flush() -> JSPromise {
        let this = jsObject
        return this[.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func flush() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.flush].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[.reset].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }

    @inlinable public class func isConfigSupported(config: VideoDecoderConfig) -> JSPromise {
        let this = constructor!
        return this[.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public class func isConfigSupported(config: VideoDecoderConfig) async throws -> VideoDecoderSupport {
        let this = constructor!
        let _promise: JSPromise = this[.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class VideoDecoderConfig: BridgedDictionary {
    public convenience init(codec: String, description: AllowSharedBufferSource, codedWidth: UInt32, codedHeight: UInt32, displayAspectWidth: UInt32, displayAspectHeight: UInt32, colorSpace: VideoColorSpaceInit, hardwareAcceleration: HardwareAcceleration, optimizeForLatency: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.codec] = _toJSValue(codec)
        object[.description] = _toJSValue(description)
        object[.codedWidth] = _toJSValue(codedWidth)
        object[.codedHeight] = _toJSValue(codedHeight)
        object[.displayAspectWidth] = _toJSValue(displayAspectWidth)
        object[.displayAspectHeight] = _toJSValue(displayAspectHeight)
        object[.colorSpace] = _toJSValue(colorSpace)
        object[.hardwareAcceleration] = _toJSValue(hardwareAcceleration)
        object[.optimizeForLatency] = _toJSValue(optimizeForLatency)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _codec = ReadWriteAttribute(jsObject: object, name: .codec)
        _description = ReadWriteAttribute(jsObject: object, name: .description)
        _codedWidth = ReadWriteAttribute(jsObject: object, name: .codedWidth)
        _codedHeight = ReadWriteAttribute(jsObject: object, name: .codedHeight)
        _displayAspectWidth = ReadWriteAttribute(jsObject: object, name: .displayAspectWidth)
        _displayAspectHeight = ReadWriteAttribute(jsObject: object, name: .displayAspectHeight)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: .colorSpace)
        _hardwareAcceleration = ReadWriteAttribute(jsObject: object, name: .hardwareAcceleration)
        _optimizeForLatency = ReadWriteAttribute(jsObject: object, name: .optimizeForLatency)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var codec: String

    @ReadWriteAttribute
    public var description: AllowSharedBufferSource

    @ReadWriteAttribute
    public var codedWidth: UInt32

    @ReadWriteAttribute
    public var codedHeight: UInt32

    @ReadWriteAttribute
    public var displayAspectWidth: UInt32

    @ReadWriteAttribute
    public var displayAspectHeight: UInt32

    @ReadWriteAttribute
    public var colorSpace: VideoColorSpaceInit

    @ReadWriteAttribute
    public var hardwareAcceleration: HardwareAcceleration

    @ReadWriteAttribute
    public var optimizeForLatency: Bool
}

public class VideoDecoderInit: BridgedDictionary {
    public convenience init(output: @escaping VideoFrameOutputCallback, error: @escaping WebCodecsErrorCallback) {
        let object = JSObject.global[.Object].function!.new()
        ClosureAttribute1Void[.output, in: object] = output
        ClosureAttribute1Void[.error, in: object] = error
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _output = ClosureAttribute1Void(jsObject: object, name: .output)
        _error = ClosureAttribute1Void(jsObject: object, name: .error)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute1Void
    public var output: VideoFrameOutputCallback

    @ClosureAttribute1Void
    public var error: WebCodecsErrorCallback
}

public class VideoDecoderSupport: BridgedDictionary {
    public convenience init(supported: Bool, config: VideoDecoderConfig) {
        let object = JSObject.global[.Object].function!.new()
        object[.supported] = _toJSValue(supported)
        object[.config] = _toJSValue(config)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _supported = ReadWriteAttribute(jsObject: object, name: .supported)
        _config = ReadWriteAttribute(jsObject: object, name: .config)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var supported: Bool

    @ReadWriteAttribute
    public var config: VideoDecoderConfig
}

public class VideoEncoder: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.VideoEncoder].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _state = ReadonlyAttribute(jsObject: jsObject, name: .state)
        _encodeQueueSize = ReadonlyAttribute(jsObject: jsObject, name: .encodeQueueSize)
        _ondequeue = ClosureAttribute1Optional(jsObject: jsObject, name: .ondequeue)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(init: VideoEncoderInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var state: CodecState

    @ReadonlyAttribute
    public var encodeQueueSize: UInt32

    @ClosureAttribute1Optional
    public var ondequeue: EventHandler

    @inlinable public func configure(config: VideoEncoderConfig) {
        let this = jsObject
        _ = this[.configure].function!(this: this, arguments: [_toJSValue(config)])
    }

    @inlinable public func encode(frame: VideoFrame, options: VideoEncoderEncodeOptions? = nil) {
        let this = jsObject
        _ = this[.encode].function!(this: this, arguments: [_toJSValue(frame), _toJSValue(options)])
    }

    @inlinable public func flush() -> JSPromise {
        let this = jsObject
        return this[.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func flush() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.flush].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[.reset].function!(this: this, arguments: [])
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }

    @inlinable public class func isConfigSupported(config: VideoEncoderConfig) -> JSPromise {
        let this = constructor!
        return this[.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public class func isConfigSupported(config: VideoEncoderConfig) async throws -> VideoEncoderSupport {
        let this = constructor!
        let _promise: JSPromise = this[.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public enum VideoEncoderBitrateMode: JSString, JSValueCompatible {
    case constant = "constant"
    case variable = "variable"
    case quantizer = "quantizer"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class VideoEncoderConfig: BridgedDictionary {
    public convenience init(codec: String, width: UInt32, height: UInt32, displayWidth: UInt32, displayHeight: UInt32, bitrate: UInt64, framerate: Double, hardwareAcceleration: HardwareAcceleration, alpha: AlphaOption, scalabilityMode: String, bitrateMode: VideoEncoderBitrateMode, latencyMode: LatencyMode) {
        let object = JSObject.global[.Object].function!.new()
        object[.codec] = _toJSValue(codec)
        object[.width] = _toJSValue(width)
        object[.height] = _toJSValue(height)
        object[.displayWidth] = _toJSValue(displayWidth)
        object[.displayHeight] = _toJSValue(displayHeight)
        object[.bitrate] = _toJSValue(bitrate)
        object[.framerate] = _toJSValue(framerate)
        object[.hardwareAcceleration] = _toJSValue(hardwareAcceleration)
        object[.alpha] = _toJSValue(alpha)
        object[.scalabilityMode] = _toJSValue(scalabilityMode)
        object[.bitrateMode] = _toJSValue(bitrateMode)
        object[.latencyMode] = _toJSValue(latencyMode)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _codec = ReadWriteAttribute(jsObject: object, name: .codec)
        _width = ReadWriteAttribute(jsObject: object, name: .width)
        _height = ReadWriteAttribute(jsObject: object, name: .height)
        _displayWidth = ReadWriteAttribute(jsObject: object, name: .displayWidth)
        _displayHeight = ReadWriteAttribute(jsObject: object, name: .displayHeight)
        _bitrate = ReadWriteAttribute(jsObject: object, name: .bitrate)
        _framerate = ReadWriteAttribute(jsObject: object, name: .framerate)
        _hardwareAcceleration = ReadWriteAttribute(jsObject: object, name: .hardwareAcceleration)
        _alpha = ReadWriteAttribute(jsObject: object, name: .alpha)
        _scalabilityMode = ReadWriteAttribute(jsObject: object, name: .scalabilityMode)
        _bitrateMode = ReadWriteAttribute(jsObject: object, name: .bitrateMode)
        _latencyMode = ReadWriteAttribute(jsObject: object, name: .latencyMode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var codec: String

    @ReadWriteAttribute
    public var width: UInt32

    @ReadWriteAttribute
    public var height: UInt32

    @ReadWriteAttribute
    public var displayWidth: UInt32

    @ReadWriteAttribute
    public var displayHeight: UInt32

    @ReadWriteAttribute
    public var bitrate: UInt64

    @ReadWriteAttribute
    public var framerate: Double

    @ReadWriteAttribute
    public var hardwareAcceleration: HardwareAcceleration

    @ReadWriteAttribute
    public var alpha: AlphaOption

    @ReadWriteAttribute
    public var scalabilityMode: String

    @ReadWriteAttribute
    public var bitrateMode: VideoEncoderBitrateMode

    @ReadWriteAttribute
    public var latencyMode: LatencyMode
}

public class VideoEncoderEncodeOptions: BridgedDictionary {
    public convenience init(keyFrame: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.keyFrame] = _toJSValue(keyFrame)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _keyFrame = ReadWriteAttribute(jsObject: object, name: .keyFrame)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var keyFrame: Bool
}

public class VideoEncoderInit: BridgedDictionary {
    public convenience init(output: @escaping EncodedVideoChunkOutputCallback, error: @escaping WebCodecsErrorCallback) {
        let object = JSObject.global[.Object].function!.new()
        ClosureAttribute2Void[.output, in: object] = output
        ClosureAttribute1Void[.error, in: object] = error
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _output = ClosureAttribute2Void(jsObject: object, name: .output)
        _error = ClosureAttribute1Void(jsObject: object, name: .error)
        super.init(unsafelyWrapping: object)
    }

    @ClosureAttribute2Void
    public var output: EncodedVideoChunkOutputCallback

    @ClosureAttribute1Void
    public var error: WebCodecsErrorCallback
}

public class VideoEncoderSupport: BridgedDictionary {
    public convenience init(supported: Bool, config: VideoEncoderConfig) {
        let object = JSObject.global[.Object].function!.new()
        object[.supported] = _toJSValue(supported)
        object[.config] = _toJSValue(config)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _supported = ReadWriteAttribute(jsObject: object, name: .supported)
        _config = ReadWriteAttribute(jsObject: object, name: .config)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var supported: Bool

    @ReadWriteAttribute
    public var config: VideoEncoderConfig
}

public enum VideoFacingModeEnum: JSString, JSValueCompatible {
    case user = "user"
    case environment = "environment"
    case left = "left"
    case right = "right"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class VideoFrame: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.VideoFrame].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _format = ReadonlyAttribute(jsObject: jsObject, name: .format)
        _codedWidth = ReadonlyAttribute(jsObject: jsObject, name: .codedWidth)
        _codedHeight = ReadonlyAttribute(jsObject: jsObject, name: .codedHeight)
        _codedRect = ReadonlyAttribute(jsObject: jsObject, name: .codedRect)
        _visibleRect = ReadonlyAttribute(jsObject: jsObject, name: .visibleRect)
        _displayWidth = ReadonlyAttribute(jsObject: jsObject, name: .displayWidth)
        _displayHeight = ReadonlyAttribute(jsObject: jsObject, name: .displayHeight)
        _duration = ReadonlyAttribute(jsObject: jsObject, name: .duration)
        _timestamp = ReadonlyAttribute(jsObject: jsObject, name: .timestamp)
        _colorSpace = ReadonlyAttribute(jsObject: jsObject, name: .colorSpace)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(image: CanvasImageSource, init: VideoFrameInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(image), _toJSValue(`init`)]))
    }

    @inlinable public convenience init(data: AllowSharedBufferSource, init: VideoFrameBufferInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(data), _toJSValue(`init`)]))
    }

    @ReadonlyAttribute
    public var format: VideoPixelFormat?

    @ReadonlyAttribute
    public var codedWidth: UInt32

    @ReadonlyAttribute
    public var codedHeight: UInt32

    @ReadonlyAttribute
    public var codedRect: DOMRectReadOnly?

    @ReadonlyAttribute
    public var visibleRect: DOMRectReadOnly?

    @ReadonlyAttribute
    public var displayWidth: UInt32

    @ReadonlyAttribute
    public var displayHeight: UInt32

    @ReadonlyAttribute
    public var duration: UInt64?

    @ReadonlyAttribute
    public var timestamp: Int64

    @ReadonlyAttribute
    public var colorSpace: VideoColorSpace

    @inlinable public func metadata() -> VideoFrameMetadata {
        let this = jsObject
        return this[.metadata].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func allocationSize(options: VideoFrameCopyToOptions? = nil) -> UInt32 {
        let this = jsObject
        return this[.allocationSize].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public func copyTo(destination: AllowSharedBufferSource, options: VideoFrameCopyToOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.copyTo].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func copyTo(destination: AllowSharedBufferSource, options: VideoFrameCopyToOptions? = nil) async throws -> [PlaneLayout] {
        let this = jsObject
        let _promise: JSPromise = this[.copyTo].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func clone() -> Self {
        let this = jsObject
        return this[.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }
}

public class VideoFrameBufferInit: BridgedDictionary {
    public convenience init(format: VideoPixelFormat, codedWidth: UInt32, codedHeight: UInt32, timestamp: Int64, duration: UInt64, layout: [PlaneLayout], visibleRect: DOMRectInit, displayWidth: UInt32, displayHeight: UInt32, colorSpace: VideoColorSpaceInit, transfer: [ArrayBuffer]) {
        let object = JSObject.global[.Object].function!.new()
        object[.format] = _toJSValue(format)
        object[.codedWidth] = _toJSValue(codedWidth)
        object[.codedHeight] = _toJSValue(codedHeight)
        object[.timestamp] = _toJSValue(timestamp)
        object[.duration] = _toJSValue(duration)
        object[.layout] = _toJSValue(layout)
        object[.visibleRect] = _toJSValue(visibleRect)
        object[.displayWidth] = _toJSValue(displayWidth)
        object[.displayHeight] = _toJSValue(displayHeight)
        object[.colorSpace] = _toJSValue(colorSpace)
        object[.transfer] = _toJSValue(transfer)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: .format)
        _codedWidth = ReadWriteAttribute(jsObject: object, name: .codedWidth)
        _codedHeight = ReadWriteAttribute(jsObject: object, name: .codedHeight)
        _timestamp = ReadWriteAttribute(jsObject: object, name: .timestamp)
        _duration = ReadWriteAttribute(jsObject: object, name: .duration)
        _layout = ReadWriteAttribute(jsObject: object, name: .layout)
        _visibleRect = ReadWriteAttribute(jsObject: object, name: .visibleRect)
        _displayWidth = ReadWriteAttribute(jsObject: object, name: .displayWidth)
        _displayHeight = ReadWriteAttribute(jsObject: object, name: .displayHeight)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: .colorSpace)
        _transfer = ReadWriteAttribute(jsObject: object, name: .transfer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: VideoPixelFormat

    @ReadWriteAttribute
    public var codedWidth: UInt32

    @ReadWriteAttribute
    public var codedHeight: UInt32

    @ReadWriteAttribute
    public var timestamp: Int64

    @ReadWriteAttribute
    public var duration: UInt64

    @ReadWriteAttribute
    public var layout: [PlaneLayout]

    @ReadWriteAttribute
    public var visibleRect: DOMRectInit

    @ReadWriteAttribute
    public var displayWidth: UInt32

    @ReadWriteAttribute
    public var displayHeight: UInt32

    @ReadWriteAttribute
    public var colorSpace: VideoColorSpaceInit

    @ReadWriteAttribute
    public var transfer: [ArrayBuffer]
}

public class VideoFrameCopyToOptions: BridgedDictionary {
    public convenience init(rect: DOMRectInit, layout: [PlaneLayout]) {
        let object = JSObject.global[.Object].function!.new()
        object[.rect] = _toJSValue(rect)
        object[.layout] = _toJSValue(layout)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _rect = ReadWriteAttribute(jsObject: object, name: .rect)
        _layout = ReadWriteAttribute(jsObject: object, name: .layout)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var rect: DOMRectInit

    @ReadWriteAttribute
    public var layout: [PlaneLayout]
}

public class VideoFrameInit: BridgedDictionary {
    public convenience init(duration: UInt64, timestamp: Int64, alpha: AlphaOption, visibleRect: DOMRectInit, displayWidth: UInt32, displayHeight: UInt32, metadata: VideoFrameMetadata) {
        let object = JSObject.global[.Object].function!.new()
        object[.duration] = _toJSValue(duration)
        object[.timestamp] = _toJSValue(timestamp)
        object[.alpha] = _toJSValue(alpha)
        object[.visibleRect] = _toJSValue(visibleRect)
        object[.displayWidth] = _toJSValue(displayWidth)
        object[.displayHeight] = _toJSValue(displayHeight)
        object[.metadata] = _toJSValue(metadata)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _duration = ReadWriteAttribute(jsObject: object, name: .duration)
        _timestamp = ReadWriteAttribute(jsObject: object, name: .timestamp)
        _alpha = ReadWriteAttribute(jsObject: object, name: .alpha)
        _visibleRect = ReadWriteAttribute(jsObject: object, name: .visibleRect)
        _displayWidth = ReadWriteAttribute(jsObject: object, name: .displayWidth)
        _displayHeight = ReadWriteAttribute(jsObject: object, name: .displayHeight)
        _metadata = ReadWriteAttribute(jsObject: object, name: .metadata)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var duration: UInt64

    @ReadWriteAttribute
    public var timestamp: Int64

    @ReadWriteAttribute
    public var alpha: AlphaOption

    @ReadWriteAttribute
    public var visibleRect: DOMRectInit

    @ReadWriteAttribute
    public var displayWidth: UInt32

    @ReadWriteAttribute
    public var displayHeight: UInt32

    @ReadWriteAttribute
    public var metadata: VideoFrameMetadata
}

public class VideoFrameMetadata: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public enum VideoMatrixCoefficients: JSString, JSValueCompatible {
    case rgb = "rgb"
    case bt709 = "bt709"
    case bt470bg = "bt470bg"
    case smpte170m = "smpte170m"
    case bt2020Ncl = "bt2020-ncl"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum VideoPixelFormat: JSString, JSValueCompatible {
    case i420 = "I420"
    case i420A = "I420A"
    case i422 = "I422"
    case i444 = "I444"
    case nV12 = "NV12"
    case rGBA = "RGBA"
    case rGBX = "RGBX"
    case bGRA = "BGRA"
    case bGRX = "BGRX"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum VideoResizeModeEnum: JSString, JSValueCompatible {
    case none = "none"
    case cropAndScale = "crop-and-scale"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class VideoTrack: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.VideoTrack].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _id = ReadonlyAttribute(jsObject: jsObject, name: .id)
        _kind = ReadonlyAttribute(jsObject: jsObject, name: .kind)
        _label = ReadonlyAttribute(jsObject: jsObject, name: .label)
        _language = ReadonlyAttribute(jsObject: jsObject, name: .language)
        _selected = ReadWriteAttribute(jsObject: jsObject, name: .selected)
        _sourceBuffer = ReadonlyAttribute(jsObject: jsObject, name: .sourceBuffer)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var id: String

    @ReadonlyAttribute
    public var kind: String

    @ReadonlyAttribute
    public var label: String

    @ReadonlyAttribute
    public var language: String

    @ReadWriteAttribute
    public var selected: Bool

    @ReadonlyAttribute
    public var sourceBuffer: SourceBuffer?
}

public class VideoTrackList: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.VideoTrackList].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        _selectedIndex = ReadonlyAttribute(jsObject: jsObject, name: .selectedIndex)
        _onchange = ClosureAttribute1Optional(jsObject: jsObject, name: .onchange)
        _onaddtrack = ClosureAttribute1Optional(jsObject: jsObject, name: .onaddtrack)
        _onremovetrack = ClosureAttribute1Optional(jsObject: jsObject, name: .onremovetrack)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var length: UInt32

    @inlinable public subscript(key: Int) -> VideoTrack {
        jsObject[key].fromJSValue()!
    }

    @inlinable public func getTrackById(id: String) -> VideoTrack? {
        let this = jsObject
        return this[.getTrackById].function!(this: this, arguments: [_toJSValue(id)]).fromJSValue()
    }

    @ReadonlyAttribute
    public var selectedIndex: Int32

    @ClosureAttribute1Optional
    public var onchange: EventHandler

    @ClosureAttribute1Optional
    public var onaddtrack: EventHandler

    @ClosureAttribute1Optional
    public var onremovetrack: EventHandler
}

public enum VideoTransferCharacteristics: JSString, JSValueCompatible {
    case bt709 = "bt709"
    case smpte170m = "smpte170m"
    case iec6196621 = "iec61966-2-1"
    case linear = "linear"
    case pq = "pq"
    case hlg = "hlg"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class VisibilityStateEntry: PerformanceEntry {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.VisibilityStateEntry].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _name = ReadonlyAttribute(jsObject: jsObject, name: .name)
        _entryType = ReadonlyAttribute(jsObject: jsObject, name: .entryType)
        _startTime = ReadonlyAttribute(jsObject: jsObject, name: .startTime)
        super.init(unsafelyWrapping: jsObject)
    }

    @usableFromInline let _name: ReadonlyAttribute<String>
    @inlinable override public var name: String { _name.wrappedValue }

    @usableFromInline let _entryType: ReadonlyAttribute<String>
    @inlinable override public var entryType: String { _entryType.wrappedValue }

    @usableFromInline let _startTime: ReadonlyAttribute<DOMHighResTimeStamp>
    @inlinable override public var startTime: DOMHighResTimeStamp { _startTime.wrappedValue }

    // XXX: override of property `duration` removed because the type here is UInt32 but the
    // type in the superclass is DOMHighResTimestamp (Double).
}

public class VisualViewport: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.VisualViewport].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _offsetLeft = ReadonlyAttribute(jsObject: jsObject, name: .offsetLeft)
        _offsetTop = ReadonlyAttribute(jsObject: jsObject, name: .offsetTop)
        _pageLeft = ReadonlyAttribute(jsObject: jsObject, name: .pageLeft)
        _pageTop = ReadonlyAttribute(jsObject: jsObject, name: .pageTop)
        _width = ReadonlyAttribute(jsObject: jsObject, name: .width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: .height)
        _scale = ReadonlyAttribute(jsObject: jsObject, name: .scale)
        _onresize = ClosureAttribute1Optional(jsObject: jsObject, name: .onresize)
        _onscroll = ClosureAttribute1Optional(jsObject: jsObject, name: .onscroll)
        _onscrollend = ClosureAttribute1Optional(jsObject: jsObject, name: .onscrollend)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var offsetLeft: Double

    @ReadonlyAttribute
    public var offsetTop: Double

    @ReadonlyAttribute
    public var pageLeft: Double

    @ReadonlyAttribute
    public var pageTop: Double

    @ReadonlyAttribute
    public var width: Double

    @ReadonlyAttribute
    public var height: Double

    @ReadonlyAttribute
    public var scale: Double

    @ClosureAttribute1Optional
    public var onresize: EventHandler

    @ClosureAttribute1Optional
    public var onscroll: EventHandler

    @ClosureAttribute1Optional
    public var onscrollend: EventHandler
}

public class WheelEvent: MouseEvent {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.WheelEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _deltaX = ReadonlyAttribute(jsObject: jsObject, name: .deltaX)
        _deltaY = ReadonlyAttribute(jsObject: jsObject, name: .deltaY)
        _deltaZ = ReadonlyAttribute(jsObject: jsObject, name: .deltaZ)
        _deltaMode = ReadonlyAttribute(jsObject: jsObject, name: .deltaMode)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, eventInitDict: WheelEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    public static let DOM_DELTA_PIXEL: UInt32 = 0x00

    public static let DOM_DELTA_LINE: UInt32 = 0x01

    public static let DOM_DELTA_PAGE: UInt32 = 0x02

    @ReadonlyAttribute
    public var deltaX: Double

    @ReadonlyAttribute
    public var deltaY: Double

    @ReadonlyAttribute
    public var deltaZ: Double

    @ReadonlyAttribute
    public var deltaMode: UInt32
}

public class WheelEventInit: BridgedDictionary {
    public convenience init(deltaX: Double, deltaY: Double, deltaZ: Double, deltaMode: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.deltaX] = _toJSValue(deltaX)
        object[.deltaY] = _toJSValue(deltaY)
        object[.deltaZ] = _toJSValue(deltaZ)
        object[.deltaMode] = _toJSValue(deltaMode)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _deltaX = ReadWriteAttribute(jsObject: object, name: .deltaX)
        _deltaY = ReadWriteAttribute(jsObject: object, name: .deltaY)
        _deltaZ = ReadWriteAttribute(jsObject: object, name: .deltaZ)
        _deltaMode = ReadWriteAttribute(jsObject: object, name: .deltaMode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var deltaX: Double

    @ReadWriteAttribute
    public var deltaY: Double

    @ReadWriteAttribute
    public var deltaZ: Double

    @ReadWriteAttribute
    public var deltaMode: UInt32
}

public class Worker: EventTarget, AbstractWorker {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.Worker].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: .onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(scriptURL: String, options: WorkerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(scriptURL), _toJSValue(options)]))
    }

    @inlinable public func terminate() {
        let this = jsObject
        _ = this[.terminate].function!(this: this, arguments: [])
    }

    @inlinable public func postMessage(message: JSValue, transfer: [JSObject]) {
        let this = jsObject
        _ = this[.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(transfer)])
    }

    @inlinable public func postMessage(message: JSValue, options: StructuredSerializeOptions? = nil) {
        let this = jsObject
        _ = this[.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(options)])
    }

    @ClosureAttribute1Optional
    public var onmessage: EventHandler

    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public class WorkerOptions: BridgedDictionary {
    public convenience init(type: WorkerType, credentials: RequestCredentials, name: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.credentials] = _toJSValue(credentials)
        object[.name] = _toJSValue(name)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        _credentials = ReadWriteAttribute(jsObject: object, name: .credentials)
        _name = ReadWriteAttribute(jsObject: object, name: .name)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: WorkerType

    @ReadWriteAttribute
    public var credentials: RequestCredentials

    @ReadWriteAttribute
    public var name: String
}

public enum WorkerType: JSString, JSValueCompatible {
    case classic = "classic"
    case module = "module"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

open class Worklet: JSBridgedClass {
    @inlinable open class var constructor: JSFunction? { JSObject.global[.Worklet].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func addModule(moduleURL: String, options: WorkletOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.addModule].function!(this: this, arguments: [_toJSValue(moduleURL), _toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func addModule(moduleURL: String, options: WorkletOptions? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.addModule].function!(this: this, arguments: [_toJSValue(moduleURL), _toJSValue(options)]).fromJSValue()!
        _ = try await _promise.value
    }
}

public class WorkletOptions: BridgedDictionary {
    public convenience init(credentials: RequestCredentials) {
        let object = JSObject.global[.Object].function!.new()
        object[.credentials] = _toJSValue(credentials)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _credentials = ReadWriteAttribute(jsObject: object, name: .credentials)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var credentials: RequestCredentials
}

open class WritableStream: JSBridgedClass {
    @inlinable open class var constructor: JSFunction? { JSObject.global[.WritableStream].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _locked = ReadonlyAttribute(jsObject: jsObject, name: .locked)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(underlyingSink: JSObject? = nil, strategy: QueuingStrategy? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(underlyingSink), _toJSValue(strategy)]))
    }

    @ReadonlyAttribute
    public var locked: Bool

    @inlinable public func abort(reason: JSValue? = nil) -> JSPromise {
        let this = jsObject
        return this[.abort].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func abort(reason: JSValue? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.abort].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func close() -> JSPromise {
        let this = jsObject
        return this[.close].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func close() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.close].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func getWriter() -> WritableStreamDefaultWriter {
        let this = jsObject
        return this[.getWriter].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class WritableStreamDefaultController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.WritableStreamDefaultController].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _signal = ReadonlyAttribute(jsObject: jsObject, name: .signal)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var signal: AbortSignal

    @inlinable public func error(e: JSValue? = nil) {
        let this = jsObject
        _ = this[.error].function!(this: this, arguments: [_toJSValue(e)])
    }
}

public class WritableStreamDefaultWriter: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.WritableStreamDefaultWriter].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _closed = ReadonlyAttribute(jsObject: jsObject, name: .closed)
        _desiredSize = ReadonlyAttribute(jsObject: jsObject, name: .desiredSize)
        _ready = ReadonlyAttribute(jsObject: jsObject, name: .ready)
        self.jsObject = jsObject
    }

    @inlinable public convenience init(stream: WritableStream) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(stream)]))
    }

    @ReadonlyAttribute
    public var closed: JSPromise

    @ReadonlyAttribute
    public var desiredSize: Double?

    @ReadonlyAttribute
    public var ready: JSPromise

    @inlinable public func abort(reason: JSValue? = nil) -> JSPromise {
        let this = jsObject
        return this[.abort].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func abort(reason: JSValue? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.abort].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func close() -> JSPromise {
        let this = jsObject
        return this[.close].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func close() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.close].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func releaseLock() {
        let this = jsObject
        _ = this[.releaseLock].function!(this: this, arguments: [])
    }

    @inlinable public func write(chunk: JSValue? = nil) -> JSPromise {
        let this = jsObject
        return this[.write].function!(this: this, arguments: [_toJSValue(chunk)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func write(chunk: JSValue? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.write].function!(this: this, arguments: [_toJSValue(chunk)]).fromJSValue()!
        _ = try await _promise.value
    }
}

public class XMLDocument: Document {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.XMLDocument].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class XMLHttpRequest: XMLHttpRequestEventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.XMLHttpRequest].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onreadystatechange = ClosureAttribute1Optional(jsObject: jsObject, name: .onreadystatechange)
        _readyState = ReadonlyAttribute(jsObject: jsObject, name: .readyState)
        _timeout = ReadWriteAttribute(jsObject: jsObject, name: .timeout)
        _withCredentials = ReadWriteAttribute(jsObject: jsObject, name: .withCredentials)
        _upload = ReadonlyAttribute(jsObject: jsObject, name: .upload)
        _responseURL = ReadonlyAttribute(jsObject: jsObject, name: .responseURL)
        _status = ReadonlyAttribute(jsObject: jsObject, name: .status)
        _statusText = ReadonlyAttribute(jsObject: jsObject, name: .statusText)
        _responseType = ReadWriteAttribute(jsObject: jsObject, name: .responseType)
        _response = ReadonlyAttribute(jsObject: jsObject, name: .response)
        _responseText = ReadonlyAttribute(jsObject: jsObject, name: .responseText)
        _responseXML = ReadonlyAttribute(jsObject: jsObject, name: .responseXML)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @ClosureAttribute1Optional
    public var onreadystatechange: EventHandler

    public static let UNSENT: UInt16 = 0

    public static let OPENED: UInt16 = 1

    public static let HEADERS_RECEIVED: UInt16 = 2

    public static let LOADING: UInt16 = 3

    public static let DONE: UInt16 = 4

    @ReadonlyAttribute
    public var readyState: UInt16

    @inlinable public func open(method: String, url: String) {
        let this = jsObject
        _ = this[.open].function!(this: this, arguments: [_toJSValue(method), _toJSValue(url)])
    }

    @inlinable public func open(method: String, url: String, async: Bool, username: String? = nil, password: String? = nil) {
        let this = jsObject
        _ = this[.open].function!(this: this, arguments: [_toJSValue(method), _toJSValue(url), _toJSValue(async), _toJSValue(username), _toJSValue(password)])
    }

    @inlinable public func setRequestHeader(name: String, value: String) {
        let this = jsObject
        _ = this[.setRequestHeader].function!(this: this, arguments: [_toJSValue(name), _toJSValue(value)])
    }

    @ReadWriteAttribute
    public var timeout: UInt32

    @ReadWriteAttribute
    public var withCredentials: Bool

    @ReadonlyAttribute
    public var upload: XMLHttpRequestUpload

    @inlinable public func send(body: Document_or_XMLHttpRequestBodyInit? = nil) {
        let this = jsObject
        _ = this[.send].function!(this: this, arguments: [_toJSValue(body)])
    }

    @inlinable public func abort() {
        let this = jsObject
        _ = this[.abort].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var responseURL: String

    @ReadonlyAttribute
    public var status: UInt16

    @ReadonlyAttribute
    public var statusText: String

    @inlinable public func getResponseHeader(name: String) -> String? {
        let this = jsObject
        return this[.getResponseHeader].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }

    @inlinable public func getAllResponseHeaders() -> String {
        let this = jsObject
        return this[.getAllResponseHeaders].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public func overrideMimeType(mime: String) {
        let this = jsObject
        _ = this[.overrideMimeType].function!(this: this, arguments: [_toJSValue(mime)])
    }

    @ReadWriteAttribute
    public var responseType: XMLHttpRequestResponseType

    @ReadonlyAttribute
    public var response: JSValue

    @ReadonlyAttribute
    public var responseText: String

    @ReadonlyAttribute
    public var responseXML: Document?
}

public class XMLHttpRequestEventTarget: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.XMLHttpRequestEventTarget].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _onloadstart = ClosureAttribute1Optional(jsObject: jsObject, name: .onloadstart)
        _onprogress = ClosureAttribute1Optional(jsObject: jsObject, name: .onprogress)
        _onabort = ClosureAttribute1Optional(jsObject: jsObject, name: .onabort)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onerror)
        _onload = ClosureAttribute1Optional(jsObject: jsObject, name: .onload)
        _ontimeout = ClosureAttribute1Optional(jsObject: jsObject, name: .ontimeout)
        _onloadend = ClosureAttribute1Optional(jsObject: jsObject, name: .onloadend)
        super.init(unsafelyWrapping: jsObject)
    }

    @ClosureAttribute1Optional
    public var onloadstart: EventHandler

    @ClosureAttribute1Optional
    public var onprogress: EventHandler

    @ClosureAttribute1Optional
    public var onabort: EventHandler

    @ClosureAttribute1Optional
    public var onerror: EventHandler

    @ClosureAttribute1Optional
    public var onload: EventHandler

    @ClosureAttribute1Optional
    public var ontimeout: EventHandler

    @ClosureAttribute1Optional
    public var onloadend: EventHandler
}

public enum XMLHttpRequestResponseType: JSString, JSValueCompatible {
    case _empty = ""
    case arraybuffer = "arraybuffer"
    case blob = "blob"
    case document = "document"
    case json = "json"
    case text = "text"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class XMLHttpRequestUpload: XMLHttpRequestEventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.XMLHttpRequestUpload].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public class XPathEvaluator: JSBridgedClass, XPathEvaluatorBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.XPathEvaluator].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }
}

public protocol XPathEvaluatorBase: JSBridgedClass {}
public extension XPathEvaluatorBase {
    // XXX: method 'createExpression' is ignored

    // XXX: method 'createNSResolver' is ignored

    // XXX: method 'evaluate' is ignored
}

public class XPathExpression: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.XPathExpression].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func evaluate(contextNode: Node, type: UInt16? = nil, result: XPathResult? = nil) -> XPathResult {
        let this = jsObject
        return this[.evaluate].function!(this: this, arguments: [_toJSValue(contextNode), _toJSValue(type), _toJSValue(result)]).fromJSValue()!
    }
}

public class XPathResult: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.XPathResult].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _resultType = ReadonlyAttribute(jsObject: jsObject, name: .resultType)
        _numberValue = ReadonlyAttribute(jsObject: jsObject, name: .numberValue)
        _stringValue = ReadonlyAttribute(jsObject: jsObject, name: .stringValue)
        _booleanValue = ReadonlyAttribute(jsObject: jsObject, name: .booleanValue)
        _singleNodeValue = ReadonlyAttribute(jsObject: jsObject, name: .singleNodeValue)
        _invalidIteratorState = ReadonlyAttribute(jsObject: jsObject, name: .invalidIteratorState)
        _snapshotLength = ReadonlyAttribute(jsObject: jsObject, name: .snapshotLength)
        self.jsObject = jsObject
    }

    public static let ANY_TYPE: UInt16 = 0

    public static let NUMBER_TYPE: UInt16 = 1

    public static let STRING_TYPE: UInt16 = 2

    public static let BOOLEAN_TYPE: UInt16 = 3

    public static let UNORDERED_NODE_ITERATOR_TYPE: UInt16 = 4

    public static let ORDERED_NODE_ITERATOR_TYPE: UInt16 = 5

    public static let UNORDERED_NODE_SNAPSHOT_TYPE: UInt16 = 6

    public static let ORDERED_NODE_SNAPSHOT_TYPE: UInt16 = 7

    public static let ANY_UNORDERED_NODE_TYPE: UInt16 = 8

    public static let FIRST_ORDERED_NODE_TYPE: UInt16 = 9

    @ReadonlyAttribute
    public var resultType: UInt16

    @ReadonlyAttribute
    public var numberValue: Double

    @ReadonlyAttribute
    public var stringValue: String

    @ReadonlyAttribute
    public var booleanValue: Bool

    @ReadonlyAttribute
    public var singleNodeValue: Node?

    @ReadonlyAttribute
    public var invalidIteratorState: Bool

    @ReadonlyAttribute
    public var snapshotLength: UInt32

    @inlinable public func iterateNext() -> Node? {
        let this = jsObject
        return this[.iterateNext].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public func snapshotItem(index: UInt32) -> Node? {
        let this = jsObject
        return this[.snapshotItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
}

public class XSLTProcessor: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.XSLTProcessor].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public convenience init() {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: []))
    }

    @inlinable public func importStylesheet(style: Node) {
        let this = jsObject
        _ = this[.importStylesheet].function!(this: this, arguments: [_toJSValue(style)])
    }

    @inlinable public func transformToFragment(source: Node, output: Document) -> DocumentFragment {
        let this = jsObject
        return this[.transformToFragment].function!(this: this, arguments: [_toJSValue(source), _toJSValue(output)]).fromJSValue()!
    }

    @inlinable public func transformToDocument(source: Node) -> Document {
        let this = jsObject
        return this[.transformToDocument].function!(this: this, arguments: [_toJSValue(source)]).fromJSValue()!
    }

    @inlinable public func setParameter(namespaceURI: String, localName: String, value: JSValue) {
        let this = jsObject
        _ = this[.setParameter].function!(this: this, arguments: [_toJSValue(namespaceURI), _toJSValue(localName), _toJSValue(value)])
    }

    @inlinable public func getParameter(namespaceURI: String, localName: String) -> JSValue {
        let this = jsObject
        return this[.getParameter].function!(this: this, arguments: [_toJSValue(namespaceURI), _toJSValue(localName)]).fromJSValue()!
    }

    @inlinable public func removeParameter(namespaceURI: String, localName: String) {
        let this = jsObject
        _ = this[.removeParameter].function!(this: this, arguments: [_toJSValue(namespaceURI), _toJSValue(localName)])
    }

    @inlinable public func clearParameters() {
        let this = jsObject
        _ = this[.clearParameters].function!(this: this, arguments: [])
    }

    @inlinable public func reset() {
        let this = jsObject
        _ = this[.reset].function!(this: this, arguments: [])
    }
}

public protocol Any_AddEventListenerOptions_or_Bool: ConvertibleToJSValue {}
extension AddEventListenerOptions: Any_AddEventListenerOptions_or_Bool {}
extension Bool: Any_AddEventListenerOptions_or_Bool {}

public enum AddEventListenerOptions_or_Bool: JSValueCompatible, Any_AddEventListenerOptions_or_Bool {
    case addEventListenerOptions(AddEventListenerOptions)
    case bool(Bool)

    init(_ addEventListenerOptions: AddEventListenerOptions) {
        let val: AddEventListenerOptions_or_Bool = .addEventListenerOptions(addEventListenerOptions)
        self = val
    }

    init(_ bool: Bool) {
        let val: AddEventListenerOptions_or_Bool = .bool(bool)
        self = val
    }

    public var addEventListenerOptions: AddEventListenerOptions? {
        switch self {
        case let .addEventListenerOptions(addEventListenerOptions): return addEventListenerOptions
        default: return nil
        }
    }

    public var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let addEventListenerOptions: AddEventListenerOptions = value.fromJSValue() {
            return .addEventListenerOptions(addEventListenerOptions)
        }
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .addEventListenerOptions(addEventListenerOptions):
            return addEventListenerOptions.jsValue
        case let .bool(bool):
            return bool.jsValue
        }
    }
}

public protocol Any_ArrayBuffer_or_String: ConvertibleToJSValue {}
extension ArrayBuffer: Any_ArrayBuffer_or_String {}
extension String: Any_ArrayBuffer_or_String {}

public enum ArrayBuffer_or_String: JSValueCompatible, Any_ArrayBuffer_or_String {
    case arrayBuffer(ArrayBuffer)
    case string(String)

    init(_ arrayBuffer: ArrayBuffer) {
        let val: ArrayBuffer_or_String = .arrayBuffer(arrayBuffer)
        self = val
    }

    init(_ string: String) {
        let val: ArrayBuffer_or_String = .string(string)
        self = val
    }

    public var arrayBuffer: ArrayBuffer? {
        switch self {
        case let .arrayBuffer(arrayBuffer): return arrayBuffer
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let arrayBuffer: ArrayBuffer = value.fromJSValue() {
            return .arrayBuffer(arrayBuffer)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .arrayBuffer(arrayBuffer):
            return arrayBuffer.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_AudioTrack_or_TextTrack_or_VideoTrack: ConvertibleToJSValue {}
extension AudioTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}
extension TextTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}
extension VideoTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}

public enum AudioTrack_or_TextTrack_or_VideoTrack: JSValueCompatible, Any_AudioTrack_or_TextTrack_or_VideoTrack {
    case audioTrack(AudioTrack)
    case textTrack(TextTrack)
    case videoTrack(VideoTrack)

    init(_ audioTrack: AudioTrack) {
        let val: AudioTrack_or_TextTrack_or_VideoTrack = .audioTrack(audioTrack)
        self = val
    }

    init(_ textTrack: TextTrack) {
        let val: AudioTrack_or_TextTrack_or_VideoTrack = .textTrack(textTrack)
        self = val
    }

    init(_ videoTrack: VideoTrack) {
        let val: AudioTrack_or_TextTrack_or_VideoTrack = .videoTrack(videoTrack)
        self = val
    }

    public var audioTrack: AudioTrack? {
        switch self {
        case let .audioTrack(audioTrack): return audioTrack
        default: return nil
        }
    }

    public var textTrack: TextTrack? {
        switch self {
        case let .textTrack(textTrack): return textTrack
        default: return nil
        }
    }

    public var videoTrack: VideoTrack? {
        switch self {
        case let .videoTrack(videoTrack): return videoTrack
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let audioTrack: AudioTrack = value.fromJSValue() {
            return .audioTrack(audioTrack)
        }
        if let textTrack: TextTrack = value.fromJSValue() {
            return .textTrack(textTrack)
        }
        if let videoTrack: VideoTrack = value.fromJSValue() {
            return .videoTrack(videoTrack)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .audioTrack(audioTrack):
            return audioTrack.jsValue
        case let .textTrack(textTrack):
            return textTrack.jsValue
        case let .videoTrack(videoTrack):
            return videoTrack.jsValue
        }
    }
}

public protocol Any_BlobPart: ConvertibleToJSValue {}
extension Blob: Any_BlobPart {}
extension BufferSource: Any_BlobPart {}
extension String: Any_BlobPart {}

public enum BlobPart: JSValueCompatible, Any_BlobPart {
    case blob(Blob)
    case bufferSource(BufferSource)
    case string(String)

    init(_ blob: Blob) {
        let val: BlobPart = .blob(blob)
        self = val
    }

    init(_ bufferSource: BufferSource) {
        let val: BlobPart = .bufferSource(bufferSource)
        self = val
    }

    init(_ arrayBuffer: ArrayBuffer) {
        let val: BufferSource = .arrayBuffer(arrayBuffer)
        self = .init(val)
    }

    init(_ arrayBufferView: ArrayBufferView) {
        let val: BufferSource = .arrayBufferView(arrayBufferView)
        self = .init(val)
    }

    init(_ string: String) {
        let val: BlobPart = .string(string)
        self = val
    }

    public var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    public var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Bool_or_Double_or_String: ConvertibleToJSValue {}
extension Bool: Any_Bool_or_Double_or_String {}
extension Double: Any_Bool_or_Double_or_String {}
extension String: Any_Bool_or_Double_or_String {}

public enum Bool_or_Double_or_String: JSValueCompatible, Any_Bool_or_Double_or_String {
    case bool(Bool)
    case double(Double)
    case string(String)

    init(_ bool: Bool) {
        let val: Bool_or_Double_or_String = .bool(bool)
        self = val
    }

    init(_ double: Double) {
        let val: Bool_or_Double_or_String = .double(double)
        self = val
    }

    init(_ string: String) {
        let val: Bool_or_Double_or_String = .string(string)
        self = val
    }

    public var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bool(bool):
            return bool.jsValue
        case let .double(double):
            return double.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Bool_or_EventListenerOptions: ConvertibleToJSValue {}
extension Bool: Any_Bool_or_EventListenerOptions {}
extension EventListenerOptions: Any_Bool_or_EventListenerOptions {}

public enum Bool_or_EventListenerOptions: JSValueCompatible, Any_Bool_or_EventListenerOptions {
    case bool(Bool)
    case eventListenerOptions(EventListenerOptions)

    init(_ bool: Bool) {
        let val: Bool_or_EventListenerOptions = .bool(bool)
        self = val
    }

    init(_ eventListenerOptions: EventListenerOptions) {
        let val: Bool_or_EventListenerOptions = .eventListenerOptions(eventListenerOptions)
        self = val
    }

    public var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    public var eventListenerOptions: EventListenerOptions? {
        switch self {
        case let .eventListenerOptions(eventListenerOptions): return eventListenerOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        if let eventListenerOptions: EventListenerOptions = value.fromJSValue() {
            return .eventListenerOptions(eventListenerOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bool(bool):
            return bool.jsValue
        case let .eventListenerOptions(eventListenerOptions):
            return eventListenerOptions.jsValue
        }
    }
}

public protocol Any_Bool_or_MediaTrackConstraints: ConvertibleToJSValue {}
extension Bool: Any_Bool_or_MediaTrackConstraints {}
extension MediaTrackConstraints: Any_Bool_or_MediaTrackConstraints {}

public enum Bool_or_MediaTrackConstraints: JSValueCompatible, Any_Bool_or_MediaTrackConstraints {
    case bool(Bool)
    case mediaTrackConstraints(MediaTrackConstraints)

    init(_ bool: Bool) {
        let val: Bool_or_MediaTrackConstraints = .bool(bool)
        self = val
    }

    init(_ mediaTrackConstraints: MediaTrackConstraints) {
        let val: Bool_or_MediaTrackConstraints = .mediaTrackConstraints(mediaTrackConstraints)
        self = val
    }

    public var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    public var mediaTrackConstraints: MediaTrackConstraints? {
        switch self {
        case let .mediaTrackConstraints(mediaTrackConstraints): return mediaTrackConstraints
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        if let mediaTrackConstraints: MediaTrackConstraints = value.fromJSValue() {
            return .mediaTrackConstraints(mediaTrackConstraints)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bool(bool):
            return bool.jsValue
        case let .mediaTrackConstraints(mediaTrackConstraints):
            return mediaTrackConstraints.jsValue
        }
    }
}

public protocol Any_Bool_or_ScrollIntoViewOptions: ConvertibleToJSValue {}
extension Bool: Any_Bool_or_ScrollIntoViewOptions {}
extension ScrollIntoViewOptions: Any_Bool_or_ScrollIntoViewOptions {}

public enum Bool_or_ScrollIntoViewOptions: JSValueCompatible, Any_Bool_or_ScrollIntoViewOptions {
    case bool(Bool)
    case scrollIntoViewOptions(ScrollIntoViewOptions)

    init(_ bool: Bool) {
        let val: Bool_or_ScrollIntoViewOptions = .bool(bool)
        self = val
    }

    init(_ scrollIntoViewOptions: ScrollIntoViewOptions) {
        let val: Bool_or_ScrollIntoViewOptions = .scrollIntoViewOptions(scrollIntoViewOptions)
        self = val
    }

    public var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    public var scrollIntoViewOptions: ScrollIntoViewOptions? {
        switch self {
        case let .scrollIntoViewOptions(scrollIntoViewOptions): return scrollIntoViewOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        if let scrollIntoViewOptions: ScrollIntoViewOptions = value.fromJSValue() {
            return .scrollIntoViewOptions(scrollIntoViewOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bool(bool):
            return bool.jsValue
        case let .scrollIntoViewOptions(scrollIntoViewOptions):
            return scrollIntoViewOptions.jsValue
        }
    }
}

public protocol Any_CSSPseudoElement_or_Element: ConvertibleToJSValue {}
extension CSSPseudoElement: Any_CSSPseudoElement_or_Element {}
extension Element: Any_CSSPseudoElement_or_Element {}

public enum CSSPseudoElement_or_Element: JSValueCompatible, Any_CSSPseudoElement_or_Element {
    case cssPseudoElement(CSSPseudoElement)
    case element(Element)

    init(_ cssPseudoElement: CSSPseudoElement) {
        let val: CSSPseudoElement_or_Element = .cssPseudoElement(cssPseudoElement)
        self = val
    }

    init(_ element: Element) {
        let val: CSSPseudoElement_or_Element = .element(element)
        self = val
    }

    public var cssPseudoElement: CSSPseudoElement? {
        switch self {
        case let .cssPseudoElement(cssPseudoElement): return cssPseudoElement
        default: return nil
        }
    }

    public var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let cssPseudoElement: CSSPseudoElement = value.fromJSValue() {
            return .cssPseudoElement(cssPseudoElement)
        }
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .cssPseudoElement(cssPseudoElement):
            return cssPseudoElement.jsValue
        case let .element(element):
            return element.jsValue
        }
    }
}

public protocol CanvasImageSourceProtocol: ConvertibleToJSValue {}
extension HTMLCanvasElement: CanvasImageSourceProtocol {}
extension HTMLOrSVGImageElement: CanvasImageSourceProtocol {}
extension HTMLVideoElement: CanvasImageSourceProtocol {}
extension ImageBitmap: CanvasImageSourceProtocol {}
extension OffscreenCanvas: CanvasImageSourceProtocol {}
extension VideoFrame: CanvasImageSourceProtocol {}

public enum CanvasImageSource: JSValueCompatible, CanvasImageSourceProtocol {
    case htmlCanvasElement(HTMLCanvasElement)
    case htmlOrSVGImageElement(HTMLOrSVGImageElement)
    case htmlVideoElement(HTMLVideoElement)
    case imageBitmap(ImageBitmap)
    case offscreenCanvas(OffscreenCanvas)
    case videoFrame(VideoFrame)

    init(_ htmlCanvasElement: HTMLCanvasElement) {
        let val: CanvasImageSource = .htmlCanvasElement(htmlCanvasElement)
        self = val
    }

    init(_ htmlImageElement: HTMLImageElement) {
        let val: CanvasImageSource = .htmlOrSVGImageElement(htmlImageElement)
        self = val
    }

    init(_ htmlVideoElement: HTMLVideoElement) {
        let val: CanvasImageSource = .htmlVideoElement(htmlVideoElement)
        self = val
    }

    init(_ imageBitmap: ImageBitmap) {
        let val: CanvasImageSource = .imageBitmap(imageBitmap)
        self = val
    }

    init(_ offscreenCanvas: OffscreenCanvas) {
        let val: CanvasImageSource = .offscreenCanvas(offscreenCanvas)
        self = val
    }

    init(_ videoFrame: VideoFrame) {
        let val: CanvasImageSource = .videoFrame(videoFrame)
        self = val
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let htmlOrSVGImageElement: HTMLOrSVGImageElement = value.fromJSValue() {
            return .htmlOrSVGImageElement(htmlOrSVGImageElement)
        }
        if let htmlVideoElement: HTMLVideoElement = value.fromJSValue() {
            return .htmlVideoElement(htmlVideoElement)
        }
        if let imageBitmap: ImageBitmap = value.fromJSValue() {
            return .imageBitmap(imageBitmap)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        if let videoFrame: VideoFrame = value.fromJSValue() {
            return .videoFrame(videoFrame)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .htmlOrSVGImageElement(htmlOrSVGImageElement):
            return htmlOrSVGImageElement.jsValue
        case let .htmlVideoElement(htmlVideoElement):
            return htmlVideoElement.jsValue
        case let .imageBitmap(imageBitmap):
            return imageBitmap.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        case let .videoFrame(videoFrame):
            return videoFrame.jsValue
        }
    }
}

public protocol Any_ConstrainBoolean: ConvertibleToJSValue {}
extension Bool: Any_ConstrainBoolean {}
extension ConstrainBooleanParameters: Any_ConstrainBoolean {}

public enum ConstrainBoolean: JSValueCompatible, Any_ConstrainBoolean {
    case bool(Bool)
    case constrainBooleanParameters(ConstrainBooleanParameters)

    init(_ bool: Bool) {
        let val: ConstrainBoolean = .bool(bool)
        self = val
    }

    init(_ constrainBooleanParameters: ConstrainBooleanParameters) {
        let val: ConstrainBoolean = .constrainBooleanParameters(constrainBooleanParameters)
        self = val
    }

    public var bool: Bool? {
        switch self {
        case let .bool(bool): return bool
        default: return nil
        }
    }

    public var constrainBooleanParameters: ConstrainBooleanParameters? {
        switch self {
        case let .constrainBooleanParameters(constrainBooleanParameters): return constrainBooleanParameters
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bool: Bool = value.fromJSValue() {
            return .bool(bool)
        }
        if let constrainBooleanParameters: ConstrainBooleanParameters = value.fromJSValue() {
            return .constrainBooleanParameters(constrainBooleanParameters)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bool(bool):
            return bool.jsValue
        case let .constrainBooleanParameters(constrainBooleanParameters):
            return constrainBooleanParameters.jsValue
        }
    }
}

public protocol Any_ConstrainDOMString: ConvertibleToJSValue {}
extension ConstrainDOMStringParameters: Any_ConstrainDOMString {}
extension String: Any_ConstrainDOMString {}
extension Array: Any_ConstrainDOMString where Element == String {}

public enum ConstrainDOMString: JSValueCompatible, Any_ConstrainDOMString {
    case constrainDOMStringParameters(ConstrainDOMStringParameters)
    case string(String)
    case seq_of_String([String])

    init(_ constrainDOMStringParameters: ConstrainDOMStringParameters) {
        let val: ConstrainDOMString = .constrainDOMStringParameters(constrainDOMStringParameters)
        self = val
    }

    init(_ string: String) {
        let val: ConstrainDOMString = .string(string)
        self = val
    }

    init(_ seq_of_String: [String]) {
        let val: ConstrainDOMString = .seq_of_String(seq_of_String)
        self = val
    }

    public var constrainDOMStringParameters: ConstrainDOMStringParameters? {
        switch self {
        case let .constrainDOMStringParameters(constrainDOMStringParameters): return constrainDOMStringParameters
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var seq_of_String: [String]? {
        switch self {
        case let .seq_of_String(seq_of_String): return seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let constrainDOMStringParameters: ConstrainDOMStringParameters = value.fromJSValue() {
            return .constrainDOMStringParameters(constrainDOMStringParameters)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_String: [String] = value.fromJSValue() {
            return .seq_of_String(seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .constrainDOMStringParameters(constrainDOMStringParameters):
            return constrainDOMStringParameters.jsValue
        case let .string(string):
            return string.jsValue
        case let .seq_of_String(seq_of_String):
            return seq_of_String.jsValue
        }
    }
}

public protocol Any_ConstrainDouble: ConvertibleToJSValue {}
extension ConstrainDoubleRange: Any_ConstrainDouble {}
extension Double: Any_ConstrainDouble {}

public enum ConstrainDouble: JSValueCompatible, Any_ConstrainDouble {
    case constrainDoubleRange(ConstrainDoubleRange)
    case double(Double)

    init(_ constrainDoubleRange: ConstrainDoubleRange) {
        let val: ConstrainDouble = .constrainDoubleRange(constrainDoubleRange)
        self = val
    }

    init(_ double: Double) {
        let val: ConstrainDouble = .double(double)
        self = val
    }

    public var constrainDoubleRange: ConstrainDoubleRange? {
        switch self {
        case let .constrainDoubleRange(constrainDoubleRange): return constrainDoubleRange
        default: return nil
        }
    }

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let constrainDoubleRange: ConstrainDoubleRange = value.fromJSValue() {
            return .constrainDoubleRange(constrainDoubleRange)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .constrainDoubleRange(constrainDoubleRange):
            return constrainDoubleRange.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}

public protocol Any_ConstrainULong: ConvertibleToJSValue {}
extension ConstrainULongRange: Any_ConstrainULong {}
extension UInt32: Any_ConstrainULong {}

public enum ConstrainULong: JSValueCompatible, Any_ConstrainULong {
    case constrainULongRange(ConstrainULongRange)
    case uInt32(UInt32)

    init(_ constrainULongRange: ConstrainULongRange) {
        let val: ConstrainULong = .constrainULongRange(constrainULongRange)
        self = val
    }

    init(_ uInt32: UInt32) {
        let val: ConstrainULong = .uInt32(uInt32)
        self = val
    }

    public var constrainULongRange: ConstrainULongRange? {
        switch self {
        case let .constrainULongRange(constrainULongRange): return constrainULongRange
        default: return nil
        }
    }

    public var uInt32: UInt32? {
        switch self {
        case let .uInt32(uInt32): return uInt32
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let constrainULongRange: ConstrainULongRange = value.fromJSValue() {
            return .constrainULongRange(constrainULongRange)
        }
        if let uInt32: UInt32 = value.fromJSValue() {
            return .uInt32(uInt32)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .constrainULongRange(constrainULongRange):
            return constrainULongRange.jsValue
        case let .uInt32(uInt32):
            return uInt32.jsValue
        }
    }
}

public protocol Any_DOMPointInit_or_Double: ConvertibleToJSValue {}
extension DOMPointInit: Any_DOMPointInit_or_Double {}
extension Double: Any_DOMPointInit_or_Double {}

public enum DOMPointInit_or_Double: JSValueCompatible, Any_DOMPointInit_or_Double {
    case domPointInit(DOMPointInit)
    case double(Double)

    init(_ domPointInit: DOMPointInit) {
        let val: DOMPointInit_or_Double = .domPointInit(domPointInit)
        self = val
    }

    init(_ double: Double) {
        let val: DOMPointInit_or_Double = .double(double)
        self = val
    }

    public var domPointInit: DOMPointInit? {
        switch self {
        case let .domPointInit(domPointInit): return domPointInit
        default: return nil
        }
    }

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let domPointInit: DOMPointInit = value.fromJSValue() {
            return .domPointInit(domPointInit)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .domPointInit(domPointInit):
            return domPointInit.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}

public protocol Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double: ConvertibleToJSValue {}
extension DOMPointInit: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {}
extension Double: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {}
extension Array: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double where Element == DOMPointInit_or_Double {}

public enum DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double: JSValueCompatible, Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {
    case domPointInit(DOMPointInit)
    case double(Double)
    case seq_of_DOMPointInit_or_Double([DOMPointInit_or_Double])

    init(_ domPointInit: DOMPointInit) {
        let val: DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double = .domPointInit(domPointInit)
        self = val
    }

    init(_ double: Double) {
        let val: DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double = .double(double)
        self = val
    }

    init(_ seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double]) {
        let val: DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double = .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double)
        self = val
    }

    public var domPointInit: DOMPointInit? {
        switch self {
        case let .domPointInit(domPointInit): return domPointInit
        default: return nil
        }
    }

    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }

    public var seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double]? {
        switch self {
        case let .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double): return seq_of_DOMPointInit_or_Double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let domPointInit: DOMPointInit = value.fromJSValue() {
            return .domPointInit(domPointInit)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double] = value.fromJSValue() {
            return .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .domPointInit(domPointInit):
            return domPointInit.jsValue
        case let .double(double):
            return double.jsValue
        case let .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double):
            return seq_of_DOMPointInit_or_Double.jsValue
        }
    }
}

public protocol Any_Document_or_XMLHttpRequestBodyInit: ConvertibleToJSValue {}
extension Document: Any_Document_or_XMLHttpRequestBodyInit {}
extension XMLHttpRequestBodyInit: Any_Document_or_XMLHttpRequestBodyInit {}

public enum Document_or_XMLHttpRequestBodyInit: JSValueCompatible, Any_Document_or_XMLHttpRequestBodyInit {
    case document(Document)
    case xmlHttpRequestBodyInit(XMLHttpRequestBodyInit)

    init(_ document: Document) {
        let val: Document_or_XMLHttpRequestBodyInit = .document(document)
        self = val
    }

    init(_ xmlHttpRequestBodyInit: XMLHttpRequestBodyInit) {
        let val: Document_or_XMLHttpRequestBodyInit = .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit)
        self = val
    }

    init(_ blob: Blob) {
        let val: XMLHttpRequestBodyInit = .blob(blob)
        self = .init(val)
    }

    init(_ bufferSource: BufferSource) {
        let val: XMLHttpRequestBodyInit = .bufferSource(bufferSource)
        self = .init(val)
    }

    init(_ arrayBuffer: ArrayBuffer) {
        let val: BufferSource = .arrayBuffer(arrayBuffer)
        self = .init(val)
    }

    init(_ arrayBufferView: ArrayBufferView) {
        let val: BufferSource = .arrayBufferView(arrayBufferView)
        self = .init(val)
    }

    init(_ formData: FormData) {
        let val: XMLHttpRequestBodyInit = .formData(formData)
        self = .init(val)
    }

    init(_ string: String) {
        let val: XMLHttpRequestBodyInit = .string(string)
        self = .init(val)
    }

    init(_ urlSearchParams: URLSearchParams) {
        let val: XMLHttpRequestBodyInit = .urlSearchParams(urlSearchParams)
        self = .init(val)
    }

    public var document: Document? {
        switch self {
        case let .document(document): return document
        default: return nil
        }
    }

    public var xmlHttpRequestBodyInit: XMLHttpRequestBodyInit? {
        switch self {
        case let .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit): return xmlHttpRequestBodyInit
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let document: Document = value.fromJSValue() {
            return .document(document)
        }
        if let xmlHttpRequestBodyInit: XMLHttpRequestBodyInit = value.fromJSValue() {
            return .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .document(document):
            return document.jsValue
        case let .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit):
            return xmlHttpRequestBodyInit.jsValue
        }
    }
}

public protocol Any_ElementCreationOptions_or_String: ConvertibleToJSValue {}
extension ElementCreationOptions: Any_ElementCreationOptions_or_String {}
extension String: Any_ElementCreationOptions_or_String {}

public enum ElementCreationOptions_or_String: JSValueCompatible, Any_ElementCreationOptions_or_String {
    case elementCreationOptions(ElementCreationOptions)
    case string(String)

    init(_ elementCreationOptions: ElementCreationOptions) {
        let val: ElementCreationOptions_or_String = .elementCreationOptions(elementCreationOptions)
        self = val
    }

    init(_ string: String) {
        let val: ElementCreationOptions_or_String = .string(string)
        self = val
    }

    public var elementCreationOptions: ElementCreationOptions? {
        switch self {
        case let .elementCreationOptions(elementCreationOptions): return elementCreationOptions
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let elementCreationOptions: ElementCreationOptions = value.fromJSValue() {
            return .elementCreationOptions(elementCreationOptions)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .elementCreationOptions(elementCreationOptions):
            return elementCreationOptions.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Element_or_HTMLCollection: ConvertibleToJSValue {}
extension Element: Any_Element_or_HTMLCollection {}
extension HTMLCollection: Any_Element_or_HTMLCollection {}

public enum Element_or_HTMLCollection: JSValueCompatible, Any_Element_or_HTMLCollection {
    case element(Element)
    case htmlCollection(HTMLCollection)

    init(_ element: Element) {
        let val: Element_or_HTMLCollection = .element(element)
        self = val
    }

    init(_ htmlCollection: HTMLCollection) {
        let val: Element_or_HTMLCollection = .htmlCollection(htmlCollection)
        self = val
    }

    public var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    public var htmlCollection: HTMLCollection? {
        switch self {
        case let .htmlCollection(htmlCollection): return htmlCollection
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let htmlCollection: HTMLCollection = value.fromJSValue() {
            return .htmlCollection(htmlCollection)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .htmlCollection(htmlCollection):
            return htmlCollection.jsValue
        }
    }
}

public protocol Any_Element_or_RadioNodeList: ConvertibleToJSValue {}
extension Element: Any_Element_or_RadioNodeList {}
extension RadioNodeList: Any_Element_or_RadioNodeList {}

public enum Element_or_RadioNodeList: JSValueCompatible, Any_Element_or_RadioNodeList {
    case element(Element)
    case radioNodeList(RadioNodeList)

    init(_ element: Element) {
        let val: Element_or_RadioNodeList = .element(element)
        self = val
    }

    init(_ radioNodeList: RadioNodeList) {
        let val: Element_or_RadioNodeList = .radioNodeList(radioNodeList)
        self = val
    }

    public var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    public var radioNodeList: RadioNodeList? {
        switch self {
        case let .radioNodeList(radioNodeList): return radioNodeList
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let radioNodeList: RadioNodeList = value.fromJSValue() {
            return .radioNodeList(radioNodeList)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .radioNodeList(radioNodeList):
            return radioNodeList.jsValue
        }
    }
}

public protocol Any_Element_or_Text: ConvertibleToJSValue {}
extension Element: Any_Element_or_Text {}
extension Text: Any_Element_or_Text {}

public enum Element_or_Text: JSValueCompatible, Any_Element_or_Text {
    case element(Element)
    case text(Text)

    init(_ element: Element) {
        let val: Element_or_Text = .element(element)
        self = val
    }

    init(_ text: Text) {
        let val: Element_or_Text = .text(text)
        self = val
    }

    public var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    public var text: Text? {
        switch self {
        case let .text(text): return text
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let text: Text = value.fromJSValue() {
            return .text(text)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .element(element):
            return element.jsValue
        case let .text(text):
            return text.jsValue
        }
    }
}

public protocol Any_Event_or_String: ConvertibleToJSValue {}
extension Event: Any_Event_or_String {}
extension String: Any_Event_or_String {}

public enum Event_or_String: JSValueCompatible, Any_Event_or_String {
    case event(Event)
    case string(String)

    init(_ event: Event) {
        let val: Event_or_String = .event(event)
        self = val
    }

    init(_ string: String) {
        let val: Event_or_String = .string(string)
        self = val
    }

    public var event: Event? {
        switch self {
        case let .event(event): return event
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let event: Event = value.fromJSValue() {
            return .event(event)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .event(event):
            return event.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_File_or_FormData_or_String: ConvertibleToJSValue {}
extension File: Any_File_or_FormData_or_String {}
extension FormData: Any_File_or_FormData_or_String {}
extension String: Any_File_or_FormData_or_String {}

public enum File_or_FormData_or_String: JSValueCompatible, Any_File_or_FormData_or_String {
    case file(File)
    case formData(FormData)
    case string(String)

    init(_ file: File) {
        let val: File_or_FormData_or_String = .file(file)
        self = val
    }

    init(_ formData: FormData) {
        let val: File_or_FormData_or_String = .formData(formData)
        self = val
    }

    init(_ string: String) {
        let val: File_or_FormData_or_String = .string(string)
        self = val
    }

    public var file: File? {
        switch self {
        case let .file(file): return file
        default: return nil
        }
    }

    public var formData: FormData? {
        switch self {
        case let .formData(formData): return formData
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let file: File = value.fromJSValue() {
            return .file(file)
        }
        if let formData: FormData = value.fromJSValue() {
            return .formData(formData)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .file(file):
            return file.jsValue
        case let .formData(formData):
            return formData.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_FormDataEntryValue: ConvertibleToJSValue {}
extension File: Any_FormDataEntryValue {}
extension String: Any_FormDataEntryValue {}

public enum FormDataEntryValue: JSValueCompatible, Any_FormDataEntryValue {
    case file(File)
    case string(String)

    init(_ file: File) {
        let val: FormDataEntryValue = .file(file)
        self = val
    }

    init(_ string: String) {
        let val: FormDataEntryValue = .string(string)
        self = val
    }

    public var file: File? {
        switch self {
        case let .file(file): return file
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let file: File = value.fromJSValue() {
            return .file(file)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .file(file):
            return file.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_GeometryNode: ConvertibleToJSValue {}
extension CSSPseudoElement: Any_GeometryNode {}
extension Document: Any_GeometryNode {}
extension Element: Any_GeometryNode {}
extension Text: Any_GeometryNode {}

public enum GeometryNode: JSValueCompatible, Any_GeometryNode {
    case cssPseudoElement(CSSPseudoElement)
    case document(Document)
    case element(Element)
    case text(Text)

    init(_ cssPseudoElement: CSSPseudoElement) {
        let val: GeometryNode = .cssPseudoElement(cssPseudoElement)
        self = val
    }

    init(_ document: Document) {
        let val: GeometryNode = .document(document)
        self = val
    }

    init(_ element: Element) {
        let val: GeometryNode = .element(element)
        self = val
    }

    init(_ text: Text) {
        let val: GeometryNode = .text(text)
        self = val
    }

    public var cssPseudoElement: CSSPseudoElement? {
        switch self {
        case let .cssPseudoElement(cssPseudoElement): return cssPseudoElement
        default: return nil
        }
    }

    public var document: Document? {
        switch self {
        case let .document(document): return document
        default: return nil
        }
    }

    public var element: Element? {
        switch self {
        case let .element(element): return element
        default: return nil
        }
    }

    public var text: Text? {
        switch self {
        case let .text(text): return text
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let cssPseudoElement: CSSPseudoElement = value.fromJSValue() {
            return .cssPseudoElement(cssPseudoElement)
        }
        if let document: Document = value.fromJSValue() {
            return .document(document)
        }
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let text: Text = value.fromJSValue() {
            return .text(text)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .cssPseudoElement(cssPseudoElement):
            return cssPseudoElement.jsValue
        case let .document(document):
            return document.jsValue
        case let .element(element):
            return element.jsValue
        case let .text(text):
            return text.jsValue
        }
    }
}

public protocol Any_HTMLCanvasElement_or_OffscreenCanvas: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_HTMLCanvasElement_or_OffscreenCanvas {}
extension OffscreenCanvas: Any_HTMLCanvasElement_or_OffscreenCanvas {}

public enum HTMLCanvasElement_or_OffscreenCanvas: JSValueCompatible, Any_HTMLCanvasElement_or_OffscreenCanvas {
    case htmlCanvasElement(HTMLCanvasElement)
    case offscreenCanvas(OffscreenCanvas)

    init(_ htmlCanvasElement: HTMLCanvasElement) {
        let val: HTMLCanvasElement_or_OffscreenCanvas = .htmlCanvasElement(htmlCanvasElement)
        self = val
    }

    init(_ offscreenCanvas: OffscreenCanvas) {
        let val: HTMLCanvasElement_or_OffscreenCanvas = .offscreenCanvas(offscreenCanvas)
        self = val
    }

    public var htmlCanvasElement: HTMLCanvasElement? {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }

    public var offscreenCanvas: OffscreenCanvas? {
        switch self {
        case let .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        }
    }
}

public protocol Any_HTMLElement_or_Int32: ConvertibleToJSValue {}
extension HTMLElement: Any_HTMLElement_or_Int32 {}
extension Int32: Any_HTMLElement_or_Int32 {}

public enum HTMLElement_or_Int32: JSValueCompatible, Any_HTMLElement_or_Int32 {
    case htmlElement(HTMLElement)
    case int32(Int32)

    init(_ htmlElement: HTMLElement) {
        let val: HTMLElement_or_Int32 = .htmlElement(htmlElement)
        self = val
    }

    init(_ int32: Int32) {
        let val: HTMLElement_or_Int32 = .int32(int32)
        self = val
    }

    public var htmlElement: HTMLElement? {
        switch self {
        case let .htmlElement(htmlElement): return htmlElement
        default: return nil
        }
    }

    public var int32: Int32? {
        switch self {
        case let .int32(int32): return int32
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlElement: HTMLElement = value.fromJSValue() {
            return .htmlElement(htmlElement)
        }
        if let int32: Int32 = value.fromJSValue() {
            return .int32(int32)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlElement(htmlElement):
            return htmlElement.jsValue
        case let .int32(int32):
            return int32.jsValue
        }
    }
}

public protocol Any_HTMLOptGroupElement_or_HTMLOptionElement: ConvertibleToJSValue {}
extension HTMLOptGroupElement: Any_HTMLOptGroupElement_or_HTMLOptionElement {}
extension HTMLOptionElement: Any_HTMLOptGroupElement_or_HTMLOptionElement {}

public enum HTMLOptGroupElement_or_HTMLOptionElement: JSValueCompatible, Any_HTMLOptGroupElement_or_HTMLOptionElement {
    case htmlOptGroupElement(HTMLOptGroupElement)
    case htmlOptionElement(HTMLOptionElement)

    init(_ htmlOptGroupElement: HTMLOptGroupElement) {
        let val: HTMLOptGroupElement_or_HTMLOptionElement = .htmlOptGroupElement(htmlOptGroupElement)
        self = val
    }

    init(_ htmlOptionElement: HTMLOptionElement) {
        let val: HTMLOptGroupElement_or_HTMLOptionElement = .htmlOptionElement(htmlOptionElement)
        self = val
    }

    public var htmlOptGroupElement: HTMLOptGroupElement? {
        switch self {
        case let .htmlOptGroupElement(htmlOptGroupElement): return htmlOptGroupElement
        default: return nil
        }
    }

    public var htmlOptionElement: HTMLOptionElement? {
        switch self {
        case let .htmlOptionElement(htmlOptionElement): return htmlOptionElement
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let htmlOptGroupElement: HTMLOptGroupElement = value.fromJSValue() {
            return .htmlOptGroupElement(htmlOptGroupElement)
        }
        if let htmlOptionElement: HTMLOptionElement = value.fromJSValue() {
            return .htmlOptionElement(htmlOptionElement)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlOptGroupElement(htmlOptGroupElement):
            return htmlOptGroupElement.jsValue
        case let .htmlOptionElement(htmlOptionElement):
            return htmlOptionElement.jsValue
        }
    }
}

public protocol Any_HeadersInit: ConvertibleToJSValue {}
extension Dictionary: Any_HeadersInit where Key == String, Value == String {}
extension Array: Any_HeadersInit where Element == [String] {}

public enum HeadersInit: JSValueCompatible, Any_HeadersInit {
    case record_String_to_String([String: String])
    case seq_of_seq_of_String([[String]])

    init(_ record_String_to_String: [String: String]) {
        let val: HeadersInit = .record_String_to_String(record_String_to_String)
        self = val
    }

    init(_ seq_of_seq_of_String: [[String]]) {
        let val: HeadersInit = .seq_of_seq_of_String(seq_of_seq_of_String)
        self = val
    }

    public var record_String_to_String: [String: String]? {
        switch self {
        case let .record_String_to_String(record_String_to_String): return record_String_to_String
        default: return nil
        }
    }

    public var seq_of_seq_of_String: [[String]]? {
        switch self {
        case let .seq_of_seq_of_String(seq_of_seq_of_String): return seq_of_seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let record_String_to_String: [String: String] = value.fromJSValue() {
            return .record_String_to_String(record_String_to_String)
        }
        if let seq_of_seq_of_String: [[String]] = value.fromJSValue() {
            return .seq_of_seq_of_String(seq_of_seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .record_String_to_String(record_String_to_String):
            return record_String_to_String.jsValue
        case let .seq_of_seq_of_String(seq_of_seq_of_String):
            return seq_of_seq_of_String.jsValue
        }
    }
}

public protocol Any_ImageBitmapSource: ConvertibleToJSValue {}
extension Blob: Any_ImageBitmapSource {}
extension CanvasImageSource: Any_ImageBitmapSource {}
extension ImageData: Any_ImageBitmapSource {}

public enum ImageBitmapSource: JSValueCompatible, Any_ImageBitmapSource {
    case blob(Blob)
    case canvasImageSource(CanvasImageSource)
    case imageData(ImageData)

    init(_ blob: Blob) {
        let val: ImageBitmapSource = .blob(blob)
        self = val
    }

    init(_ canvasImageSource: CanvasImageSource) {
        let val: ImageBitmapSource = .canvasImageSource(canvasImageSource)
        self = val
    }

    init(_ htmlCanvasElement: HTMLCanvasElement) {
        let val: CanvasImageSource = .htmlCanvasElement(htmlCanvasElement)
        self = .init(val)
    }

    init(_ htmlImageElement: HTMLImageElement) {
        let val: CanvasImageSource = .htmlOrSVGImageElement(htmlImageElement)
        self = .init(val)
    }

    init(_ htmlVideoElement: HTMLVideoElement) {
        let val: CanvasImageSource = .htmlVideoElement(htmlVideoElement)
        self = .init(val)
    }

    init(_ imageBitmap: ImageBitmap) {
        let val: CanvasImageSource = .imageBitmap(imageBitmap)
        self = .init(val)
    }

    init(_ offscreenCanvas: OffscreenCanvas) {
        let val: CanvasImageSource = .offscreenCanvas(offscreenCanvas)
        self = .init(val)
    }

    init(_ videoFrame: VideoFrame) {
        let val: CanvasImageSource = .videoFrame(videoFrame)
        self = .init(val)
    }

    init(_ imageData: ImageData) {
        let val: ImageBitmapSource = .imageData(imageData)
        self = val
    }

    public var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    public var canvasImageSource: CanvasImageSource? {
        switch self {
        case let .canvasImageSource(canvasImageSource): return canvasImageSource
        default: return nil
        }
    }

    public var imageData: ImageData? {
        switch self {
        case let .imageData(imageData): return imageData
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let canvasImageSource: CanvasImageSource = value.fromJSValue() {
            return .canvasImageSource(canvasImageSource)
        }
        if let imageData: ImageData = value.fromJSValue() {
            return .imageData(imageData)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .canvasImageSource(canvasImageSource):
            return canvasImageSource.jsValue
        case let .imageData(imageData):
            return imageData.jsValue
        }
    }
}

public protocol Any_ImageBufferSource: ConvertibleToJSValue {}
extension BufferSource: Any_ImageBufferSource {}
extension ReadableStream: Any_ImageBufferSource {}

public enum ImageBufferSource: JSValueCompatible, Any_ImageBufferSource {
    case bufferSource(BufferSource)
    case readableStream(ReadableStream)

    init(_ bufferSource: BufferSource) {
        let val: ImageBufferSource = .bufferSource(bufferSource)
        self = val
    }

    init(_ arrayBuffer: ArrayBuffer) {
        let val: BufferSource = .arrayBuffer(arrayBuffer)
        self = .init(val)
    }

    init(_ arrayBufferView: ArrayBufferView) {
        let val: BufferSource = .arrayBufferView(arrayBufferView)
        self = .init(val)
    }

    init(_ readableStream: ReadableStream) {
        let val: ImageBufferSource = .readableStream(readableStream)
        self = val
    }

    public var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    public var readableStream: ReadableStream? {
        switch self {
        case let .readableStream(readableStream): return readableStream
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let readableStream: ReadableStream = value.fromJSValue() {
            return .readableStream(readableStream)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .readableStream(readableStream):
            return readableStream.jsValue
        }
    }
}

public protocol Any_MediaProvider: ConvertibleToJSValue {}
extension Blob: Any_MediaProvider {}
extension MediaSource: Any_MediaProvider {}
extension MediaStream: Any_MediaProvider {}

public enum MediaProvider: JSValueCompatible, Any_MediaProvider {
    case blob(Blob)
    case mediaSource(MediaSource)
    case mediaStream(MediaStream)

    init(_ blob: Blob) {
        let val: MediaProvider = .blob(blob)
        self = val
    }

    init(_ mediaSource: MediaSource) {
        let val: MediaProvider = .mediaSource(mediaSource)
        self = val
    }

    init(_ mediaStream: MediaStream) {
        let val: MediaProvider = .mediaStream(mediaStream)
        self = val
    }

    public var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    public var mediaSource: MediaSource? {
        switch self {
        case let .mediaSource(mediaSource): return mediaSource
        default: return nil
        }
    }

    public var mediaStream: MediaStream? {
        switch self {
        case let .mediaStream(mediaStream): return mediaStream
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let mediaSource: MediaSource = value.fromJSValue() {
            return .mediaSource(mediaSource)
        }
        if let mediaStream: MediaStream = value.fromJSValue() {
            return .mediaStream(mediaStream)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .mediaSource(mediaSource):
            return mediaSource.jsValue
        case let .mediaStream(mediaStream):
            return mediaStream.jsValue
        }
    }
}

public protocol Any_MessageEventSource: ConvertibleToJSValue {}
extension MessagePort: Any_MessageEventSource {}
extension ServiceWorker: Any_MessageEventSource {}
extension WindowProxy: Any_MessageEventSource {}

public enum MessageEventSource: JSValueCompatible, Any_MessageEventSource {
    case messagePort(MessagePort)
    case serviceWorker(ServiceWorker)
    case windowProxy(WindowProxy)

    init(_ messagePort: MessagePort) {
        let val: MessageEventSource = .messagePort(messagePort)
        self = val
    }

    init(_ serviceWorker: ServiceWorker) {
        let val: MessageEventSource = .serviceWorker(serviceWorker)
        self = val
    }

    init(_ windowProxy: WindowProxy) {
        let val: MessageEventSource = .windowProxy(windowProxy)
        self = val
    }

    public var messagePort: MessagePort? {
        switch self {
        case let .messagePort(messagePort): return messagePort
        default: return nil
        }
    }

    public var serviceWorker: ServiceWorker? {
        switch self {
        case let .serviceWorker(serviceWorker): return serviceWorker
        default: return nil
        }
    }

    public var windowProxy: WindowProxy? {
        switch self {
        case let .windowProxy(windowProxy): return windowProxy
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let messagePort: MessagePort = value.fromJSValue() {
            return .messagePort(messagePort)
        }
        if let serviceWorker: ServiceWorker = value.fromJSValue() {
            return .serviceWorker(serviceWorker)
        }
        if let windowProxy: WindowProxy = value.fromJSValue() {
            return .windowProxy(windowProxy)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .messagePort(messagePort):
            return messagePort.jsValue
        case let .serviceWorker(serviceWorker):
            return serviceWorker.jsValue
        case let .windowProxy(windowProxy):
            return windowProxy.jsValue
        }
    }
}

public protocol Any_Node_or_String: ConvertibleToJSValue {}
extension Node: Any_Node_or_String {}
extension String: Any_Node_or_String {}

public enum Node_or_String: JSValueCompatible, Any_Node_or_String {
    case node(Node)
    case string(String)

    init(_ node: Node) {
        let val: Node_or_String = .node(node)
        self = val
    }

    init(_ string: String) {
        let val: Node_or_String = .string(string)
        self = val
    }

    public var node: Node? {
        switch self {
        case let .node(node): return node
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let node: Node = value.fromJSValue() {
            return .node(node)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .node(node):
            return node.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_Path2D_or_String: ConvertibleToJSValue {}
extension Path2D: Any_Path2D_or_String {}
extension String: Any_Path2D_or_String {}

public enum Path2D_or_String: JSValueCompatible, Any_Path2D_or_String {
    case path2D(Path2D)
    case string(String)

    init(_ path2D: Path2D) {
        let val: Path2D_or_String = .path2D(path2D)
        self = val
    }

    init(_ string: String) {
        let val: Path2D_or_String = .string(string)
        self = val
    }

    public var path2D: Path2D? {
        switch self {
        case let .path2D(path2D): return path2D
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let path2D: Path2D = value.fromJSValue() {
            return .path2D(path2D)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .path2D(path2D):
            return path2D.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_ReadableStreamController: ConvertibleToJSValue {}
extension ReadableByteStreamController: Any_ReadableStreamController {}
extension ReadableStreamDefaultController: Any_ReadableStreamController {}

public enum ReadableStreamController: JSValueCompatible, Any_ReadableStreamController {
    case readableByteStreamController(ReadableByteStreamController)
    case readableStreamDefaultController(ReadableStreamDefaultController)

    init(_ readableByteStreamController: ReadableByteStreamController) {
        let val: ReadableStreamController = .readableByteStreamController(readableByteStreamController)
        self = val
    }

    init(_ readableStreamDefaultController: ReadableStreamDefaultController) {
        let val: ReadableStreamController = .readableStreamDefaultController(readableStreamDefaultController)
        self = val
    }

    public var readableByteStreamController: ReadableByteStreamController? {
        switch self {
        case let .readableByteStreamController(readableByteStreamController): return readableByteStreamController
        default: return nil
        }
    }

    public var readableStreamDefaultController: ReadableStreamDefaultController? {
        switch self {
        case let .readableStreamDefaultController(readableStreamDefaultController): return readableStreamDefaultController
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let readableByteStreamController: ReadableByteStreamController = value.fromJSValue() {
            return .readableByteStreamController(readableByteStreamController)
        }
        if let readableStreamDefaultController: ReadableStreamDefaultController = value.fromJSValue() {
            return .readableStreamDefaultController(readableStreamDefaultController)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .readableByteStreamController(readableByteStreamController):
            return readableByteStreamController.jsValue
        case let .readableStreamDefaultController(readableStreamDefaultController):
            return readableStreamDefaultController.jsValue
        }
    }
}

public protocol Any_ReadableStreamReader: ConvertibleToJSValue {}
extension ReadableStreamBYOBReader: Any_ReadableStreamReader {}
extension ReadableStreamDefaultReader: Any_ReadableStreamReader {}

public enum ReadableStreamReader: JSValueCompatible, Any_ReadableStreamReader {
    case readableStreamBYOBReader(ReadableStreamBYOBReader)
    case readableStreamDefaultReader(ReadableStreamDefaultReader)

    init(_ readableStreamBYOBReader: ReadableStreamBYOBReader) {
        let val: ReadableStreamReader = .readableStreamBYOBReader(readableStreamBYOBReader)
        self = val
    }

    init(_ readableStreamDefaultReader: ReadableStreamDefaultReader) {
        let val: ReadableStreamReader = .readableStreamDefaultReader(readableStreamDefaultReader)
        self = val
    }

    public var readableStreamBYOBReader: ReadableStreamBYOBReader? {
        switch self {
        case let .readableStreamBYOBReader(readableStreamBYOBReader): return readableStreamBYOBReader
        default: return nil
        }
    }

    public var readableStreamDefaultReader: ReadableStreamDefaultReader? {
        switch self {
        case let .readableStreamDefaultReader(readableStreamDefaultReader): return readableStreamDefaultReader
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let readableStreamBYOBReader: ReadableStreamBYOBReader = value.fromJSValue() {
            return .readableStreamBYOBReader(readableStreamBYOBReader)
        }
        if let readableStreamDefaultReader: ReadableStreamDefaultReader = value.fromJSValue() {
            return .readableStreamDefaultReader(readableStreamDefaultReader)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .readableStreamBYOBReader(readableStreamBYOBReader):
            return readableStreamBYOBReader.jsValue
        case let .readableStreamDefaultReader(readableStreamDefaultReader):
            return readableStreamDefaultReader.jsValue
        }
    }
}

public protocol Any_RequestInfo: ConvertibleToJSValue {}
extension Request: Any_RequestInfo {}
extension String: Any_RequestInfo {}

public enum RequestInfo: JSValueCompatible, Any_RequestInfo {
    case request(Request)
    case string(String)

    init(_ request: Request) {
        let val: RequestInfo = .request(request)
        self = val
    }

    init(_ string: String) {
        let val: RequestInfo = .string(string)
        self = val
    }

    public var request: Request? {
        switch self {
        case let .request(request): return request
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let request: Request = value.fromJSValue() {
            return .request(request)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .request(request):
            return request.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_String_or_WorkerOptions: ConvertibleToJSValue {}
extension String: Any_String_or_WorkerOptions {}
extension WorkerOptions: Any_String_or_WorkerOptions {}

public enum String_or_WorkerOptions: JSValueCompatible, Any_String_or_WorkerOptions {
    case string(String)
    case workerOptions(WorkerOptions)

    init(_ string: String) {
        let val: String_or_WorkerOptions = .string(string)
        self = val
    }

    init(_ workerOptions: WorkerOptions) {
        let val: String_or_WorkerOptions = .workerOptions(workerOptions)
        self = val
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var workerOptions: WorkerOptions? {
        switch self {
        case let .workerOptions(workerOptions): return workerOptions
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let workerOptions: WorkerOptions = value.fromJSValue() {
            return .workerOptions(workerOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .workerOptions(workerOptions):
            return workerOptions.jsValue
        }
    }
}

public protocol Any_String_or_seq_of_Double: ConvertibleToJSValue {}
extension String: Any_String_or_seq_of_Double {}
extension Array: Any_String_or_seq_of_Double where Element == Double {}

public enum String_or_seq_of_Double: JSValueCompatible, Any_String_or_seq_of_Double {
    case string(String)
    case seq_of_Double([Double])

    init(_ string: String) {
        let val: String_or_seq_of_Double = .string(string)
        self = val
    }

    init(_ seq_of_Double: [Double]) {
        let val: String_or_seq_of_Double = .seq_of_Double(seq_of_Double)
        self = val
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var seq_of_Double: [Double]? {
        switch self {
        case let .seq_of_Double(seq_of_Double): return seq_of_Double
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_Double: [Double] = value.fromJSValue() {
            return .seq_of_Double(seq_of_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .seq_of_Double(seq_of_Double):
            return seq_of_Double.jsValue
        }
    }
}

public protocol Any_String_or_seq_of_String: ConvertibleToJSValue {}
extension String: Any_String_or_seq_of_String {}
extension Array: Any_String_or_seq_of_String where Element == String {}

public enum String_or_seq_of_String: JSValueCompatible, Any_String_or_seq_of_String {
    case string(String)
    case seq_of_String([String])

    init(_ string: String) {
        let val: String_or_seq_of_String = .string(string)
        self = val
    }

    init(_ seq_of_String: [String]) {
        let val: String_or_seq_of_String = .seq_of_String(seq_of_String)
        self = val
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var seq_of_String: [String]? {
        switch self {
        case let .seq_of_String(seq_of_String): return seq_of_String
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_String: [String] = value.fromJSValue() {
            return .seq_of_String(seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .seq_of_String(seq_of_String):
            return seq_of_String.jsValue
        }
    }
}

public protocol Any_TimerHandler: ConvertibleToJSValue {}
extension JSFunction: Any_TimerHandler {}
extension String: Any_TimerHandler {}

public enum TimerHandler: JSValueCompatible, Any_TimerHandler {
    case jsFunction(JSFunction)
    case string(String)

    init(_ jsFunction: JSFunction) {
        let val: TimerHandler = .jsFunction(jsFunction)
        self = val
    }

    init(_ string: String) {
        let val: TimerHandler = .string(string)
        self = val
    }

    public var jsFunction: JSFunction? {
        switch self {
        case let .jsFunction(jsFunction): return jsFunction
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let jsFunction: JSFunction = value.fromJSValue() {
            return .jsFunction(jsFunction)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .jsFunction(jsFunction):
            return jsFunction.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_XMLHttpRequestBodyInit: ConvertibleToJSValue {}
extension Blob: Any_XMLHttpRequestBodyInit {}
extension BufferSource: Any_XMLHttpRequestBodyInit {}
extension FormData: Any_XMLHttpRequestBodyInit {}
extension String: Any_XMLHttpRequestBodyInit {}
extension URLSearchParams: Any_XMLHttpRequestBodyInit {}

public enum XMLHttpRequestBodyInit: JSValueCompatible, Any_XMLHttpRequestBodyInit {
    case blob(Blob)
    case bufferSource(BufferSource)
    case formData(FormData)
    case string(String)
    case urlSearchParams(URLSearchParams)

    init(_ blob: Blob) {
        let val: XMLHttpRequestBodyInit = .blob(blob)
        self = val
    }

    init(_ bufferSource: BufferSource) {
        let val: XMLHttpRequestBodyInit = .bufferSource(bufferSource)
        self = val
    }

    init(_ arrayBuffer: ArrayBuffer) {
        let val: BufferSource = .arrayBuffer(arrayBuffer)
        self = .init(val)
    }

    init(_ arrayBufferView: ArrayBufferView) {
        let val: BufferSource = .arrayBufferView(arrayBufferView)
        self = .init(val)
    }

    init(_ formData: FormData) {
        let val: XMLHttpRequestBodyInit = .formData(formData)
        self = val
    }

    init(_ string: String) {
        let val: XMLHttpRequestBodyInit = .string(string)
        self = val
    }

    init(_ urlSearchParams: URLSearchParams) {
        let val: XMLHttpRequestBodyInit = .urlSearchParams(urlSearchParams)
        self = val
    }

    public var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }

    public var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }

    public var formData: FormData? {
        switch self {
        case let .formData(formData): return formData
        default: return nil
        }
    }

    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }

    public var urlSearchParams: URLSearchParams? {
        switch self {
        case let .urlSearchParams(urlSearchParams): return urlSearchParams
        default: return nil
        }
    }

    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let formData: FormData = value.fromJSValue() {
            return .formData(formData)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let urlSearchParams: URLSearchParams = value.fromJSValue() {
            return .urlSearchParams(urlSearchParams)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .formData(formData):
            return formData.jsValue
        case let .string(string):
            return string.jsValue
        case let .urlSearchParams(urlSearchParams):
            return urlSearchParams.jsValue
        }
    }
}
