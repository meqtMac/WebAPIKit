// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import ECMAScript
import JavaScriptBigIntSupport
import JavaScriptEventLoop
import JavaScriptKit
import WebAPIBase

public enum AlphaOption: JSString, JSValueCompatible {
    case keep = "keep"
    case discard = "discard"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol AnimationFrameProvider: JSBridgedClass {}
public extension AnimationFrameProvider {
    @inlinable func requestAnimationFrame(callback: @escaping FrameRequestCallback) -> UInt32 {
        let this = jsObject
        return this[.requestAnimationFrame].function!(this: this, arguments: [_toJSValue(callback)]).fromJSValue()!
    }
    
    @inlinable func cancelAnimationFrame(handle: UInt32) {
        let this = jsObject
        _ = this[.cancelAnimationFrame].function!(this: this, arguments: [_toJSValue(handle)])
    }
}

public enum AppendMode: JSString, JSValueCompatible {
    case segments = "segments"
    case sequence = "sequence"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AssignedNodesOptions: BridgedDictionary {
    public convenience init(flatten: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.flatten] = _toJSValue(flatten)
        self.init(unsafelyWrapping: object)
    }
    
    public var flatten: Bool {
        get { jsObject[.flatten].fromJSValue()!}
        set { jsObject[.flatten] = newValue.jsValue }
    }
}

public class Attr: Node {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.Attr].function }
    
    public var namespaceURI: String? {
        jsObject[.namespaceURI].fromJSValue()
    }
    
    public var prefix: String? {
        jsObject[.prefix].fromJSValue()
    }
    
    public var localName: String {
        jsObject[.localName].fromJSValue()!
    }
    
    public var name: String {
        jsObject[.name].fromJSValue()!
    }
    
    public var value: String {
        get { jsObject[.value].fromJSValue()!}
        set { jsObject[.value] = newValue.jsValue }
    }
    
    public var ownerElement: Element? {
        jsObject[.ownerElement].fromJSValue()
    }
    
    public var specified: Bool {
        jsObject[.specified].fromJSValue()!
    }
}

public class BarProp: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.BarProp].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var visible: Bool {
        jsObject[.visible].fromJSValue()!
    }
}

public enum BitrateMode: JSString, JSValueCompatible {
    case constant = "constant"
    case variable = "variable"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class BoxQuadOptions: BridgedDictionary {
    public convenience init(box: CSSBoxType, relativeTo: GeometryNode) {
        let object = JSObject.global[.Object].function!.new()
        object[.box] = _toJSValue(box)
        object[.relativeTo] = _toJSValue(relativeTo)
        self.init(unsafelyWrapping: object)
    }
    
    public var box: CSSBoxType {
        get { jsObject[.box].fromJSValue()!}
        set { jsObject[.box] = newValue.jsValue }
    }
    
    public var relativeTo: GeometryNode {
        get { jsObject[.relativeTo].fromJSValue()!}
        set { jsObject[.relativeTo] = newValue.jsValue }
    }
}

public class BroadcastChannel: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.BroadcastChannel].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _onmessage = ClosureAttribute1Optional(jsObject: jsObject, name: .onmessage)
        _onmessageerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onmessageerror)
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public convenience init(name: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(name)]))
    }
    
    public var name: String {
        jsObject[.name].fromJSValue()!
    }
    
    @inlinable public func postMessage(message: JSValue) {
        let this = jsObject
        _ = this[.postMessage].function!(this: this, arguments: [_toJSValue(message)])
    }
    
    @inlinable public func close() {
        let this = jsObject
        _ = this[.close].function!(this: this, arguments: [])
    }
    
    @ClosureAttribute1Optional
    public var onmessage: EventHandler
    
    @ClosureAttribute1Optional
    public var onmessageerror: EventHandler
}

public class ByteLengthQueuingStrategy: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ByteLengthQueuingStrategy].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public convenience init(init: QueuingStrategyInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }
    
    public var highWaterMark: Double {
        jsObject[.highWaterMark].fromJSValue()!
    }
    
    public var size: JSFunction {
        jsObject[.size].fromJSValue()!
    }
}

public class CDATASection: Text {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CDATASection].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
}

public enum CSSBoxType: JSString, JSValueCompatible {
    case margin = "margin"
    case border = "border"
    case padding = "padding"
    case content = "content"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CSSPseudoElement: EventTarget, GeometryUtils {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CSSPseudoElement].function }
    
    public var type: String {
        jsObject[.type].fromJSValue()!
    }
    
    public var element: Element {
        jsObject[.element].fromJSValue()!
    }
    
    public var parent: CSSPseudoElement_or_Element {
        jsObject[.parent].fromJSValue()!
    }
    
    @inlinable public func pseudo(type: String) -> CSSPseudoElement? {
        let this = jsObject
        return this[.pseudo].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()
    }
}

public extension CSSPseudoElement {
    enum CSSPseudoElement_or_Element: JSValueCompatible {
        case cssPseudoElement(CSSPseudoElement)
        case element(Element)
        
        public static func construct(from value: JSValue) -> Self? {
            if let cssPseudoElement: CSSPseudoElement = value.fromJSValue() {
                return .cssPseudoElement(cssPseudoElement)
            }
            if let element: Element = value.fromJSValue() {
                return .element(element)
            }
            return nil
        }
        
        public var jsValue: JSValue {
            switch self {
            case let .cssPseudoElement(cssPseudoElement):
                return cssPseudoElement.jsValue
            case let .element(element):
                return element.jsValue
            }
        }
    }
}

public class CameraDevicePermissionDescriptor: BridgedDictionary {
    public convenience init(panTiltZoom: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.panTiltZoom] = _toJSValue(panTiltZoom)
        self.init(unsafelyWrapping: object)
    }
    
    public var panTiltZoom: Bool {
        get { jsObject[.panTiltZoom].fromJSValue()!}
        set { jsObject[.panTiltZoom] = newValue.jsValue }
    }
}

public enum CanPlayTypeResult: JSString, JSValueCompatible {
    case _empty = ""
    case maybe = "maybe"
    case probably = "probably"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class CanvasRenderingContext2DSettings: BridgedDictionary {
    public convenience init(alpha: Bool, desynchronized: Bool, colorSpace: PredefinedColorSpace, willReadFrequently: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.alpha] = _toJSValue(alpha)
        object[.desynchronized] = _toJSValue(desynchronized)
        object[.colorSpace] = _toJSValue(colorSpace)
        object[.willReadFrequently] = _toJSValue(willReadFrequently)
        self.init(unsafelyWrapping: object)
    }
    
    public var alpha: Bool {
        get { jsObject[.alpha].fromJSValue()!}
        set { jsObject[.alpha] = newValue.jsValue }
    }
    
    public var desynchronized: Bool {
        get { jsObject[.desynchronized].fromJSValue()!}
        set { jsObject[.desynchronized] = newValue.jsValue }
    }
    
    public var colorSpace: PredefinedColorSpace {
        get { jsObject[.colorSpace].fromJSValue()!}
        set { jsObject[.colorSpace] = newValue.jsValue }
    }
    
    public var willReadFrequently: Bool {
        get { jsObject[.willReadFrequently].fromJSValue()!}
        set { jsObject[.willReadFrequently] = newValue.jsValue }
    }
}

public class CaretPosition: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CaretPosition].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var offsetNode: Node {
        jsObject[.offsetNode].fromJSValue()!
    }
    
    public var offset: UInt32 {
        jsObject[.offset].fromJSValue()!
    }
    
    @inlinable public func getClientRect() -> DOMRect? {
        let this = jsObject
        return this[.getClientRect].function!(this: this, arguments: []).fromJSValue()
    }
}

public class CharacterData: Node, NonDocumentTypeChildNode, ChildNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.CharacterData].function }
    
    public var data: String {
        get { jsObject[.data].fromJSValue()!}
        set { jsObject[.data] = newValue.jsValue }
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @inlinable public func substringData(offset: UInt32, count: UInt32) -> String {
        let this = jsObject
        return this[.substringData].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(count)]).fromJSValue()!
    }
    
    @inlinable public func appendData(data: String) {
        let this = jsObject
        _ = this[.appendData].function!(this: this, arguments: [_toJSValue(data)])
    }
    
    @inlinable public func insertData(offset: UInt32, data: String) {
        let this = jsObject
        _ = this[.insertData].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(data)])
    }
    
    @inlinable public func deleteData(offset: UInt32, count: UInt32) {
        let this = jsObject
        _ = this[.deleteData].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(count)])
    }
    
    @inlinable public func replaceData(offset: UInt32, count: UInt32, data: String) {
        let this = jsObject
        _ = this[.replaceData].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(count), _toJSValue(data)])
    }
}

public class CheckVisibilityOptions: BridgedDictionary {
    public convenience init(checkOpacity: Bool, checkVisibilityCSS: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.checkOpacity] = _toJSValue(checkOpacity)
        object[.checkVisibilityCSS] = _toJSValue(checkVisibilityCSS)
        self.init(unsafelyWrapping: object)
    }
    
    public var checkOpacity: Bool {
        get { jsObject[.checkOpacity].fromJSValue()!}
        set { jsObject[.checkOpacity] = newValue.jsValue }
    }
    
    public var checkVisibilityCSS: Bool {
        get { jsObject[.checkVisibilityCSS].fromJSValue()!}
        set { jsObject[.checkVisibilityCSS] = newValue.jsValue }
    }
}

public class ClientQueryOptions: BridgedDictionary {
    public convenience init(includeUncontrolled: Bool, type: ClientType) {
        let object = JSObject.global[.Object].function!.new()
        object[.includeUncontrolled] = _toJSValue(includeUncontrolled)
        object[.type] = _toJSValue(type)
        self.init(unsafelyWrapping: object)
    }
    
    public var includeUncontrolled: Bool {
        get { jsObject[.includeUncontrolled].fromJSValue()!}
        set { jsObject[.includeUncontrolled] = newValue.jsValue }
    }
    
    public var type: ClientType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
}

public enum ClientType: JSString, JSValueCompatible {
    case window = "window"
    case worker = "worker"
    case sharedworker = "sharedworker"
    case all = "all"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CodecState: JSString, JSValueCompatible {
    case unconfigured = "unconfigured"
    case configured = "configured"
    case closed = "closed"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ColorSpaceConversion: JSString, JSValueCompatible {
    case none = "none"
    case `default` = "default"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Comment: CharacterData {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.Comment].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public convenience init(data: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(data)]))
    }
}

public class ConvertCoordinateOptions: BridgedDictionary {
    public convenience init(fromBox: CSSBoxType, toBox: CSSBoxType) {
        let object = JSObject.global[.Object].function!.new()
        object[.fromBox] = _toJSValue(fromBox)
        object[.toBox] = _toJSValue(toBox)
        self.init(unsafelyWrapping: object)
    }
    
    public var fromBox: CSSBoxType {
        get { jsObject[.fromBox].fromJSValue()!}
        set { jsObject[.fromBox] = newValue.jsValue }
    }
    
    public var toBox: CSSBoxType {
        get { jsObject[.toBox].fromJSValue()!}
        set { jsObject[.toBox] = newValue.jsValue }
    }
}

public class CountQueuingStrategy: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.CountQueuingStrategy].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public convenience init(init: QueuingStrategyInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }
    
    public var highWaterMark: Double {
        jsObject[.highWaterMark].fromJSValue()!
    }
    
    public var size: JSFunction {
        jsObject[.size].fromJSValue()!
    }
}

public class DevicePermissionDescriptor: BridgedDictionary {
    public convenience init(deviceId: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.deviceId] = _toJSValue(deviceId)
        self.init(unsafelyWrapping: object)
    }
    
    public var deviceId: String {
        get { jsObject[.deviceId].fromJSValue()!}
        set { jsObject[.deviceId] = newValue.jsValue }
    }
}

public enum EndOfStreamError: JSString, JSValueCompatible {
    case network = "network"
    case decode = "decode"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum EndingType: JSString, JSValueCompatible {
    case transparent = "transparent"
    case native = "native"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class External: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.External].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public func AddSearchProvider() {
        let this = jsObject
        _ = this[.AddSearchProvider].function!(this: this, arguments: [])
    }
    
    @inlinable public func IsSearchProviderInstalled() {
        let this = jsObject
        _ = this[.IsSearchProviderInstalled].function!(this: this, arguments: [])
    }
}

public class FocusOptions: BridgedDictionary {
    public convenience init(preventScroll: Bool, focusVisible: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.preventScroll] = _toJSValue(preventScroll)
        object[.focusVisible] = _toJSValue(focusVisible)
        self.init(unsafelyWrapping: object)
    }
    
    public var preventScroll: Bool {
        get { jsObject[.preventScroll].fromJSValue()!}
        set { jsObject[.preventScroll] = newValue.jsValue }
    }
    
    public var focusVisible: Bool {
        get { jsObject[.focusVisible].fromJSValue()!}
        set { jsObject[.focusVisible] = newValue.jsValue }
    }
}

public enum FrameType: JSString, JSValueCompatible {
    case auxiliary = "auxiliary"
    case topLevel = "top-level"
    case nested = "nested"
    case none = "none"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol GenericTransformStream: JSBridgedClass {}
public extension GenericTransformStream {
    @inlinable var readable: ReadableStream { jsObject[.readable].fromJSValue()! }
    
    @inlinable var writable: WritableStream { jsObject[.writable].fromJSValue()! }
}

public protocol GeometryUtils: JSBridgedClass {}
public extension GeometryUtils {
    @inlinable func getBoxQuads(options: BoxQuadOptions? = nil) -> [DOMQuad] {
        let this = jsObject
        return this[.getBoxQuads].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }
    
    @inlinable func convertQuadFromNode(quad: DOMQuadInit, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMQuad {
        let this = jsObject
        return this[.convertQuadFromNode].function!(this: this, arguments: [_toJSValue(quad), _toJSValue(from), _toJSValue(options)]).fromJSValue()!
    }
    
    @inlinable func convertRectFromNode(rect: DOMRectReadOnly, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMQuad {
        let this = jsObject
        return this[.convertRectFromNode].function!(this: this, arguments: [_toJSValue(rect), _toJSValue(from), _toJSValue(options)]).fromJSValue()!
    }
    
    @inlinable func convertPointFromNode(point: DOMPointInit, from: GeometryNode, options: ConvertCoordinateOptions? = nil) -> DOMPoint {
        let this = jsObject
        return this[.convertPointFromNode].function!(this: this, arguments: [_toJSValue(point), _toJSValue(from), _toJSValue(options)]).fromJSValue()!
    }
}

public class GetRootNodeOptions: BridgedDictionary {
    public convenience init(composed: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.composed] = _toJSValue(composed)
        self.init(unsafelyWrapping: object)
    }
    
    public var composed: Bool {
        get { jsObject[.composed].fromJSValue()!}
        set { jsObject[.composed] = newValue.jsValue }
    }
}

public enum LatencyMode: JSString, JSValueCompatible {
    case quality = "quality"
    case realtime = "realtime"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Location: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Location].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var href: String {
        get { jsObject[.href].fromJSValue()!}
        set { jsObject[.href] = newValue.jsValue }
    }
    
    public var origin: String {
        jsObject[.origin].fromJSValue()!
    }
    
    public var `protocol`: String {
        get { jsObject[.`protocol`].fromJSValue()!}
        set { jsObject[.`protocol`] = newValue.jsValue }
    }
    
    public var host: String {
        get { jsObject[.host].fromJSValue()!}
        set { jsObject[.host] = newValue.jsValue }
    }
    
    public var hostname: String {
        get { jsObject[.hostname].fromJSValue()!}
        set { jsObject[.hostname] = newValue.jsValue }
    }
    
    public var port: String {
        get { jsObject[.port].fromJSValue()!}
        set { jsObject[.port] = newValue.jsValue }
    }
    
    public var pathname: String {
        get { jsObject[.pathname].fromJSValue()!}
        set { jsObject[.pathname] = newValue.jsValue }
    }
    
    public var search: String {
        get { jsObject[.search].fromJSValue()!}
        set { jsObject[.search] = newValue.jsValue }
    }
    
    public var hash: String {
        get { jsObject[.hash].fromJSValue()!}
        set { jsObject[.hash] = newValue.jsValue }
    }
    
    @inlinable public func assign(url: String) {
        let this = jsObject
        _ = this[.assign].function!(this: this, arguments: [_toJSValue(url)])
    }
    
    @inlinable public func replace(url: String) {
        let this = jsObject
        _ = this[.replace].function!(this: this, arguments: [_toJSValue(url)])
    }
    
    @inlinable public func reload() {
        let this = jsObject
        _ = this[.reload].function!(this: this, arguments: [])
    }
    
    public var ancestorOrigins: DOMStringList {
        jsObject[.ancestorOrigins].fromJSValue()!
    }
}

public class MimeType: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.MimeType].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var type: String {
        jsObject[.type].fromJSValue()!
    }
    
    public var description: String {
        jsObject[.description].fromJSValue()!
    }
    
    public var suffixes: String {
        jsObject[.suffixes].fromJSValue()!
    }
    
    public var enabledPlugin: Plugin {
        jsObject[.enabledPlugin].fromJSValue()!
    }
}

public class MimeTypeArray: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.MimeTypeArray].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> MimeType? {
        jsObject[key].fromJSValue()
    }
    
    @inlinable public func item(index: UInt32) -> MimeType? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
    
    @inlinable public subscript(key: String) -> MimeType? {
        jsObject[key].fromJSValue()
    }
    
    @inlinable public func namedItem(name: String) -> MimeType? {
        let this = jsObject
        return this[.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public class MultiCacheQueryOptions: BridgedDictionary {
    public convenience init(cacheName: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.cacheName] = _toJSValue(cacheName)
        self.init(unsafelyWrapping: object)
    }
    
    public var cacheName: String {
        get { jsObject[.cacheName].fromJSValue()!}
        set { jsObject[.cacheName] = newValue.jsValue }
    }
}

public class OverconstrainedError: DOMException {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.OverconstrainedError].function }
    
    @inlinable public convenience init(constraint: String, message: String? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(constraint), _toJSValue(message)]))
    }
    
    public var constraint: String {
        jsObject[.constraint].fromJSValue()!
    }
}

public class PlaneLayout: BridgedDictionary {
    public convenience init(offset: UInt32, stride: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.offset] = _toJSValue(offset)
        object[.stride] = _toJSValue(stride)
        self.init(unsafelyWrapping: object)
    }
    
    public var offset: UInt32 {
        get { jsObject[.offset].fromJSValue()!}
        set { jsObject[.offset] = newValue.jsValue }
    }
    
    public var stride: UInt32 {
        get { jsObject[.stride].fromJSValue()!}
        set { jsObject[.stride] = newValue.jsValue }
    }
}

public class Plugin: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Plugin].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var name: String {
        jsObject[.name].fromJSValue()!
    }
    
    public var description: String {
        jsObject[.description].fromJSValue()!
    }
    
    public var filename: String {
        jsObject[.filename].fromJSValue()!
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> MimeType? {
        jsObject[key].fromJSValue()
    }
    
    @inlinable public func item(index: UInt32) -> MimeType? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
    
    @inlinable public subscript(key: String) -> MimeType? {
        jsObject[key].fromJSValue()
    }
    
    @inlinable public func namedItem(name: String) -> MimeType? {
        let this = jsObject
        return this[.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public class PluginArray: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.PluginArray].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public func refresh() {
        let this = jsObject
        _ = this[.refresh].function!(this: this, arguments: [])
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @inlinable public subscript(key: Int) -> Plugin? {
        jsObject[key].fromJSValue()
    }
    
    @inlinable public func item(index: UInt32) -> Plugin? {
        let this = jsObject
        return this[.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
    
    @inlinable public subscript(key: String) -> Plugin? {
        jsObject[key].fromJSValue()
    }
    
    @inlinable public func namedItem(name: String) -> Plugin? {
        let this = jsObject
        return this[.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public protocol PopoverInvokerElement: JSBridgedClass {}
public extension PopoverInvokerElement {
    @inlinable var popoverTargetElement: Element? {
        get { jsObject[.popoverTargetElement].fromJSValue() }
        nonmutating set { jsObject[.popoverTargetElement] = _toJSValue(newValue) }
    }
    
    @inlinable var popoverTargetAction: String {
        get { jsObject[.popoverTargetAction].fromJSValue()! }
        nonmutating set { jsObject[.popoverTargetAction] = _toJSValue(newValue) }
    }
}

public enum PredefinedColorSpace: JSString, JSValueCompatible {
    case srgb = "srgb"
    case displayP3 = "display-p3"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum PremultiplyAlpha: JSString, JSValueCompatible {
    case none = "none"
    case premultiply = "premultiply"
    case `default` = "default"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ProcessingInstruction: CharacterData {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ProcessingInstruction].function }
    
    public var target: String {
        jsObject[.target].fromJSValue()!
    }
}

public class QueuingStrategy: BridgedDictionary {
    public convenience init(highWaterMark: Double, size: @escaping QueuingStrategySize) {
        let object = JSObject.global[.Object].function!.new()
        object[.highWaterMark] = _toJSValue(highWaterMark)
        ClosureAttribute1[.size, in: object] = size
        self.init(unsafelyWrapping: object)
    }
    
    public required init(unsafelyWrapping object: JSObject) {
        _size = ClosureAttribute1(jsObject: object, name: .size)
        super.init(unsafelyWrapping: object)
    }
    
    public var highWaterMark: Double {
        get { jsObject[.highWaterMark].fromJSValue()!}
        set { jsObject[.highWaterMark] = newValue.jsValue }
    }
    
    @ClosureAttribute1
    public var size: QueuingStrategySize
}

public class QueuingStrategyInit: BridgedDictionary {
    public convenience init(highWaterMark: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.highWaterMark] = _toJSValue(highWaterMark)
        self.init(unsafelyWrapping: object)
    }
    
    public var highWaterMark: Double {
        get { jsObject[.highWaterMark].fromJSValue()!}
        set { jsObject[.highWaterMark] = newValue.jsValue }
    }
}

public class RadioNodeList: NodeList {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.RadioNodeList].function }
    
    public var value: String {
        get { jsObject[.value].fromJSValue()!}
        set { jsObject[.value] = newValue.jsValue }
    }
}

public enum ReadyState: JSString, JSValueCompatible {
    case closed = "closed"
    case open = "open"
    case ended = "ended"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum RecordingState: JSString, JSValueCompatible {
    case inactive = "inactive"
    case recording = "recording"
    case paused = "paused"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ReferrerPolicy: JSString, JSValueCompatible {
    case _empty = ""
    case noReferrer = "no-referrer"
    case noReferrerWhenDowngrade = "no-referrer-when-downgrade"
    case sameOrigin = "same-origin"
    case origin = "origin"
    case strictOrigin = "strict-origin"
    case originWhenCrossOrigin = "origin-when-cross-origin"
    case strictOriginWhenCrossOrigin = "strict-origin-when-cross-origin"
    case unsafeUrl = "unsafe-url"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class RegistrationOptions: BridgedDictionary {
    public convenience init(scope: String, type: WorkerType, updateViaCache: ServiceWorkerUpdateViaCache) {
        let object = JSObject.global[.Object].function!.new()
        object[.scope] = _toJSValue(scope)
        object[.type] = _toJSValue(type)
        object[.updateViaCache] = _toJSValue(updateViaCache)
        self.init(unsafelyWrapping: object)
    }
    
    public var scope: String {
        get { jsObject[.scope].fromJSValue()!}
        set { jsObject[.scope] = newValue.jsValue }
    }
    
    public var type: WorkerType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
    
    public var updateViaCache: ServiceWorkerUpdateViaCache {
        get { jsObject[.updateViaCache].fromJSValue()!}
        set { jsObject[.updateViaCache] = newValue.jsValue }
    }
}

public enum ResizeQuality: JSString, JSValueCompatible {
    case pixelated = "pixelated"
    case low = "low"
    case medium = "medium"
    case high = "high"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class Screen: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Screen].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var availWidth: Int32 {
        jsObject[.availWidth].fromJSValue()!
    }
    
    public var availHeight: Int32 {
        jsObject[.availHeight].fromJSValue()!
    }
    
    public var width: Int32 {
        jsObject[.width].fromJSValue()!
    }
    
    public var height: Int32 {
        jsObject[.height].fromJSValue()!
    }
    
    public var colorDepth: UInt32 {
        jsObject[.colorDepth].fromJSValue()!
    }
    
    public var pixelDepth: UInt32 {
        jsObject[.pixelDepth].fromJSValue()!
    }
}

public enum SelectionMode: JSString, JSValueCompatible {
    case select = "select"
    case start = "start"
    case end = "end"
    case preserve = "preserve"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

open class ShadowRoot: DocumentFragment, DocumentOrShadowRoot {
    @inlinable override open class var constructor: JSFunction? { JSObject.global[.ShadowRoot].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _onslotchange = ClosureAttribute1Optional(jsObject: jsObject, name: .onslotchange)
        super.init(unsafelyWrapping: jsObject)
    }
    
    public var mode: ShadowRootMode {
        jsObject[.mode].fromJSValue()!
    }
    
    public var delegatesFocus: Bool {
        jsObject[.delegatesFocus].fromJSValue()!
    }
    
    public var slotAssignment: SlotAssignmentMode {
        jsObject[.slotAssignment].fromJSValue()!
    }
    
    public var host: Element {
        jsObject[.host].fromJSValue()!
    }
    
    @ClosureAttribute1Optional
    public var onslotchange: EventHandler
}

public class ShadowRootInit: BridgedDictionary {
    public convenience init(mode: ShadowRootMode, delegatesFocus: Bool, slotAssignment: SlotAssignmentMode) {
        let object = JSObject.global[.Object].function!.new()
        object[.mode] = _toJSValue(mode)
        object[.delegatesFocus] = _toJSValue(delegatesFocus)
        object[.slotAssignment] = _toJSValue(slotAssignment)
        self.init(unsafelyWrapping: object)
    }
    
    public var mode: ShadowRootMode {
        get { jsObject[.mode].fromJSValue()!}
        set { jsObject[.mode] = newValue.jsValue }
    }
    
    public var delegatesFocus: Bool {
        get { jsObject[.delegatesFocus].fromJSValue()!}
        set { jsObject[.delegatesFocus] = newValue.jsValue }
    }
    
    public var slotAssignment: SlotAssignmentMode {
        get { jsObject[.slotAssignment].fromJSValue()!}
        set { jsObject[.slotAssignment] = newValue.jsValue }
    }
}

public enum ShadowRootMode: JSString, JSValueCompatible {
    case open = "open"
    case closed = "closed"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum SlotAssignmentMode: JSString, JSValueCompatible {
    case manual = "manual"
    case named = "named"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol Slottable: JSBridgedClass {}
public extension Slottable {
    @inlinable var assignedSlot: HTMLSlotElement? { jsObject[.assignedSlot].fromJSValue() }
}

public class SourceBuffer: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SourceBuffer].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _onupdatestart = ClosureAttribute1Optional(jsObject: jsObject, name: .onupdatestart)
        _onupdate = ClosureAttribute1Optional(jsObject: jsObject, name: .onupdate)
        _onupdateend = ClosureAttribute1Optional(jsObject: jsObject, name: .onupdateend)
        _onerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onerror)
        _onabort = ClosureAttribute1Optional(jsObject: jsObject, name: .onabort)
        super.init(unsafelyWrapping: jsObject)
    }
    
    public var mode: AppendMode {
        get { jsObject[.mode].fromJSValue()!}
        set { jsObject[.mode] = newValue.jsValue }
    }
    
    public var updating: Bool {
        jsObject[.updating].fromJSValue()!
    }
    
    public var buffered: TimeRanges {
        jsObject[.buffered].fromJSValue()!
    }
    
    public var timestampOffset: Double {
        get { jsObject[.timestampOffset].fromJSValue()!}
        set { jsObject[.timestampOffset] = newValue.jsValue }
    }
    
    public var audioTracks: AudioTrackList {
        jsObject[.audioTracks].fromJSValue()!
    }
    
    public var videoTracks: VideoTrackList {
        jsObject[.videoTracks].fromJSValue()!
    }
    
    public var textTracks: TextTrackList {
        jsObject[.textTracks].fromJSValue()!
    }
    
    public var appendWindowStart: Double {
        get { jsObject[.appendWindowStart].fromJSValue()!}
        set { jsObject[.appendWindowStart] = newValue.jsValue }
    }
    
    public var appendWindowEnd: Double {
        get { jsObject[.appendWindowEnd].fromJSValue()!}
        set { jsObject[.appendWindowEnd] = newValue.jsValue }
    }
    
    @ClosureAttribute1Optional
    public var onupdatestart: EventHandler
    
    @ClosureAttribute1Optional
    public var onupdate: EventHandler
    
    @ClosureAttribute1Optional
    public var onupdateend: EventHandler
    
    @ClosureAttribute1Optional
    public var onerror: EventHandler
    
    @ClosureAttribute1Optional
    public var onabort: EventHandler
    
    @inlinable public func appendBuffer(data: BufferSource) {
        let this = jsObject
        _ = this[.appendBuffer].function!(this: this, arguments: [_toJSValue(data)])
    }
    
    @inlinable public func abort() {
        let this = jsObject
        _ = this[.abort].function!(this: this, arguments: [])
    }
    
    @inlinable public func changeType(type: String) {
        let this = jsObject
        _ = this[.changeType].function!(this: this, arguments: [_toJSValue(type)])
    }
    
    @inlinable public func remove(start: Double, end: Double) {
        let this = jsObject
        _ = this[.remove].function!(this: this, arguments: [_toJSValue(start), _toJSValue(end)])
    }
}

public class SourceBufferList: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.SourceBufferList].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _onaddsourcebuffer = ClosureAttribute1Optional(jsObject: jsObject, name: .onaddsourcebuffer)
        _onremovesourcebuffer = ClosureAttribute1Optional(jsObject: jsObject, name: .onremovesourcebuffer)
        super.init(unsafelyWrapping: jsObject)
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @ClosureAttribute1Optional
    public var onaddsourcebuffer: EventHandler
    
    @ClosureAttribute1Optional
    public var onremovesourcebuffer: EventHandler
    
    @inlinable public subscript(key: Int) -> SourceBuffer {
        jsObject[key].fromJSValue()!
    }
}

public class Storage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Storage].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @inlinable public func key(index: UInt32) -> String? {
        let this = jsObject
        return this[.key].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
    
    @inlinable public func getItem(key: String) -> String? {
        let this = jsObject
        return this[.getItem].function!(this: this, arguments: [_toJSValue(key)]).fromJSValue()
    }
    
    @inlinable public subscript(key: String) -> String? {
        get {
            jsObject[key].fromJSValue()
        }
        set {
            jsObject[key] = _toJSValue(newValue)
        }
    }
    
    @inlinable public func removeValue(forKey key: String) {
        _ = JSObject.global.Reflect.deleteProperty(jsObject, _toJSValue(key))
    }
    
    @inlinable public func clear() {
        let this = jsObject
        _ = this[.clear].function!(this: this, arguments: [])
    }
}

public class StreamPipeOptions: BridgedDictionary {
    public convenience init(preventClose: Bool, preventAbort: Bool, preventCancel: Bool, signal: AbortSignal) {
        let object = JSObject.global[.Object].function!.new()
        object[.preventClose] = _toJSValue(preventClose)
        object[.preventAbort] = _toJSValue(preventAbort)
        object[.preventCancel] = _toJSValue(preventCancel)
        object[.signal] = _toJSValue(signal)
        self.init(unsafelyWrapping: object)
    }
    
    public var preventClose: Bool {
        get { jsObject[.preventClose].fromJSValue()!}
        set { jsObject[.preventClose] = newValue.jsValue }
    }
    
    public var preventAbort: Bool {
        get { jsObject[.preventAbort].fromJSValue()!}
        set { jsObject[.preventAbort] = newValue.jsValue }
    }
    
    public var preventCancel: Bool {
        get { jsObject[.preventCancel].fromJSValue()!}
        set { jsObject[.preventCancel] = newValue.jsValue }
    }
    
    public var signal: AbortSignal {
        get { jsObject[.signal].fromJSValue()!}
        set { jsObject[.signal] = newValue.jsValue }
    }
}

public class StructuredSerializeOptions: BridgedDictionary {
    public convenience init(transfer: [JSObject]) {
        let object = JSObject.global[.Object].function!.new()
        object[.transfer] = _toJSValue(transfer)
        self.init(unsafelyWrapping: object)
    }
    
    public var transfer: [JSObject] {
        get { jsObject[.transfer].fromJSValue()!}
        set { jsObject[.transfer] = newValue.jsValue }
    }
}

public class SvcOutputMetadata: BridgedDictionary {
    public convenience init(temporalLayerId: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.temporalLayerId] = _toJSValue(temporalLayerId)
        self.init(unsafelyWrapping: object)
    }
    
    public var temporalLayerId: UInt32 {
        get { jsObject[.temporalLayerId].fromJSValue()!}
        set { jsObject[.temporalLayerId] = newValue.jsValue }
    }
}
public class TreeWalker: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.TreeWalker].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var root: Node {
        jsObject[.root].fromJSValue()!
    }
    
    public var whatToShow: UInt32 {
        jsObject[.whatToShow].fromJSValue()!
    }
    
    // XXX: member 'filter' is ignored
    
    public var currentNode: Node {
        get { jsObject[.currentNode].fromJSValue()!}
        set { jsObject[.currentNode] = newValue.jsValue }
    }
    
    @inlinable public func parentNode() -> Node? {
        let this = jsObject
        return this[.parentNode].function!(this: this, arguments: []).fromJSValue()
    }
    
    @inlinable public func firstChild() -> Node? {
        let this = jsObject
        return this[.firstChild].function!(this: this, arguments: []).fromJSValue()
    }
    
    @inlinable public func lastChild() -> Node? {
        let this = jsObject
        return this[.lastChild].function!(this: this, arguments: []).fromJSValue()
    }
    
    @inlinable public func previousSibling() -> Node? {
        let this = jsObject
        return this[.previousSibling].function!(this: this, arguments: []).fromJSValue()
    }
    
    @inlinable public func nextSibling() -> Node? {
        let this = jsObject
        return this[.nextSibling].function!(this: this, arguments: []).fromJSValue()
    }
    
    @inlinable public func previousNode() -> Node? {
        let this = jsObject
        return this[.previousNode].function!(this: this, arguments: []).fromJSValue()
    }
    
    @inlinable public func nextNode() -> Node? {
        let this = jsObject
        return this[.nextNode].function!(this: this, arguments: []).fromJSValue()
    }
}

public extension URL {
    @inlinable class func createObjectURL(obj: Blob_or_MediaSource) -> String {
        let this = constructor!
        return this[.createObjectURL].function!(this: this, arguments: [_toJSValue(obj)]).fromJSValue()!
    }
    
    @inlinable class func revokeObjectURL(url: String) {
        let this = constructor!
        _ = this[.revokeObjectURL].function!(this: this, arguments: [_toJSValue(url)])
    }
}

public class UnderlyingSink: BridgedDictionary {
    public convenience init(start: @escaping UnderlyingSinkStartCallback, write: @escaping UnderlyingSinkWriteCallback, close: @escaping UnderlyingSinkCloseCallback, abort: @escaping UnderlyingSinkAbortCallback, type: JSValue) {
        let object = JSObject.global[.Object].function!.new()
        ClosureAttribute1[.start, in: object] = start
        ClosureAttribute2[.write, in: object] = write
        ClosureAttribute0[.close, in: object] = close
        ClosureAttribute1[.abort, in: object] = abort
        object[.type] = _toJSValue(type)
        self.init(unsafelyWrapping: object)
    }
    
    public required init(unsafelyWrapping object: JSObject) {
        _start = ClosureAttribute1(jsObject: object, name: .start)
        _write = ClosureAttribute2(jsObject: object, name: .write)
        _close = ClosureAttribute0(jsObject: object, name: .close)
        _abort = ClosureAttribute1(jsObject: object, name: .abort)
        super.init(unsafelyWrapping: object)
    }
    
    @ClosureAttribute1
    public var start: UnderlyingSinkStartCallback
    
    @ClosureAttribute2
    public var write: UnderlyingSinkWriteCallback
    
    @ClosureAttribute0
    public var close: UnderlyingSinkCloseCallback
    
    @ClosureAttribute1
    public var abort: UnderlyingSinkAbortCallback
    
    public var type: JSValue {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
}

public class UnderlyingSource: BridgedDictionary {
    public convenience init(start: @escaping UnderlyingSourceStartCallback, pull: @escaping UnderlyingSourcePullCallback, cancel: @escaping UnderlyingSourceCancelCallback, type: ReadableStreamType, autoAllocateChunkSize: UInt64) {
        let object = JSObject.global[.Object].function!.new()
        ClosureAttribute1[.start, in: object] = start
        ClosureAttribute1[.pull, in: object] = pull
        ClosureAttribute1[.cancel, in: object] = cancel
        object[.type] = _toJSValue(type)
        object[.autoAllocateChunkSize] = _toJSValue(autoAllocateChunkSize)
        self.init(unsafelyWrapping: object)
    }
    
    public required init(unsafelyWrapping object: JSObject) {
        _start = ClosureAttribute1(jsObject: object, name: .start)
        _pull = ClosureAttribute1(jsObject: object, name: .pull)
        _cancel = ClosureAttribute1(jsObject: object, name: .cancel)
        super.init(unsafelyWrapping: object)
    }
    
    @ClosureAttribute1
    public var start: UnderlyingSourceStartCallback
    
    @ClosureAttribute1
    public var pull: UnderlyingSourcePullCallback
    
    @ClosureAttribute1
    public var cancel: UnderlyingSourceCancelCallback
    
    public var type: ReadableStreamType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
    
    public var autoAllocateChunkSize: UInt64 {
        get { jsObject[.autoAllocateChunkSize].fromJSValue()!}
        set { jsObject[.autoAllocateChunkSize] = newValue.jsValue }
    }
}

public class UserActivation: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.UserActivation].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var hasBeenActive: Bool {
        jsObject[.hasBeenActive].fromJSValue()!
    }
    
    public var isActive: Bool {
        jsObject[.isActive].fromJSValue()!
    }
}

public class ValidityState: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.ValidityState].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var valueMissing: Bool {
        jsObject[.valueMissing].fromJSValue()!
    }
    
    public var typeMismatch: Bool {
        jsObject[.typeMismatch].fromJSValue()!
    }
    
    public var patternMismatch: Bool {
        jsObject[.patternMismatch].fromJSValue()!
    }
    
    public var tooLong: Bool {
        jsObject[.tooLong].fromJSValue()!
    }
    
    public var tooShort: Bool {
        jsObject[.tooShort].fromJSValue()!
    }
    
    public var rangeUnderflow: Bool {
        jsObject[.rangeUnderflow].fromJSValue()!
    }
    
    public var rangeOverflow: Bool {
        jsObject[.rangeOverflow].fromJSValue()!
    }
    
    public var stepMismatch: Bool {
        jsObject[.stepMismatch].fromJSValue()!
    }
    
    public var badInput: Bool {
        jsObject[.badInput].fromJSValue()!
    }
    
    public var customError: Bool {
        jsObject[.customError].fromJSValue()!
    }
    
    public var valid: Bool {
        jsObject[.valid].fromJSValue()!
    }
}

public class ValidityStateFlags: BridgedDictionary {
    public convenience init(valueMissing: Bool, typeMismatch: Bool, patternMismatch: Bool, tooLong: Bool, tooShort: Bool, rangeUnderflow: Bool, rangeOverflow: Bool, stepMismatch: Bool, badInput: Bool, customError: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.valueMissing] = _toJSValue(valueMissing)
        object[.typeMismatch] = _toJSValue(typeMismatch)
        object[.patternMismatch] = _toJSValue(patternMismatch)
        object[.tooLong] = _toJSValue(tooLong)
        object[.tooShort] = _toJSValue(tooShort)
        object[.rangeUnderflow] = _toJSValue(rangeUnderflow)
        object[.rangeOverflow] = _toJSValue(rangeOverflow)
        object[.stepMismatch] = _toJSValue(stepMismatch)
        object[.badInput] = _toJSValue(badInput)
        object[.customError] = _toJSValue(customError)
        self.init(unsafelyWrapping: object)
    }
    
    public var valueMissing: Bool {
        get { jsObject[.valueMissing].fromJSValue()!}
        set { jsObject[.valueMissing] = newValue.jsValue }
    }
    
    public var typeMismatch: Bool {
        get { jsObject[.typeMismatch].fromJSValue()!}
        set { jsObject[.typeMismatch] = newValue.jsValue }
    }
    
    public var patternMismatch: Bool {
        get { jsObject[.patternMismatch].fromJSValue()!}
        set { jsObject[.patternMismatch] = newValue.jsValue }
    }
    
    public var tooLong: Bool {
        get { jsObject[.tooLong].fromJSValue()!}
        set { jsObject[.tooLong] = newValue.jsValue }
    }
    
    public var tooShort: Bool {
        get { jsObject[.tooShort].fromJSValue()!}
        set { jsObject[.tooShort] = newValue.jsValue }
    }
    
    public var rangeUnderflow: Bool {
        get { jsObject[.rangeUnderflow].fromJSValue()!}
        set { jsObject[.rangeUnderflow] = newValue.jsValue }
    }
    
    public var rangeOverflow: Bool {
        get { jsObject[.rangeOverflow].fromJSValue()!}
        set { jsObject[.rangeOverflow] = newValue.jsValue }
    }
    
    public var stepMismatch: Bool {
        get { jsObject[.stepMismatch].fromJSValue()!}
        set { jsObject[.stepMismatch] = newValue.jsValue }
    }
    
    public var badInput: Bool {
        get { jsObject[.badInput].fromJSValue()!}
        set { jsObject[.badInput] = newValue.jsValue }
    }
    
    public var customError: Bool {
        get { jsObject[.customError].fromJSValue()!}
        set { jsObject[.customError] = newValue.jsValue }
    }
}

public class VisibilityStateEntry: PerformanceEntry {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.VisibilityStateEntry].function }
    
    @inlinable override public var name: String {
        jsObject[.name].fromJSValue()!
    }
    
    @inlinable override public var entryType: String {
        jsObject[.entryType].fromJSValue()!
    }
    
    @inlinable override public var startTime: DOMHighResTimeStamp {
        jsObject[.startTime].fromJSValue()!
    }
    
    // XXX: override of property `duration` removed because the type here is UInt32 but the
    // type in the superclass is DOMHighResTimestamp (Double).
}

public enum ArrayBuffer_or_String: JSValueCompatible {
    case arrayBuffer(ArrayBuffer)
    case string(String)
    
    public static func construct(from value: JSValue) -> Self? {
        if let arrayBuffer: ArrayBuffer = value.fromJSValue() {
            return .arrayBuffer(arrayBuffer)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .arrayBuffer(arrayBuffer):
            return arrayBuffer.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public enum Event_or_String: JSValueCompatible {
    case event(Event)
    case string(String)
    
    public static func construct(from value: JSValue) -> Self? {
        if let event: Event = value.fromJSValue() {
            return .event(event)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .event(event):
            return event.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public enum GeometryNode: JSValueCompatible {
    case cssPseudoElement(CSSPseudoElement)
    case document(Document)
    case element(Element)
    case text(Text)
    
    public static func construct(from value: JSValue) -> Self? {
        if let cssPseudoElement: CSSPseudoElement = value.fromJSValue() {
            return .cssPseudoElement(cssPseudoElement)
        }
        if let document: Document = value.fromJSValue() {
            return .document(document)
        }
        if let element: Element = value.fromJSValue() {
            return .element(element)
        }
        if let text: Text = value.fromJSValue() {
            return .text(text)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .cssPseudoElement(cssPseudoElement):
            return cssPseudoElement.jsValue
        case let .document(document):
            return document.jsValue
        case let .element(element):
            return element.jsValue
        case let .text(text):
            return text.jsValue
        }
    }
}
