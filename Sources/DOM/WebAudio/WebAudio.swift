// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import ECMAScript
import JavaScriptEventLoop
import JavaScriptKit
import WebAPIBase

public class AnalyserNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AnalyserNode].function }
    
    @inlinable public convenience init(context: BaseAudioContext, options: AnalyserOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    @inlinable public func getFloatFrequencyData(array: Float32Array) {
        let this = jsObject
        _ = this[.getFloatFrequencyData].function!(this: this, arguments: [_toJSValue(array)])
    }
    
    @inlinable public func getByteFrequencyData(array: Uint8Array) {
        let this = jsObject
        _ = this[.getByteFrequencyData].function!(this: this, arguments: [_toJSValue(array)])
    }
    
    @inlinable public func getFloatTimeDomainData(array: Float32Array) {
        let this = jsObject
        _ = this[.getFloatTimeDomainData].function!(this: this, arguments: [_toJSValue(array)])
    }
    
    @inlinable public func getByteTimeDomainData(array: Uint8Array) {
        let this = jsObject
        _ = this[.getByteTimeDomainData].function!(this: this, arguments: [_toJSValue(array)])
    }
    
    public var fftSize: UInt32 {
        get { jsObject[.fftSize].fromJSValue()!}
        set { jsObject[.fftSize] = newValue.jsValue }
    }
    
    public var frequencyBinCount: UInt32 {
        jsObject[.frequencyBinCount].fromJSValue()!
    }
    
    public var minDecibels: Double {
        get { jsObject[.minDecibels].fromJSValue()!}
        set { jsObject[.minDecibels] = newValue.jsValue }
    }
    
    public var maxDecibels: Double {
        get { jsObject[.maxDecibels].fromJSValue()!}
        set { jsObject[.maxDecibels] = newValue.jsValue }
    }
    
    public var smoothingTimeConstant: Double {
        get { jsObject[.smoothingTimeConstant].fromJSValue()!}
        set { jsObject[.smoothingTimeConstant] = newValue.jsValue }
    }
}

public class AnalyserOptions: BridgedDictionary {
    public convenience init(fftSize: UInt32, maxDecibels: Double, minDecibels: Double, smoothingTimeConstant: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.fftSize] = _toJSValue(fftSize)
        object[.maxDecibels] = _toJSValue(maxDecibels)
        object[.minDecibels] = _toJSValue(minDecibels)
        object[.smoothingTimeConstant] = _toJSValue(smoothingTimeConstant)
        self.init(unsafelyWrapping: object)
    }
    
    public var fftSize: UInt32 {
        get { jsObject[.fftSize].fromJSValue()!}
        set { jsObject[.fftSize] = newValue.jsValue }
    }
    
    public var maxDecibels: Double {
        get { jsObject[.maxDecibels].fromJSValue()!}
        set { jsObject[.maxDecibels] = newValue.jsValue }
    }
    
    public var minDecibels: Double {
        get { jsObject[.minDecibels].fromJSValue()!}
        set { jsObject[.minDecibels] = newValue.jsValue }
    }
    
    public var smoothingTimeConstant: Double {
        get { jsObject[.smoothingTimeConstant].fromJSValue()!}
        set { jsObject[.smoothingTimeConstant] = newValue.jsValue }
    }
}

public class AudioBuffer: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.AudioBuffer].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }
    
    @inlinable public convenience init(options: AudioBufferOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(options)]))
    }
    
    public var sampleRate: Float {
        jsObject[.sampleRate].fromJSValue()!
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    public var duration: Double {
        jsObject[.duration].fromJSValue()!
    }
    
    public var numberOfChannels: UInt32 {
        jsObject[.numberOfChannels].fromJSValue()!
    }
    
    @inlinable public func getChannelData(channel: UInt32) -> Float32Array {
        let this = jsObject
        return this[.getChannelData].function!(this: this, arguments: [_toJSValue(channel)]).fromJSValue()!
    }
    
    @inlinable public func copyFromChannel(destination: Float32Array, channelNumber: UInt32, bufferOffset: UInt32? = nil) {
        let this = jsObject
        _ = this[.copyFromChannel].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(channelNumber), _toJSValue(bufferOffset)])
    }
    
    @inlinable public func copyToChannel(source: Float32Array, channelNumber: UInt32, bufferOffset: UInt32? = nil) {
        let this = jsObject
        _ = this[.copyToChannel].function!(this: this, arguments: [_toJSValue(source), _toJSValue(channelNumber), _toJSValue(bufferOffset)])
    }
}

public class AudioBufferOptions: BridgedDictionary {
    public convenience init(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) {
        let object = JSObject.global[.Object].function!.new()
        object[.numberOfChannels] = _toJSValue(numberOfChannels)
        object[.length] = _toJSValue(length)
        object[.sampleRate] = _toJSValue(sampleRate)
        self.init(unsafelyWrapping: object)
    }
    
    public var numberOfChannels: UInt32 {
        get { jsObject[.numberOfChannels].fromJSValue()!}
        set { jsObject[.numberOfChannels] = newValue.jsValue }
    }
    
    public var length: UInt32 {
        get { jsObject[.length].fromJSValue()!}
        set { jsObject[.length] = newValue.jsValue }
    }
    
    public var sampleRate: Float {
        get { jsObject[.sampleRate].fromJSValue()!}
        set { jsObject[.sampleRate] = newValue.jsValue }
    }
}

public class AudioBufferSourceNode: AudioScheduledSourceNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioBufferSourceNode].function }
    
    @inlinable public convenience init(context: BaseAudioContext, options: AudioBufferSourceOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var buffer: AudioBuffer? {
        get { jsObject[.buffer].fromJSValue()}
        set { jsObject[.buffer] = newValue.jsValue }
    }
    
    public var playbackRate: AudioParam {
        jsObject[.playbackRate].fromJSValue()!
    }
    
    public var detune: AudioParam {
        jsObject[.detune].fromJSValue()!
    }
    
    public var loop: Bool {
        get { jsObject[.loop].fromJSValue()!}
        set { jsObject[.loop] = newValue.jsValue }
    }
    
    public var loopStart: Double {
        get { jsObject[.loopStart].fromJSValue()!}
        set { jsObject[.loopStart] = newValue.jsValue }
    }
    
    public var loopEnd: Double {
        get { jsObject[.loopEnd].fromJSValue()!}
        set { jsObject[.loopEnd] = newValue.jsValue }
    }
    
    // `override` removed since the superclass function has fewer parameters
    @inlinable func start(when: Double? = nil, offset: Double? = nil, duration: Double? = nil) {
        let this = jsObject
        _ = this[.start].function!(this: this, arguments: [_toJSValue(when), _toJSValue(offset), _toJSValue(duration)])
    }
}

public class AudioBufferSourceOptions: BridgedDictionary {
    public convenience init(buffer: AudioBuffer?, detune: Float, loop: Bool, loopEnd: Double, loopStart: Double, playbackRate: Float) {
        let object = JSObject.global[.Object].function!.new()
        object[.buffer] = _toJSValue(buffer)
        object[.detune] = _toJSValue(detune)
        object[.loop] = _toJSValue(loop)
        object[.loopEnd] = _toJSValue(loopEnd)
        object[.loopStart] = _toJSValue(loopStart)
        object[.playbackRate] = _toJSValue(playbackRate)
        self.init(unsafelyWrapping: object)
    }
    
   public var buffer: AudioBuffer? {
        get { jsObject[.buffer].fromJSValue()}
        set { jsObject[.buffer] = newValue.jsValue }
    }
    
    public var detune: Float {
        get { jsObject[.detune].fromJSValue()!}
        set { jsObject[.detune] = newValue.jsValue }
    }
    
    public var loop: Bool {
        get { jsObject[.loop].fromJSValue()!}
        set { jsObject[.loop] = newValue.jsValue }
    }
    
    public var loopEnd: Double {
        get { jsObject[.loopEnd].fromJSValue()!}
        set { jsObject[.loopEnd] = newValue.jsValue }
    }
    
    public var loopStart: Double {
        get { jsObject[.loopStart].fromJSValue()!}
        set { jsObject[.loopStart] = newValue.jsValue }
    }
    
    public var playbackRate: Float {
        get { jsObject[.playbackRate].fromJSValue()!}
        set { jsObject[.playbackRate] = newValue.jsValue }
    }
}

public class AudioContext: BaseAudioContext {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioContext].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
       _onsinkchange = ClosureAttribute1Optional(jsObject: jsObject, name: .onsinkchange)
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public convenience init(contextOptions: AudioContextOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(contextOptions)]))
    }
    
    public var baseLatency: Double {
        jsObject[.baseLatency].fromJSValue()!
    }
    
    public var outputLatency: Double {
        jsObject[.outputLatency].fromJSValue()!
    }
    
    public var sinkId: AudioSinkInfo_or_String {
        jsObject[.sinkId].fromJSValue()!
    }
    
    public var renderCapacity: AudioRenderCapacity {
        jsObject[.renderCapacity].fromJSValue()!
    }
    
    @ClosureAttribute1Optional
    public var onsinkchange: EventHandler
    
    @inlinable public func getOutputTimestamp() -> AudioTimestamp {
        let this = jsObject
        return this[.getOutputTimestamp].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func resume() -> JSPromise {
        let this = jsObject
        return this[.resume].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func resume() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.resume].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }
    
    @inlinable public func suspend() -> JSPromise {
        let this = jsObject
        return this[.suspend].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func suspend() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.suspend].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }
    
    @inlinable public func close() -> JSPromise {
        let this = jsObject
        return this[.close].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func close() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.close].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }
    
    @inlinable public func setSinkId(sinkId: AudioSinkOptions_or_String) -> JSPromise {
        let this = jsObject
        return this[.setSinkId].function!(this: this, arguments: [_toJSValue(sinkId)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func setSinkId(sinkId: AudioSinkOptions_or_String) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.setSinkId].function!(this: this, arguments: [_toJSValue(sinkId)]).fromJSValue()!
        _ = try await _promise.value
    }
    
    @inlinable public func createMediaElementSource(mediaElement: HTMLMediaElement) -> MediaElementAudioSourceNode {
        let this = jsObject
        return this[.createMediaElementSource].function!(this: this, arguments: [_toJSValue(mediaElement)]).fromJSValue()!
    }
    
    @inlinable public func createMediaStreamSource(mediaStream: MediaStream) -> MediaStreamAudioSourceNode {
        let this = jsObject
        return this[.createMediaStreamSource].function!(this: this, arguments: [_toJSValue(mediaStream)]).fromJSValue()!
    }
    
    @inlinable public func createMediaStreamTrackSource(mediaStreamTrack: MediaStreamTrack) -> MediaStreamTrackAudioSourceNode {
        let this = jsObject
        return this[.createMediaStreamTrackSource].function!(this: this, arguments: [_toJSValue(mediaStreamTrack)]).fromJSValue()!
    }
    
    @inlinable public func createMediaStreamDestination() -> MediaStreamAudioDestinationNode {
        let this = jsObject
        return this[.createMediaStreamDestination].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum AudioContextLatencyCategory: JSString, JSValueCompatible {
    case balanced = "balanced"
    case interactive = "interactive"
    case playback = "playback"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AudioContextOptions: BridgedDictionary {
    public convenience init(latencyHint: AudioContextLatencyCategory_or_Double, sampleRate: Float, sinkId: AudioSinkOptions_or_String) {
        let object = JSObject.global[.Object].function!.new()
        object[.latencyHint] = _toJSValue(latencyHint)
        object[.sampleRate] = _toJSValue(sampleRate)
        object[.sinkId] = _toJSValue(sinkId)
        self.init(unsafelyWrapping: object)
    }
    
   public var latencyHint: AudioContextLatencyCategory_or_Double {
        get { jsObject[.latencyHint].fromJSValue()!}
        set { jsObject[.latencyHint] = newValue.jsValue }
    }
    
    public var sampleRate: Float {
        get { jsObject[.sampleRate].fromJSValue()!}
        set { jsObject[.sampleRate] = newValue.jsValue }
    }
    
    public var sinkId: AudioSinkOptions_or_String {
        get { jsObject[.sinkId].fromJSValue()!}
        set { jsObject[.sinkId] = newValue.jsValue }
    }
}

public enum AudioContextState: JSString, JSValueCompatible {
    case suspended = "suspended"
    case running = "running"
    case closed = "closed"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AudioDestinationNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioDestinationNode].function }
    
   public var maxChannelCount: UInt32 {
        jsObject[.maxChannelCount].fromJSValue()!
    }
}

public class AudioListener: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.AudioListener].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }
    
    public var positionX: AudioParam {
        jsObject[.positionX].fromJSValue()!
    }
    
    public var positionY: AudioParam {
        jsObject[.positionY].fromJSValue()!
    }
    
    public var positionZ: AudioParam {
        jsObject[.positionZ].fromJSValue()!
    }
    
    public var forwardX: AudioParam {
        jsObject[.forwardX].fromJSValue()!
    }
    
    public var forwardY: AudioParam {
        jsObject[.forwardY].fromJSValue()!
    }
    
    public var forwardZ: AudioParam {
        jsObject[.forwardZ].fromJSValue()!
    }
    
    public var upX: AudioParam {
        jsObject[.upX].fromJSValue()!
    }
    
    public var upY: AudioParam {
        jsObject[.upY].fromJSValue()!
    }
    
    public var upZ: AudioParam {
        jsObject[.upZ].fromJSValue()!
    }
    
    @inlinable public func setPosition(x: Float, y: Float, z: Float) {
        let this = jsObject
        _ = this[.setPosition].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z)])
    }
    
    @inlinable public func setOrientation(x: Float, y: Float, z: Float, xUp: Float, yUp: Float, zUp: Float) {
        let this = jsObject
        _ = this[.setOrientation].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z), _toJSValue(xUp), _toJSValue(yUp), _toJSValue(zUp)])
    }
}

public class AudioNode: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioNode].function }
    
   @discardableResult @inlinable public func connect<NodeType: AudioNode>(destinationNode: NodeType, output: UInt32? = nil, input: UInt32? = nil) -> NodeType {
        let this = jsObject
        return this[.connect].function!(this: this, arguments: [_toJSValue(destinationNode), _toJSValue(output), _toJSValue(input)]).fromJSValue()!
    }
    
    @inlinable public func connect(destinationParam: AudioParam, output: UInt32? = nil) {
        let this = jsObject
        _ = this[.connect].function!(this: this, arguments: [_toJSValue(destinationParam), _toJSValue(output)])
    }
    
    @inlinable public func disconnect() {
        let this = jsObject
        _ = this[.disconnect].function!(this: this, arguments: [])
    }
    
    @inlinable public func disconnect(output: UInt32) {
        let this = jsObject
        _ = this[.disconnect].function!(this: this, arguments: [_toJSValue(output)])
    }
    
    @inlinable public func disconnect(destinationNode: AudioNode) {
        let this = jsObject
        _ = this[.disconnect].function!(this: this, arguments: [_toJSValue(destinationNode)])
    }
    
    @inlinable public func disconnect(destinationNode: AudioNode, output: UInt32) {
        let this = jsObject
        _ = this[.disconnect].function!(this: this, arguments: [_toJSValue(destinationNode), _toJSValue(output)])
    }
    
    @inlinable public func disconnect(destinationNode: AudioNode, output: UInt32, input: UInt32) {
        let this = jsObject
        _ = this[.disconnect].function!(this: this, arguments: [_toJSValue(destinationNode), _toJSValue(output), _toJSValue(input)])
    }
    
    @inlinable public func disconnect(destinationParam: AudioParam) {
        let this = jsObject
        _ = this[.disconnect].function!(this: this, arguments: [_toJSValue(destinationParam)])
    }
    
    @inlinable public func disconnect(destinationParam: AudioParam, output: UInt32) {
        let this = jsObject
        _ = this[.disconnect].function!(this: this, arguments: [_toJSValue(destinationParam), _toJSValue(output)])
    }
    
    public var context: BaseAudioContext {
        jsObject[.context].fromJSValue()!
    }
    
    public var numberOfInputs: UInt32 {
        jsObject[.numberOfInputs].fromJSValue()!
    }
    
    public var numberOfOutputs: UInt32 {
        jsObject[.numberOfOutputs].fromJSValue()!
    }
    
    public var channelCount: UInt32 {
        get { jsObject[.channelCount].fromJSValue()!}
        set { jsObject[.channelCount] = newValue.jsValue }
    }
    
    public var channelCountMode: ChannelCountMode {
        get { jsObject[.channelCountMode].fromJSValue()!}
        set { jsObject[.channelCountMode] = newValue.jsValue }
    }
    
    public var channelInterpretation: ChannelInterpretation {
        get { jsObject[.channelInterpretation].fromJSValue()!}
        set { jsObject[.channelInterpretation] = newValue.jsValue }
    }
}

public class AudioNodeOptions: BridgedDictionary {
    public convenience init(channelCount: UInt32, channelCountMode: ChannelCountMode, channelInterpretation: ChannelInterpretation) {
        let object = JSObject.global[.Object].function!.new()
        object[.channelCount] = _toJSValue(channelCount)
        object[.channelCountMode] = _toJSValue(channelCountMode)
        object[.channelInterpretation] = _toJSValue(channelInterpretation)
        self.init(unsafelyWrapping: object)
    }
    
   public var channelCount: UInt32 {
        get { jsObject[.channelCount].fromJSValue()!}
        set { jsObject[.channelCount] = newValue.jsValue }
    }
    
    public var channelCountMode: ChannelCountMode {
        get { jsObject[.channelCountMode].fromJSValue()!}
        set { jsObject[.channelCountMode] = newValue.jsValue }
    }
    
    public var channelInterpretation: ChannelInterpretation {
        get { jsObject[.channelInterpretation].fromJSValue()!}
        set { jsObject[.channelInterpretation] = newValue.jsValue }
    }
}

public class AudioParam: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.AudioParam].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }
    
    public var value: Float {
        get { jsObject[.value].fromJSValue()!}
        set { jsObject[.value] = newValue.jsValue }
    }
    
    public var automationRate: AutomationRate {
        get { jsObject[.automationRate].fromJSValue()!}
        set { jsObject[.automationRate] = newValue.jsValue }
    }
    
    public var defaultValue: Float {
        jsObject[.defaultValue].fromJSValue()!
    }
    
    public var minValue: Float {
        jsObject[.minValue].fromJSValue()!
    }
    
    public var maxValue: Float {
        jsObject[.maxValue].fromJSValue()!
    }
    
    @inlinable public func setValueAtTime(value: Float, startTime: Double) -> Self {
        let this = jsObject
        return this[.setValueAtTime].function!(this: this, arguments: [_toJSValue(value), _toJSValue(startTime)]).fromJSValue()!
    }
    
    @inlinable public func linearRampToValueAtTime(value: Float, endTime: Double) -> Self {
        let this = jsObject
        return this[.linearRampToValueAtTime].function!(this: this, arguments: [_toJSValue(value), _toJSValue(endTime)]).fromJSValue()!
    }
    
    @inlinable public func exponentialRampToValueAtTime(value: Float, endTime: Double) -> Self {
        let this = jsObject
        return this[.exponentialRampToValueAtTime].function!(this: this, arguments: [_toJSValue(value), _toJSValue(endTime)]).fromJSValue()!
    }
    
    @inlinable public func setTargetAtTime(target: Float, startTime: Double, timeConstant: Float) -> Self {
        let this = jsObject
        return this[.setTargetAtTime].function!(this: this, arguments: [_toJSValue(target), _toJSValue(startTime), _toJSValue(timeConstant)]).fromJSValue()!
    }
    
    @inlinable public func setValueCurveAtTime(values: [Float], startTime: Double, duration: Double) -> Self {
        let this = jsObject
        return this[.setValueCurveAtTime].function!(this: this, arguments: [_toJSValue(values), _toJSValue(startTime), _toJSValue(duration)]).fromJSValue()!
    }
    
    @inlinable public func cancelScheduledValues(cancelTime: Double) -> Self {
        let this = jsObject
        return this[.cancelScheduledValues].function!(this: this, arguments: [_toJSValue(cancelTime)]).fromJSValue()!
    }
    
    @inlinable public func cancelAndHoldAtTime(cancelTime: Double) -> Self {
        let this = jsObject
        return this[.cancelAndHoldAtTime].function!(this: this, arguments: [_toJSValue(cancelTime)]).fromJSValue()!
    }
}

public class AudioParamDescriptor: BridgedDictionary {
    public convenience init(name: String, defaultValue: Float, minValue: Float, maxValue: Float, automationRate: AutomationRate) {
        let object = JSObject.global[.Object].function!.new()
        object[.name] = _toJSValue(name)
        object[.defaultValue] = _toJSValue(defaultValue)
        object[.minValue] = _toJSValue(minValue)
        object[.maxValue] = _toJSValue(maxValue)
        object[.automationRate] = _toJSValue(automationRate)
        self.init(unsafelyWrapping: object)
    }
    
    public var name: String {
        get { jsObject[.name].fromJSValue()!}
        set { jsObject[.name] = newValue.jsValue }
    }
    
    public var defaultValue: Float {
        get { jsObject[.defaultValue].fromJSValue()!}
        set { jsObject[.defaultValue] = newValue.jsValue }
    }
    
    public var minValue: Float {
        get { jsObject[.minValue].fromJSValue()!}
        set { jsObject[.minValue] = newValue.jsValue }
    }
    
    public var maxValue: Float {
        get { jsObject[.maxValue].fromJSValue()!}
        set { jsObject[.maxValue] = newValue.jsValue }
    }
    
    public var automationRate: AutomationRate {
        get { jsObject[.automationRate].fromJSValue()!}
        set { jsObject[.automationRate] = newValue.jsValue }
    }
}

public class AudioParamMap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.AudioParamMap].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    // XXX: make me Map-like!
}



public class AudioRenderCapacity: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioRenderCapacity].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _onupdate = ClosureAttribute1Optional(jsObject: jsObject, name: .onupdate)
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public func start(options: AudioRenderCapacityOptions? = nil) {
        let this = jsObject
        _ = this[.start].function!(this: this, arguments: [_toJSValue(options)])
    }
    
    @inlinable public func stop() {
        let this = jsObject
        _ = this[.stop].function!(this: this, arguments: [])
    }
    
    @ClosureAttribute1Optional
    public var onupdate: EventHandler
}

public class AudioRenderCapacityEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioRenderCapacityEvent].function }
    
    @inlinable public convenience init(type: String, eventInitDict: AudioRenderCapacityEventInit? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }
    
    public var timestamp: Double {
        jsObject[.timestamp].fromJSValue()!
    }
    
    public var averageLoad: Double {
        jsObject[.averageLoad].fromJSValue()!
    }
    
    public var peakLoad: Double {
        jsObject[.peakLoad].fromJSValue()!
    }
    
    public var underrunRatio: Double {
        jsObject[.underrunRatio].fromJSValue()!
    }
}

public class AudioRenderCapacityEventInit: BridgedDictionary {
    public convenience init(timestamp: Double, averageLoad: Double, peakLoad: Double, underrunRatio: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.timestamp] = _toJSValue(timestamp)
        object[.averageLoad] = _toJSValue(averageLoad)
        object[.peakLoad] = _toJSValue(peakLoad)
        object[.underrunRatio] = _toJSValue(underrunRatio)
        self.init(unsafelyWrapping: object)
    }
    
   public var timestamp: Double {
        get { jsObject[.timestamp].fromJSValue()!}
        set { jsObject[.timestamp] = newValue.jsValue }
    }
    
    public var averageLoad: Double {
        get { jsObject[.averageLoad].fromJSValue()!}
        set { jsObject[.averageLoad] = newValue.jsValue }
    }
    
    public var peakLoad: Double {
        get { jsObject[.peakLoad].fromJSValue()!}
        set { jsObject[.peakLoad] = newValue.jsValue }
    }
    
    public var underrunRatio: Double {
        get { jsObject[.underrunRatio].fromJSValue()!}
        set { jsObject[.underrunRatio] = newValue.jsValue }
    }
}

public class AudioRenderCapacityOptions: BridgedDictionary {
    public convenience init(updateInterval: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.updateInterval] = _toJSValue(updateInterval)
        self.init(unsafelyWrapping: object)
    }
    
   public var updateInterval: Double {
        get { jsObject[.updateInterval].fromJSValue()!}
        set { jsObject[.updateInterval] = newValue.jsValue }
    }
}

public class AudioScheduledSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioScheduledSourceNode].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _onended = ClosureAttribute1Optional(jsObject: jsObject, name: .onended)
        super.init(unsafelyWrapping: jsObject)
    }
    
    @ClosureAttribute1Optional
    public var onended: EventHandler
    
    @inlinable public func start(when: Double? = nil) {
        let this = jsObject
        _ = this[.start].function!(this: this, arguments: [_toJSValue(when)])
    }
    
    @inlinable public func stop(when: Double? = nil) {
        let this = jsObject
        _ = this[.stop].function!(this: this, arguments: [_toJSValue(when)])
    }
}

public class AudioSinkInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.AudioSinkInfo].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var type: AudioSinkType {
        jsObject[.type].fromJSValue()!
    }
}

public class AudioSinkOptions: BridgedDictionary {
    public convenience init(type: AudioSinkType) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        self.init(unsafelyWrapping: object)
    }
    
   public var type: AudioSinkType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
}

public enum AudioSinkType: JSString, JSValueCompatible {
    case none = "none"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AudioTimestamp: BridgedDictionary {
    public convenience init(contextTime: Double, performanceTime: DOMHighResTimeStamp) {
        let object = JSObject.global[.Object].function!.new()
        object[.contextTime] = _toJSValue(contextTime)
        object[.performanceTime] = _toJSValue(performanceTime)
        self.init(unsafelyWrapping: object)
    }
    
   public var contextTime: Double {
        get { jsObject[.contextTime].fromJSValue()!}
        set { jsObject[.contextTime] = newValue.jsValue }
    }
    
    public var performanceTime: DOMHighResTimeStamp {
        get { jsObject[.performanceTime].fromJSValue()!}
        set { jsObject[.performanceTime] = newValue.jsValue }
    }
}

public class AudioWorklet: Worklet {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioWorklet].function }
    
   public var port: MessagePort {
        jsObject[.port].fromJSValue()!
    }
}

public class AudioWorkletNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.AudioWorkletNode].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _onprocessorerror = ClosureAttribute1Optional(jsObject: jsObject, name: .onprocessorerror)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(context: BaseAudioContext, name: String, options: AudioWorkletNodeOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(name), _toJSValue(options)]))
    }
    
    public var parameters: AudioParamMap {
        jsObject[.parameters].fromJSValue()!
    }
    
    public var port: MessagePort {
        jsObject[.port].fromJSValue()!
    }
    
    @ClosureAttribute1Optional
    public var onprocessorerror: EventHandler
}

public class AudioWorkletNodeOptions: BridgedDictionary {
    public convenience init(numberOfInputs: UInt32, numberOfOutputs: UInt32, outputChannelCount: [UInt32], parameterData: [String: Double], processorOptions: JSObject) {
        let object = JSObject.global[.Object].function!.new()
        object[.numberOfInputs] = _toJSValue(numberOfInputs)
        object[.numberOfOutputs] = _toJSValue(numberOfOutputs)
        object[.outputChannelCount] = _toJSValue(outputChannelCount)
        object[.parameterData] = _toJSValue(parameterData)
        object[.processorOptions] = _toJSValue(processorOptions)
        self.init(unsafelyWrapping: object)
    }
    
    public var numberOfInputs: UInt32 {
        get { jsObject[.numberOfInputs].fromJSValue()!}
        set { jsObject[.numberOfInputs] = newValue.jsValue }
    }
    
    public var numberOfOutputs: UInt32 {
        get { jsObject[.numberOfOutputs].fromJSValue()!}
        set { jsObject[.numberOfOutputs] = newValue.jsValue }
    }
    
    public var outputChannelCount: [UInt32] {
        get { jsObject[.outputChannelCount].fromJSValue()!}
        set { jsObject[.outputChannelCount] = newValue.jsValue }
    }
    
    
    
    public var parameterData: [String: Double] {
        get { jsObject[.parameterData].fromJSValue()! }
        set { jsObject[.parameterData] = newValue.jsValue }
    }
    
    public var processorOptions: JSObject {
        get { jsObject[.processorOptions].fromJSValue()!}
        set { jsObject[.processorOptions] = newValue.jsValue }
    }
}

public enum AutomationRate: JSString, JSValueCompatible {
    case aRate = "a-rate"
    case kRate = "k-rate"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class BaseAudioContext: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.BaseAudioContext].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
       _onstatechange = ClosureAttribute1Optional(jsObject: jsObject, name: .onstatechange)
        super.init(unsafelyWrapping: jsObject)
    }
    
    public var destination: AudioDestinationNode {
        jsObject[.destination].fromJSValue()!
    }
    
    public var sampleRate: Float {
        jsObject[.sampleRate].fromJSValue()!
    }
    
    public var currentTime: Double {
        jsObject[.currentTime].fromJSValue()!
    }
    
    public var listener: AudioListener {
        jsObject[.listener].fromJSValue()!
    }
    
    public var state: AudioContextState {
        jsObject[.state].fromJSValue()!
    }
    
    public var audioWorklet: AudioWorklet {
        jsObject[.audioWorklet].fromJSValue()!
    }
    
    @ClosureAttribute1Optional
    public var onstatechange: EventHandler
    
    @inlinable public func createAnalyser() -> AnalyserNode {
        let this = jsObject
        return this[.createAnalyser].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createBiquadFilter() -> BiquadFilterNode {
        let this = jsObject
        return this[.createBiquadFilter].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createBuffer(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) -> AudioBuffer {
        let this = jsObject
        return this[.createBuffer].function!(this: this, arguments: [_toJSValue(numberOfChannels), _toJSValue(length), _toJSValue(sampleRate)]).fromJSValue()!
    }
    
    @inlinable public func createBufferSource() -> AudioBufferSourceNode {
        let this = jsObject
        return this[.createBufferSource].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createChannelMerger(numberOfInputs: UInt32? = nil) -> ChannelMergerNode {
        let this = jsObject
        return this[.createChannelMerger].function!(this: this, arguments: [_toJSValue(numberOfInputs)]).fromJSValue()!
    }
    
    @inlinable public func createChannelSplitter(numberOfOutputs: UInt32? = nil) -> ChannelSplitterNode {
        let this = jsObject
        return this[.createChannelSplitter].function!(this: this, arguments: [_toJSValue(numberOfOutputs)]).fromJSValue()!
    }
    
    @inlinable public func createConstantSource() -> ConstantSourceNode {
        let this = jsObject
        return this[.createConstantSource].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createConvolver() -> ConvolverNode {
        let this = jsObject
        return this[.createConvolver].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createDelay(maxDelayTime: Double? = nil) -> DelayNode {
        let this = jsObject
        return this[.createDelay].function!(this: this, arguments: [_toJSValue(maxDelayTime)]).fromJSValue()!
    }
    
    @inlinable public func createDynamicsCompressor() -> DynamicsCompressorNode {
        let this = jsObject
        return this[.createDynamicsCompressor].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createGain() -> GainNode {
        let this = jsObject
        return this[.createGain].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createIIRFilter(feedforward: [Double], feedback: [Double]) -> IIRFilterNode {
        let this = jsObject
        return this[.createIIRFilter].function!(this: this, arguments: [_toJSValue(feedforward), _toJSValue(feedback)]).fromJSValue()!
    }
    
    @inlinable public func createOscillator() -> OscillatorNode {
        let this = jsObject
        return this[.createOscillator].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createPanner() -> PannerNode {
        let this = jsObject
        return this[.createPanner].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createPeriodicWave(real: [Float], imag: [Float], constraints: PeriodicWaveConstraints? = nil) -> PeriodicWave {
        let this = jsObject
        return this[.createPeriodicWave].function!(this: this, arguments: [_toJSValue(real), _toJSValue(imag), _toJSValue(constraints)]).fromJSValue()!
    }
    
    @inlinable public func createScriptProcessor(bufferSize: UInt32? = nil, numberOfInputChannels: UInt32? = nil, numberOfOutputChannels: UInt32? = nil) -> ScriptProcessorNode {
        let this = jsObject
        return this[.createScriptProcessor].function!(this: this, arguments: [_toJSValue(bufferSize), _toJSValue(numberOfInputChannels), _toJSValue(numberOfOutputChannels)]).fromJSValue()!
    }
    
    @inlinable public func createStereoPanner() -> StereoPannerNode {
        let this = jsObject
        return this[.createStereoPanner].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func createWaveShaper() -> WaveShaperNode {
        let this = jsObject
        return this[.createWaveShaper].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @inlinable public func decodeAudioData(audioData: ArrayBuffer, successCallback: DecodeSuccessCallback? = nil, errorCallback: DecodeErrorCallback? = nil) -> JSPromise {
        let this = jsObject
        return this[.decodeAudioData].function!(this: this, arguments: [_toJSValue(audioData), _toJSValue(successCallback), _toJSValue(errorCallback)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func decodeAudioData(audioData: ArrayBuffer, successCallback: DecodeSuccessCallback? = nil, errorCallback: DecodeErrorCallback? = nil) async throws -> AudioBuffer {
        let this = jsObject
        let _promise: JSPromise = this[.decodeAudioData].function!(this: this, arguments: [_toJSValue(audioData), _toJSValue(successCallback), _toJSValue(errorCallback)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class BiquadFilterNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.BiquadFilterNode].function }
    
    @inlinable public convenience init(context: BaseAudioContext, options: BiquadFilterOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var type: BiquadFilterType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
    
    public var frequency: AudioParam {
        jsObject[.frequency].fromJSValue()!
    }
    
    public var detune: AudioParam {
        jsObject[.detune].fromJSValue()!
    }
    
    public var Q: AudioParam {
        jsObject[.Q].fromJSValue()!
    }
    
    public var gain: AudioParam {
        jsObject[.gain].fromJSValue()!
    }
    
    @inlinable public func getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array) {
        let this = jsObject
        _ = this[.getFrequencyResponse].function!(this: this, arguments: [_toJSValue(frequencyHz), _toJSValue(magResponse), _toJSValue(phaseResponse)])
    }
}

public class BiquadFilterOptions: BridgedDictionary {
    public convenience init(type: BiquadFilterType, Q: Float, detune: Float, frequency: Float, gain: Float) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.Q] = _toJSValue(Q)
        object[.detune] = _toJSValue(detune)
        object[.frequency] = _toJSValue(frequency)
        object[.gain] = _toJSValue(gain)
        self.init(unsafelyWrapping: object)
    }
    
   public var type: BiquadFilterType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
    
    public var Q: Float {
        get { jsObject[.Q].fromJSValue()!}
        set { jsObject[.Q] = newValue.jsValue }
    }
    
    public var detune: Float {
        get { jsObject[.detune].fromJSValue()!}
        set { jsObject[.detune] = newValue.jsValue }
    }
    
    public var frequency: Float {
        get { jsObject[.frequency].fromJSValue()!}
        set { jsObject[.frequency] = newValue.jsValue }
    }
    
    public var gain: Float {
        get { jsObject[.gain].fromJSValue()!}
        set { jsObject[.gain] = newValue.jsValue }
    }
}

public enum BiquadFilterType: JSString, JSValueCompatible {
    case lowpass = "lowpass"
    case highpass = "highpass"
    case bandpass = "bandpass"
    case lowshelf = "lowshelf"
    case highshelf = "highshelf"
    case peaking = "peaking"
    case notch = "notch"
    case allpass = "allpass"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ChannelCountMode: JSString, JSValueCompatible {
    case max = "max"
    case clampedMax = "clamped-max"
    case explicit = "explicit"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum ChannelInterpretation: JSString, JSValueCompatible {
    case speakers = "speakers"
    case discrete = "discrete"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ChannelMergerNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ChannelMergerNode].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public convenience init(context: BaseAudioContext, options: ChannelMergerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
}

public class ChannelMergerOptions: BridgedDictionary {
    public convenience init(numberOfInputs: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.numberOfInputs] = _toJSValue(numberOfInputs)
        self.init(unsafelyWrapping: object)
    }
    
    public var numberOfInputs: UInt32 {
        get { jsObject[.numberOfInputs].fromJSValue()!}
        set { jsObject[.numberOfInputs] = newValue.jsValue }
    }
}

public class ChannelSplitterNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ChannelSplitterNode].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public convenience init(context: BaseAudioContext, options: ChannelSplitterOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
}

public class ChannelSplitterOptions: BridgedDictionary {
    public convenience init(numberOfOutputs: UInt32) {
        let object = JSObject.global[.Object].function!.new()
        object[.numberOfOutputs] = _toJSValue(numberOfOutputs)
        self.init(unsafelyWrapping: object)
    }
    
    public var numberOfOutputs: UInt32 {
        get { jsObject[.numberOfOutputs].fromJSValue()!}
        set { jsObject[.numberOfOutputs] = newValue.jsValue }
    }
}

public class ConstantSourceNode: AudioScheduledSourceNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ConstantSourceNode].function }
    
    @inlinable public convenience init(context: BaseAudioContext, options: ConstantSourceOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var offset: AudioParam {
        jsObject[.offset].fromJSValue()!
    }
}

public class ConstantSourceOptions: BridgedDictionary {
    public convenience init(offset: Float) {
        let object = JSObject.global[.Object].function!.new()
        object[.offset] = _toJSValue(offset)
        self.init(unsafelyWrapping: object)
    }
   
    public var offset: Float {
        get { jsObject[.offset].fromJSValue()!}
        set { jsObject[.offset] = newValue.jsValue }
    }
}

public class ConvolverNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ConvolverNode].function }
    
    @inlinable public convenience init(context: BaseAudioContext, options: ConvolverOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var buffer: AudioBuffer? {
        get { jsObject[.buffer].fromJSValue()}
        set { jsObject[.buffer] = newValue.jsValue }
    }
    
    public var normalize: Bool {
        get { jsObject[.normalize].fromJSValue()!}
        set { jsObject[.normalize] = newValue.jsValue }
    }
}

public class ConvolverOptions: BridgedDictionary {
    public convenience init(buffer: AudioBuffer?, disableNormalization: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.buffer] = _toJSValue(buffer)
        object[.disableNormalization] = _toJSValue(disableNormalization)
        self.init(unsafelyWrapping: object)
    }
    
    public var buffer: AudioBuffer? {
        get { jsObject[.buffer].fromJSValue()}
        set { jsObject[.buffer] = newValue.jsValue }
    }
    
    public var disableNormalization: Bool {
        get { jsObject[.disableNormalization].fromJSValue()!}
        set { jsObject[.disableNormalization] = newValue.jsValue }
    }
}

public class DelayNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.DelayNode].function }
    
   @inlinable public convenience init(context: BaseAudioContext, options: DelayOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var delayTime: AudioParam {
        jsObject[.delayTime].fromJSValue()!
    }
}

public class DelayOptions: BridgedDictionary {
    public convenience init(maxDelayTime: Double, delayTime: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.maxDelayTime] = _toJSValue(maxDelayTime)
        object[.delayTime] = _toJSValue(delayTime)
        self.init(unsafelyWrapping: object)
    }
    
   public var maxDelayTime: Double {
        get { jsObject[.maxDelayTime].fromJSValue()!}
        set { jsObject[.maxDelayTime] = newValue.jsValue }
    }
    
    public var delayTime: Double {
        get { jsObject[.delayTime].fromJSValue()!}
        set { jsObject[.delayTime] = newValue.jsValue }
    }
}

public enum DistanceModelType: JSString, JSValueCompatible {
    case linear = "linear"
    case inverse = "inverse"
    case exponential = "exponential"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class DynamicsCompressorNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.DynamicsCompressorNode].function }
    
    @inlinable public convenience init(context: BaseAudioContext, options: DynamicsCompressorOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var threshold: AudioParam {
        jsObject[.threshold].fromJSValue()!
    }
    
    public var knee: AudioParam {
        jsObject[.knee].fromJSValue()!
    }
    
    public var ratio: AudioParam {
        jsObject[.ratio].fromJSValue()!
    }
    
    public var reduction: Float {
        jsObject[.reduction].fromJSValue()!
    }
    
    public var attack: AudioParam {
        jsObject[.attack].fromJSValue()!
    }
    
    public var release: AudioParam {
        jsObject[.release].fromJSValue()!
    }
}

public class DynamicsCompressorOptions: BridgedDictionary {
    public convenience init(attack: Float, knee: Float, ratio: Float, release: Float, threshold: Float) {
        let object = JSObject.global[.Object].function!.new()
        object[.attack] = _toJSValue(attack)
        object[.knee] = _toJSValue(knee)
        object[.ratio] = _toJSValue(ratio)
        object[.release] = _toJSValue(release)
        object[.threshold] = _toJSValue(threshold)
        self.init(unsafelyWrapping: object)
    }
    
   public var attack: Float {
        get { jsObject[.attack].fromJSValue()!}
        set { jsObject[.attack] = newValue.jsValue }
    }
    
    public var knee: Float {
        get { jsObject[.knee].fromJSValue()!}
        set { jsObject[.knee] = newValue.jsValue }
    }
    
    public var ratio: Float {
        get { jsObject[.ratio].fromJSValue()!}
        set { jsObject[.ratio] = newValue.jsValue }
    }
    
    public var release: Float {
        get { jsObject[.release].fromJSValue()!}
        set { jsObject[.release] = newValue.jsValue }
    }
    
    public var threshold: Float {
        get { jsObject[.threshold].fromJSValue()!}
        set { jsObject[.threshold] = newValue.jsValue }
    }
}

public class GainNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GainNode].function }
    
   @inlinable public convenience init(context: BaseAudioContext, options: GainOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var gain: AudioParam {
        jsObject[.gain].fromJSValue()!
    }
}

public class GainOptions: BridgedDictionary {
    public convenience init(gain: Float) {
        let object = JSObject.global[.Object].function!.new()
        object[.gain] = _toJSValue(gain)
        self.init(unsafelyWrapping: object)
    }
    
   public var gain: Float {
        get { jsObject[.gain].fromJSValue()!}
        set { jsObject[.gain] = newValue.jsValue }
    }
}

public class IIRFilterNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.IIRFilterNode].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public convenience init(context: BaseAudioContext, options: IIRFilterOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    @inlinable public func getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array) {
        let this = jsObject
        _ = this[.getFrequencyResponse].function!(this: this, arguments: [_toJSValue(frequencyHz), _toJSValue(magResponse), _toJSValue(phaseResponse)])
    }
}

public class IIRFilterOptions: BridgedDictionary {
    public convenience init(feedforward: [Double], feedback: [Double]) {
        let object = JSObject.global[.Object].function!.new()
        object[.feedforward] = _toJSValue(feedforward)
        object[.feedback] = _toJSValue(feedback)
        self.init(unsafelyWrapping: object)
    }
    
   public var feedforward: [Double] {
        get { jsObject[.feedforward].fromJSValue()!}
        set { jsObject[.feedforward] = newValue.jsValue }
    }
    
    public var feedback: [Double] {
        get { jsObject[.feedback].fromJSValue()!}
        set { jsObject[.feedback] = newValue.jsValue }
    }
}

public class MediaElementAudioSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaElementAudioSourceNode].function }
    
   @inlinable public convenience init(context: AudioContext, options: MediaElementAudioSourceOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var mediaElement: HTMLMediaElement {
        jsObject[.mediaElement].fromJSValue()!
    }
}

public class MediaElementAudioSourceOptions: BridgedDictionary {
    public convenience init(mediaElement: HTMLMediaElement) {
        let object = JSObject.global[.Object].function!.new()
        object[.mediaElement] = _toJSValue(mediaElement)
        self.init(unsafelyWrapping: object)
    }
    
   public var mediaElement: HTMLMediaElement {
        get { jsObject[.mediaElement].fromJSValue()!}
        set { jsObject[.mediaElement] = newValue.jsValue }
    }
}

public class MediaStreamAudioDestinationNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaStreamAudioDestinationNode].function }
   
    @inlinable public convenience init(context: AudioContext, options: AudioNodeOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var stream: MediaStream {
        jsObject[.stream].fromJSValue()!
    }
}

public class MediaStreamAudioSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaStreamAudioSourceNode].function }
    
    @inlinable public convenience init(context: AudioContext, options: MediaStreamAudioSourceOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var mediaStream: MediaStream {
        jsObject[.mediaStream].fromJSValue()!
    }
}

public class MediaStreamAudioSourceOptions: BridgedDictionary {
    public convenience init(mediaStream: MediaStream) {
        let object = JSObject.global[.Object].function!.new()
        object[.mediaStream] = _toJSValue(mediaStream)
        self.init(unsafelyWrapping: object)
    }
    
    public var mediaStream: MediaStream {
        get { jsObject[.mediaStream].fromJSValue()!}
        set { jsObject[.mediaStream] = newValue.jsValue }
    }
}

public class MediaStreamTrackAudioSourceNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.MediaStreamTrackAudioSourceNode].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public convenience init(context: AudioContext, options: MediaStreamTrackAudioSourceOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
}

public class MediaStreamTrackAudioSourceOptions: BridgedDictionary {
    public convenience init(mediaStreamTrack: MediaStreamTrack) {
        let object = JSObject.global[.Object].function!.new()
        object[.mediaStreamTrack] = _toJSValue(mediaStreamTrack)
        self.init(unsafelyWrapping: object)
    }
    
    public var mediaStreamTrack: MediaStreamTrack {
        get { jsObject[.mediaStreamTrack].fromJSValue()!}
        set { jsObject[.mediaStreamTrack] = newValue.jsValue }
    }
}

public class OfflineAudioCompletionEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.OfflineAudioCompletionEvent].function }
    
    @inlinable public convenience init(type: String, eventInitDict: OfflineAudioCompletionEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }
    
    public var renderedBuffer: AudioBuffer {
        jsObject[.renderedBuffer].fromJSValue()!
    }
}

public class OfflineAudioCompletionEventInit: BridgedDictionary {
    public convenience init(renderedBuffer: AudioBuffer) {
        let object = JSObject.global[.Object].function!.new()
        object[.renderedBuffer] = _toJSValue(renderedBuffer)
        self.init(unsafelyWrapping: object)
    }
    
    public var renderedBuffer: AudioBuffer {
        get { jsObject[.renderedBuffer].fromJSValue()!}
        set { jsObject[.renderedBuffer] = newValue.jsValue }
    }
}

public class OfflineAudioContext: BaseAudioContext {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.OfflineAudioContext].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _oncomplete = ClosureAttribute1Optional(jsObject: jsObject, name: .oncomplete)
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public convenience init(contextOptions: OfflineAudioContextOptions) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(contextOptions)]))
    }
    
    @inlinable public convenience init(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(numberOfChannels), _toJSValue(length), _toJSValue(sampleRate)]))
    }
    
    @inlinable public func startRendering() -> JSPromise {
        let this = jsObject
        return this[.startRendering].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func startRendering() async throws -> AudioBuffer {
        let this = jsObject
        let _promise: JSPromise = this[.startRendering].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
    
    @inlinable public func resume() -> JSPromise {
        let this = jsObject
        return this[.resume].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func resume() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.resume].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }
    
    @inlinable public func suspend(suspendTime: Double) -> JSPromise {
        let this = jsObject
        return this[.suspend].function!(this: this, arguments: [_toJSValue(suspendTime)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func suspend(suspendTime: Double) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.suspend].function!(this: this, arguments: [_toJSValue(suspendTime)]).fromJSValue()!
        _ = try await _promise.value
    }
    
    public var length: UInt32 {
        jsObject[.length].fromJSValue()!
    }
    
    @ClosureAttribute1Optional
    public var oncomplete: EventHandler
}

public class OfflineAudioContextOptions: BridgedDictionary {
    public convenience init(numberOfChannels: UInt32, length: UInt32, sampleRate: Float) {
        let object = JSObject.global[.Object].function!.new()
        object[.numberOfChannels] = _toJSValue(numberOfChannels)
        object[.length] = _toJSValue(length)
        object[.sampleRate] = _toJSValue(sampleRate)
        self.init(unsafelyWrapping: object)
    }
    
   public var numberOfChannels: UInt32 {
        get { jsObject[.numberOfChannels].fromJSValue()!}
        set { jsObject[.numberOfChannels] = newValue.jsValue }
    }
    
    public var length: UInt32 {
        get { jsObject[.length].fromJSValue()!}
        set { jsObject[.length] = newValue.jsValue }
    }
    
    public var sampleRate: Float {
        get { jsObject[.sampleRate].fromJSValue()!}
        set { jsObject[.sampleRate] = newValue.jsValue }
    }
}

public class OscillatorNode: AudioScheduledSourceNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.OscillatorNode].function }
    
    @inlinable public convenience init(context: BaseAudioContext, options: OscillatorOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var type: OscillatorType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
    
    public var frequency: AudioParam {
        jsObject[.frequency].fromJSValue()!
    }
    
    public var detune: AudioParam {
        jsObject[.detune].fromJSValue()!
    }
    
    @inlinable public func setPeriodicWave(periodicWave: PeriodicWave) {
        let this = jsObject
        _ = this[.setPeriodicWave].function!(this: this, arguments: [_toJSValue(periodicWave)])
    }
}

public class OscillatorOptions: BridgedDictionary {
    public convenience init(type: OscillatorType, frequency: Float, detune: Float, periodicWave: PeriodicWave) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.frequency] = _toJSValue(frequency)
        object[.detune] = _toJSValue(detune)
        object[.periodicWave] = _toJSValue(periodicWave)
        self.init(unsafelyWrapping: object)
    }
    
    public var type: OscillatorType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
    
    public var frequency: Float {
        get { jsObject[.frequency].fromJSValue()!}
        set { jsObject[.frequency] = newValue.jsValue }
    }
    
    public var detune: Float {
        get { jsObject[.detune].fromJSValue()!}
        set { jsObject[.detune] = newValue.jsValue }
    }
    
    public var periodicWave: PeriodicWave {
        get { jsObject[.periodicWave].fromJSValue()!}
        set { jsObject[.periodicWave] = newValue.jsValue }
    }
}

public enum OscillatorType: JSString, JSValueCompatible {
    case sine = "sine"
    case square = "square"
    case sawtooth = "sawtooth"
    case triangle = "triangle"
    case custom = "custom"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum OverSampleType: JSString, JSValueCompatible {
    case none = "none"
    case _2x = "2x"
    case _4x = "4x"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class PannerNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.PannerNode].function }
    
    @inlinable public convenience init(context: BaseAudioContext, options: PannerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var panningModel: PanningModelType {
        get { jsObject[.panningModel].fromJSValue()!}
        set { jsObject[.panningModel] = newValue.jsValue }
    }
    
    public var positionX: AudioParam {
        jsObject[.positionX].fromJSValue()!
    }
    
    public var positionY: AudioParam {
        jsObject[.positionY].fromJSValue()!
    }
    
    public var positionZ: AudioParam {
        jsObject[.positionZ].fromJSValue()!
    }
    
    public var orientationX: AudioParam {
        jsObject[.orientationX].fromJSValue()!
    }
    
    public var orientationY: AudioParam {
        jsObject[.orientationY].fromJSValue()!
    }
    
    public var orientationZ: AudioParam {
        jsObject[.orientationZ].fromJSValue()!
    }
    
    public var distanceModel: DistanceModelType {
        get { jsObject[.distanceModel].fromJSValue()!}
        set { jsObject[.distanceModel] = newValue.jsValue }
    }
    
    public var refDistance: Double {
        get { jsObject[.refDistance].fromJSValue()!}
        set { jsObject[.refDistance] = newValue.jsValue }
    }
    
    public var maxDistance: Double {
        get { jsObject[.maxDistance].fromJSValue()!}
        set { jsObject[.maxDistance] = newValue.jsValue }
    }
    
    public var rolloffFactor: Double {
        get { jsObject[.rolloffFactor].fromJSValue()!}
        set { jsObject[.rolloffFactor] = newValue.jsValue }
    }
    
    public var coneInnerAngle: Double {
        get { jsObject[.coneInnerAngle].fromJSValue()!}
        set { jsObject[.coneInnerAngle] = newValue.jsValue }
    }
    
    public var coneOuterAngle: Double {
        get { jsObject[.coneOuterAngle].fromJSValue()!}
        set { jsObject[.coneOuterAngle] = newValue.jsValue }
    }
    
    public var coneOuterGain: Double {
        get { jsObject[.coneOuterGain].fromJSValue()!}
        set { jsObject[.coneOuterGain] = newValue.jsValue }
    }
    
    @inlinable public func setPosition(x: Float, y: Float, z: Float) {
        let this = jsObject
        _ = this[.setPosition].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z)])
    }
    
    @inlinable public func setOrientation(x: Float, y: Float, z: Float) {
        let this = jsObject
        _ = this[.setOrientation].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z)])
    }
}

public class PannerOptions: BridgedDictionary {
    public convenience init(panningModel: PanningModelType, distanceModel: DistanceModelType, positionX: Float, positionY: Float, positionZ: Float, orientationX: Float, orientationY: Float, orientationZ: Float, refDistance: Double, maxDistance: Double, rolloffFactor: Double, coneInnerAngle: Double, coneOuterAngle: Double, coneOuterGain: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.panningModel] = _toJSValue(panningModel)
        object[.distanceModel] = _toJSValue(distanceModel)
        object[.positionX] = _toJSValue(positionX)
        object[.positionY] = _toJSValue(positionY)
        object[.positionZ] = _toJSValue(positionZ)
        object[.orientationX] = _toJSValue(orientationX)
        object[.orientationY] = _toJSValue(orientationY)
        object[.orientationZ] = _toJSValue(orientationZ)
        object[.refDistance] = _toJSValue(refDistance)
        object[.maxDistance] = _toJSValue(maxDistance)
        object[.rolloffFactor] = _toJSValue(rolloffFactor)
        object[.coneInnerAngle] = _toJSValue(coneInnerAngle)
        object[.coneOuterAngle] = _toJSValue(coneOuterAngle)
        object[.coneOuterGain] = _toJSValue(coneOuterGain)
        self.init(unsafelyWrapping: object)
    }
    
   public var panningModel: PanningModelType {
        get { jsObject[.panningModel].fromJSValue()!}
        set { jsObject[.panningModel] = newValue.jsValue }
    }
    
    public var distanceModel: DistanceModelType {
        get { jsObject[.distanceModel].fromJSValue()!}
        set { jsObject[.distanceModel] = newValue.jsValue }
    }
    
    public var positionX: Float {
        get { jsObject[.positionX].fromJSValue()!}
        set { jsObject[.positionX] = newValue.jsValue }
    }
    
    public var positionY: Float {
        get { jsObject[.positionY].fromJSValue()!}
        set { jsObject[.positionY] = newValue.jsValue }
    }
    
    public var positionZ: Float {
        get { jsObject[.positionZ].fromJSValue()!}
        set { jsObject[.positionZ] = newValue.jsValue }
    }
    
    public var orientationX: Float {
        get { jsObject[.orientationX].fromJSValue()!}
        set { jsObject[.orientationX] = newValue.jsValue }
    }
    
    public var orientationY: Float {
        get { jsObject[.orientationY].fromJSValue()!}
        set { jsObject[.orientationY] = newValue.jsValue }
    }
    
    public var orientationZ: Float {
        get { jsObject[.orientationZ].fromJSValue()!}
        set { jsObject[.orientationZ] = newValue.jsValue }
    }
    
    public var refDistance: Double {
        get { jsObject[.refDistance].fromJSValue()!}
        set { jsObject[.refDistance] = newValue.jsValue }
    }
    
    public var maxDistance: Double {
        get { jsObject[.maxDistance].fromJSValue()!}
        set { jsObject[.maxDistance] = newValue.jsValue }
    }
    
    public var rolloffFactor: Double {
        get { jsObject[.rolloffFactor].fromJSValue()!}
        set { jsObject[.rolloffFactor] = newValue.jsValue }
    }
    
    public var coneInnerAngle: Double {
        get { jsObject[.coneInnerAngle].fromJSValue()!}
        set { jsObject[.coneInnerAngle] = newValue.jsValue }
    }
    
    public var coneOuterAngle: Double {
        get { jsObject[.coneOuterAngle].fromJSValue()!}
        set { jsObject[.coneOuterAngle] = newValue.jsValue }
    }
    
    public var coneOuterGain: Double {
        get { jsObject[.coneOuterGain].fromJSValue()!}
        set { jsObject[.coneOuterGain] = newValue.jsValue }
    }
}

public enum PanningModelType: JSString, JSValueCompatible {
    case equalpower = "equalpower"
    case hRTF = "HRTF"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class PeriodicWave: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.PeriodicWave].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public convenience init(context: BaseAudioContext, options: PeriodicWaveOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
}

public class PeriodicWaveConstraints: BridgedDictionary {
    public convenience init(disableNormalization: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.disableNormalization] = _toJSValue(disableNormalization)
        self.init(unsafelyWrapping: object)
    }
    
   public var disableNormalization: Bool {
        get { jsObject[.disableNormalization].fromJSValue()!}
        set { jsObject[.disableNormalization] = newValue.jsValue }
    }
}

public class PeriodicWaveOptions: BridgedDictionary {
    public convenience init(real: [Float], imag: [Float]) {
        let object = JSObject.global[.Object].function!.new()
        object[.real] = _toJSValue(real)
        object[.imag] = _toJSValue(imag)
        self.init(unsafelyWrapping: object)
    }
    
    public var real: [Float] {
        get { jsObject[.real].fromJSValue()!}
        set { jsObject[.real] = newValue.jsValue }
    }
    
    public var imag: [Float] {
        get { jsObject[.imag].fromJSValue()!}
        set { jsObject[.imag] = newValue.jsValue }
    }
}

public class ScriptProcessorNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.ScriptProcessorNode].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        _onaudioprocess = ClosureAttribute1Optional(jsObject: jsObject, name: .onaudioprocess)
        super.init(unsafelyWrapping: jsObject)
    }
    
    @ClosureAttribute1Optional
    public var onaudioprocess: EventHandler
    
    public var bufferSize: Int32 {
        jsObject[.bufferSize].fromJSValue()!
    }
}

public class StereoPannerNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.StereoPannerNode].function }
    
   @inlinable public convenience init(context: BaseAudioContext, options: StereoPannerOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var pan: AudioParam {
        jsObject[.pan].fromJSValue()!
    }
}

public class StereoPannerOptions: BridgedDictionary {
    public convenience init(pan: Float) {
        let object = JSObject.global[.Object].function!.new()
        object[.pan] = _toJSValue(pan)
        self.init(unsafelyWrapping: object)
    }
    
   public var pan: Float {
        get { jsObject[.pan].fromJSValue()!}
        set { jsObject[.pan] = newValue.jsValue }
    }
}

public typealias DecodeErrorCallback = (DOMException) -> Void
public typealias DecodeSuccessCallback = (AudioBuffer) -> Void
public typealias AudioWorkletProcessCallback = ([[Float32Array]], [[Float32Array]], JSObject) -> Bool
public class WaveShaperNode: AudioNode {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.WaveShaperNode].function }
   
    @inlinable public convenience init(context: BaseAudioContext, options: WaveShaperOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(context), _toJSValue(options)]))
    }
    
    public var curve: Float32Array? {
        get { jsObject[.curve].fromJSValue()}
        set { jsObject[.curve] = newValue.jsValue }
    }
    
    public var oversample: OverSampleType {
        get { jsObject[.oversample].fromJSValue()!}
        set { jsObject[.oversample] = newValue.jsValue }
    }
}

public class WaveShaperOptions: BridgedDictionary {
    public convenience init(curve: [Float], oversample: OverSampleType) {
        let object = JSObject.global[.Object].function!.new()
        object[.curve] = _toJSValue(curve)
        object[.oversample] = _toJSValue(oversample)
        self.init(unsafelyWrapping: object)
    }
    
    public var curve: [Float] {
        get { jsObject[.curve].fromJSValue()!}
        set { jsObject[.curve] = newValue.jsValue }
    }
    
    public var oversample: OverSampleType {
        get { jsObject[.oversample].fromJSValue()!}
        set { jsObject[.oversample] = newValue.jsValue }
    }
}

extension JSString {
    @usableFromInline static let AnalyserNode: JSString = "AnalyserNode"
    @usableFromInline static let AudioBuffer: JSString = "AudioBuffer"
    @usableFromInline static let AudioBufferSourceNode: JSString = "AudioBufferSourceNode"
    @usableFromInline static let AudioContext: JSString = "AudioContext"
    @usableFromInline static let AudioDestinationNode: JSString = "AudioDestinationNode"
    @usableFromInline static let AudioListener: JSString = "AudioListener"
    @usableFromInline static let AudioNode: JSString = "AudioNode"
    @usableFromInline static let AudioParam: JSString = "AudioParam"
    @usableFromInline static let AudioParamMap: JSString = "AudioParamMap"
    @usableFromInline static let AudioProcessingEvent: JSString = "AudioProcessingEvent"
    @usableFromInline static let AudioRenderCapacity: JSString = "AudioRenderCapacity"
    @usableFromInline static let AudioRenderCapacityEvent: JSString = "AudioRenderCapacityEvent"
    @usableFromInline static let AudioScheduledSourceNode: JSString = "AudioScheduledSourceNode"
    @usableFromInline static let AudioSinkInfo: JSString = "AudioSinkInfo"
    @usableFromInline static let AudioWorklet: JSString = "AudioWorklet"
    @usableFromInline static let AudioWorkletNode: JSString = "AudioWorkletNode"
    @usableFromInline static let BaseAudioContext: JSString = "BaseAudioContext"
    @usableFromInline static let BiquadFilterNode: JSString = "BiquadFilterNode"
    @usableFromInline static let ChannelMergerNode: JSString = "ChannelMergerNode"
    @usableFromInline static let ChannelSplitterNode: JSString = "ChannelSplitterNode"
    @usableFromInline static let ConstantSourceNode: JSString = "ConstantSourceNode"
    @usableFromInline static let ConvolverNode: JSString = "ConvolverNode"
    @usableFromInline static let DelayNode: JSString = "DelayNode"
    @usableFromInline static let DynamicsCompressorNode: JSString = "DynamicsCompressorNode"
    @usableFromInline static let GainNode: JSString = "GainNode"
    @usableFromInline static let IIRFilterNode: JSString = "IIRFilterNode"
    @usableFromInline static let MediaElementAudioSourceNode: JSString = "MediaElementAudioSourceNode"
    @usableFromInline static let MediaStreamAudioDestinationNode: JSString = "MediaStreamAudioDestinationNode"
    @usableFromInline static let MediaStreamAudioSourceNode: JSString = "MediaStreamAudioSourceNode"
    @usableFromInline static let MediaStreamTrackAudioSourceNode: JSString = "MediaStreamTrackAudioSourceNode"
    //    @usableFromInline static let Object: JSString = "Object"
    @usableFromInline static let OfflineAudioCompletionEvent: JSString = "OfflineAudioCompletionEvent"
    @usableFromInline static let OfflineAudioContext: JSString = "OfflineAudioContext"
    @usableFromInline static let OscillatorNode: JSString = "OscillatorNode"
    @usableFromInline static let PannerNode: JSString = "PannerNode"
    @usableFromInline static let PeriodicWave: JSString = "PeriodicWave"
    @usableFromInline static let Q: JSString = "Q"
    @usableFromInline static let ScriptProcessorNode: JSString = "ScriptProcessorNode"
    @usableFromInline static let StereoPannerNode: JSString = "StereoPannerNode"
    @usableFromInline static let WaveShaperNode: JSString = "WaveShaperNode"
    @usableFromInline static let attack: JSString = "attack"
    @usableFromInline static let audioWorklet: JSString = "audioWorklet"
    @usableFromInline static let automationRate: JSString = "automationRate"
    @usableFromInline static let averageLoad: JSString = "averageLoad"
    @usableFromInline static let baseLatency: JSString = "baseLatency"
    @usableFromInline static let buffer: JSString = "buffer"
    @usableFromInline static let bufferSize: JSString = "bufferSize"
    @usableFromInline static let cancelAndHoldAtTime: JSString = "cancelAndHoldAtTime"
    @usableFromInline static let cancelScheduledValues: JSString = "cancelScheduledValues"
    //    @usableFromInline static let channelCount: JSString = "channelCount"
    @usableFromInline static let channelCountMode: JSString = "channelCountMode"
    @usableFromInline static let channelInterpretation: JSString = "channelInterpretation"
    //    @usableFromInline static let close: JSString = "close"
    @usableFromInline static let coneInnerAngle: JSString = "coneInnerAngle"
    @usableFromInline static let coneOuterAngle: JSString = "coneOuterAngle"
    @usableFromInline static let coneOuterGain: JSString = "coneOuterGain"
    @usableFromInline static let connect: JSString = "connect"
    @usableFromInline static let context: JSString = "context"
    @usableFromInline static let contextTime: JSString = "contextTime"
    @usableFromInline static let copyFromChannel: JSString = "copyFromChannel"
    @usableFromInline static let copyToChannel: JSString = "copyToChannel"
    @usableFromInline static let createAnalyser: JSString = "createAnalyser"
    @usableFromInline static let createBiquadFilter: JSString = "createBiquadFilter"
    @usableFromInline static let createBuffer: JSString = "createBuffer"
    @usableFromInline static let createBufferSource: JSString = "createBufferSource"
    @usableFromInline static let createChannelMerger: JSString = "createChannelMerger"
    @usableFromInline static let createChannelSplitter: JSString = "createChannelSplitter"
    @usableFromInline static let createConstantSource: JSString = "createConstantSource"
    @usableFromInline static let createConvolver: JSString = "createConvolver"
    @usableFromInline static let createDelay: JSString = "createDelay"
    @usableFromInline static let createDynamicsCompressor: JSString = "createDynamicsCompressor"
    @usableFromInline static let createGain: JSString = "createGain"
    @usableFromInline static let createIIRFilter: JSString = "createIIRFilter"
    @usableFromInline static let createMediaElementSource: JSString = "createMediaElementSource"
    @usableFromInline static let createMediaStreamDestination: JSString = "createMediaStreamDestination"
    @usableFromInline static let createMediaStreamSource: JSString = "createMediaStreamSource"
    @usableFromInline static let createMediaStreamTrackSource: JSString = "createMediaStreamTrackSource"
    @usableFromInline static let createOscillator: JSString = "createOscillator"
    @usableFromInline static let createPanner: JSString = "createPanner"
    @usableFromInline static let createPeriodicWave: JSString = "createPeriodicWave"
    @usableFromInline static let createScriptProcessor: JSString = "createScriptProcessor"
    @usableFromInline static let createStereoPanner: JSString = "createStereoPanner"
    @usableFromInline static let createWaveShaper: JSString = "createWaveShaper"
    //    @usableFromInline static let currentTime: JSString = "currentTime"
    @usableFromInline static let curve: JSString = "curve"
    @usableFromInline static let decodeAudioData: JSString = "decodeAudioData"
    //    @usableFromInline static let defaultValue: JSString = "defaultValue"
    @usableFromInline static let delayTime: JSString = "delayTime"
    //    @usableFromInline static let destination: JSString = "destination"
    @usableFromInline static let detune: JSString = "detune"
    @usableFromInline static let disableNormalization: JSString = "disableNormalization"
    //    @usableFromInline static let disconnect: JSString = "disconnect"
    @usableFromInline static let distanceModel: JSString = "distanceModel"
    //    @usableFromInline static let duration: JSString = "duration"
    @usableFromInline static let exponentialRampToValueAtTime: JSString = "exponentialRampToValueAtTime"
    @usableFromInline static let feedback: JSString = "feedback"
    @usableFromInline static let feedforward: JSString = "feedforward"
    @usableFromInline static let fftSize: JSString = "fftSize"
    @usableFromInline static let forwardX: JSString = "forwardX"
    @usableFromInline static let forwardY: JSString = "forwardY"
    @usableFromInline static let forwardZ: JSString = "forwardZ"
    @usableFromInline static let frequency: JSString = "frequency"
    @usableFromInline static let frequencyBinCount: JSString = "frequencyBinCount"
    @usableFromInline static let gain: JSString = "gain"
    @usableFromInline static let getByteFrequencyData: JSString = "getByteFrequencyData"
    @usableFromInline static let getByteTimeDomainData: JSString = "getByteTimeDomainData"
    @usableFromInline static let getChannelData: JSString = "getChannelData"
    @usableFromInline static let getFloatFrequencyData: JSString = "getFloatFrequencyData"
    @usableFromInline static let getFloatTimeDomainData: JSString = "getFloatTimeDomainData"
    @usableFromInline static let getFrequencyResponse: JSString = "getFrequencyResponse"
    @usableFromInline static let getOutputTimestamp: JSString = "getOutputTimestamp"
    @usableFromInline static let imag: JSString = "imag"
    @usableFromInline static let inputBuffer: JSString = "inputBuffer"
    @usableFromInline static let knee: JSString = "knee"
    @usableFromInline static let latencyHint: JSString = "latencyHint"
    //    @usableFromInline static let length: JSString = "length"
    @usableFromInline static let linearRampToValueAtTime: JSString = "linearRampToValueAtTime"
    @usableFromInline static let listener: JSString = "listener"
    //    @usableFromInline static let loop: JSString = "loop"
    @usableFromInline static let loopEnd: JSString = "loopEnd"
    @usableFromInline static let loopStart: JSString = "loopStart"
    @usableFromInline static let maxChannelCount: JSString = "maxChannelCount"
    @usableFromInline static let maxDecibels: JSString = "maxDecibels"
    @usableFromInline static let maxDelayTime: JSString = "maxDelayTime"
    @usableFromInline static let maxDistance: JSString = "maxDistance"
    @usableFromInline static let maxValue: JSString = "maxValue"
    @usableFromInline static let mediaElement: JSString = "mediaElement"
    @usableFromInline static let mediaStream: JSString = "mediaStream"
    @usableFromInline static let mediaStreamTrack: JSString = "mediaStreamTrack"
    @usableFromInline static let minDecibels: JSString = "minDecibels"
    @usableFromInline static let minValue: JSString = "minValue"
    //    @usableFromInline static let name: JSString = "name"
    //    @usableFromInline static let normalize: JSString = "normalize"
    //    @usableFromInline static let numberOfChannels: JSString = "numberOfChannels"
    @usableFromInline static let numberOfInputs: JSString = "numberOfInputs"
    @usableFromInline static let numberOfOutputs: JSString = "numberOfOutputs"
    //    @usableFromInline static let offset: JSString = "offset"
    @usableFromInline static let onaudioprocess: JSString = "onaudioprocess"
    @usableFromInline static let oncomplete: JSString = "oncomplete"
    //    @usableFromInline static let onended: JSString = "onended"
    @usableFromInline static let onprocessorerror: JSString = "onprocessorerror"
    @usableFromInline static let onsinkchange: JSString = "onsinkchange"
    //    @usableFromInline static let onstatechange: JSString = "onstatechange"
    //    @usableFromInline static let onupdate: JSString = "onupdate"
    @usableFromInline static let orientationX: JSString = "orientationX"
    @usableFromInline static let orientationY: JSString = "orientationY"
    @usableFromInline static let orientationZ: JSString = "orientationZ"
    @usableFromInline static let outputBuffer: JSString = "outputBuffer"
    @usableFromInline static let outputChannelCount: JSString = "outputChannelCount"
    @usableFromInline static let outputLatency: JSString = "outputLatency"
    @usableFromInline static let oversample: JSString = "oversample"
    @usableFromInline static let pan: JSString = "pan"
    @usableFromInline static let panningModel: JSString = "panningModel"
    @usableFromInline static let parameterData: JSString = "parameterData"
    @usableFromInline static let parameters: JSString = "parameters"
    @usableFromInline static let peakLoad: JSString = "peakLoad"
    @usableFromInline static let performanceTime: JSString = "performanceTime"
    @usableFromInline static let periodicWave: JSString = "periodicWave"
    //    @usableFromInline static let playbackRate: JSString = "playbackRate"
    @usableFromInline static let playbackTime: JSString = "playbackTime"
    //    @usableFromInline static let port: JSString = "port"
    @usableFromInline static let positionX: JSString = "positionX"
    @usableFromInline static let positionY: JSString = "positionY"
    @usableFromInline static let positionZ: JSString = "positionZ"
    @usableFromInline static let processorOptions: JSString = "processorOptions"
    @usableFromInline static let ratio: JSString = "ratio"
    @usableFromInline static let real: JSString = "real"
    @usableFromInline static let reduction: JSString = "reduction"
    @usableFromInline static let refDistance: JSString = "refDistance"
    @usableFromInline static let release: JSString = "release"
    @usableFromInline static let renderCapacity: JSString = "renderCapacity"
    @usableFromInline static let renderedBuffer: JSString = "renderedBuffer"
    //    @usableFromInline static let resume: JSString = "resume"
    @usableFromInline static let rolloffFactor: JSString = "rolloffFactor"
    //    @usableFromInline static let sampleRate: JSString = "sampleRate"
    @usableFromInline static let setOrientation: JSString = "setOrientation"
    @usableFromInline static let setPeriodicWave: JSString = "setPeriodicWave"
    @usableFromInline static let setPosition: JSString = "setPosition"
    @usableFromInline static let setSinkId: JSString = "setSinkId"
    @usableFromInline static let setTargetAtTime: JSString = "setTargetAtTime"
    @usableFromInline static let setValueAtTime: JSString = "setValueAtTime"
    @usableFromInline static let setValueCurveAtTime: JSString = "setValueCurveAtTime"
    @usableFromInline static let sinkId: JSString = "sinkId"
    @usableFromInline static let smoothingTimeConstant: JSString = "smoothingTimeConstant"
    //    @usableFromInline static let start: JSString = "start"
    @usableFromInline static let startRendering: JSString = "startRendering"
    //    @usableFromInline static let state: JSString = "state"
    //    @usableFromInline static let stop: JSString = "stop"
    //    @usableFromInline static let stream: JSString = "stream"
    @usableFromInline static let suspend: JSString = "suspend"
    @usableFromInline static let threshold: JSString = "threshold"
    //    @usableFromInline static let timestamp: JSString = "timestamp"
    //    @usableFromInline static let toString: JSString = "toString"
    //    @usableFromInline static let type: JSString = "type"
    @usableFromInline static let underrunRatio: JSString = "underrunRatio"
    @usableFromInline static let upX: JSString = "upX"
    @usableFromInline static let upY: JSString = "upY"
    @usableFromInline static let upZ: JSString = "upZ"
    @usableFromInline static let updateInterval: JSString = "updateInterval"
    //    @usableFromInline static let value: JSString = "value"
}

public protocol Any_AudioContextLatencyCategory_or_Double: ConvertibleToJSValue {}
extension AudioContextLatencyCategory: Any_AudioContextLatencyCategory_or_Double {}
extension Double: Any_AudioContextLatencyCategory_or_Double {}

public enum AudioContextLatencyCategory_or_Double: JSValueCompatible, Any_AudioContextLatencyCategory_or_Double {
    case audioContextLatencyCategory(AudioContextLatencyCategory)
    case double(Double)
    
    init(_ audioContextLatencyCategory: AudioContextLatencyCategory) {
        let val: AudioContextLatencyCategory_or_Double = .audioContextLatencyCategory(audioContextLatencyCategory)
        self = val
    }
    
    init(_ double: Double) {
        let val: AudioContextLatencyCategory_or_Double = .double(double)
        self = val
    }
    
    public var audioContextLatencyCategory: AudioContextLatencyCategory? {
        switch self {
        case let .audioContextLatencyCategory(audioContextLatencyCategory): return audioContextLatencyCategory
        default: return nil
        }
    }
    
    public var double: Double? {
        switch self {
        case let .double(double): return double
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let audioContextLatencyCategory: AudioContextLatencyCategory = value.fromJSValue() {
            return .audioContextLatencyCategory(audioContextLatencyCategory)
        }
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .audioContextLatencyCategory(audioContextLatencyCategory):
            return audioContextLatencyCategory.jsValue
        case let .double(double):
            return double.jsValue
        }
    }
}

public protocol Any_AudioSinkInfo_or_String: ConvertibleToJSValue {}
extension AudioSinkInfo: Any_AudioSinkInfo_or_String {}
extension String: Any_AudioSinkInfo_or_String {}

public enum AudioSinkInfo_or_String: JSValueCompatible, Any_AudioSinkInfo_or_String {
    case audioSinkInfo(AudioSinkInfo)
    case string(String)
    
    init(_ audioSinkInfo: AudioSinkInfo) {
        let val: AudioSinkInfo_or_String = .audioSinkInfo(audioSinkInfo)
        self = val
    }
    
    init(_ string: String) {
        let val: AudioSinkInfo_or_String = .string(string)
        self = val
    }
    
    public var audioSinkInfo: AudioSinkInfo? {
        switch self {
        case let .audioSinkInfo(audioSinkInfo): return audioSinkInfo
        default: return nil
        }
    }
    
    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let audioSinkInfo: AudioSinkInfo = value.fromJSValue() {
            return .audioSinkInfo(audioSinkInfo)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .audioSinkInfo(audioSinkInfo):
            return audioSinkInfo.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public protocol Any_AudioSinkOptions_or_String: ConvertibleToJSValue {}
extension AudioSinkOptions: Any_AudioSinkOptions_or_String {}
extension String: Any_AudioSinkOptions_or_String {}

public enum AudioSinkOptions_or_String: JSValueCompatible, Any_AudioSinkOptions_or_String {
    case audioSinkOptions(AudioSinkOptions)
    case string(String)
    
    init(_ audioSinkOptions: AudioSinkOptions) {
        let val: AudioSinkOptions_or_String = .audioSinkOptions(audioSinkOptions)
        self = val
    }
    
    init(_ string: String) {
        let val: AudioSinkOptions_or_String = .string(string)
        self = val
    }
    
    public var audioSinkOptions: AudioSinkOptions? {
        switch self {
        case let .audioSinkOptions(audioSinkOptions): return audioSinkOptions
        default: return nil
        }
    }
    
    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let audioSinkOptions: AudioSinkOptions = value.fromJSValue() {
            return .audioSinkOptions(audioSinkOptions)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .audioSinkOptions(audioSinkOptions):
            return audioSinkOptions.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}
