// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptBigIntSupport
import JavaScriptEventLoop
import JavaScriptKit
import WebAnimations
import WebAPIBase
import WebGL1

public class GPU: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPU].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _wgslLanguageFeatures = ReadonlyAttribute(jsObject: jsObject, name: .wgslLanguageFeatures)
        self.jsObject = jsObject
    }

    @inlinable public func requestAdapter(options: GPURequestAdapterOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.requestAdapter].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestAdapter(options: GPURequestAdapterOptions? = nil) async throws -> GPUAdapter? {
        let this = jsObject
        let _promise: JSPromise = this[.requestAdapter].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()
    }

    @inlinable public func getPreferredCanvasFormat() -> GPUTextureFormat {
        let this = jsObject
        return this[.getPreferredCanvasFormat].function!(this: this, arguments: []).fromJSValue()!
    }

    @ReadonlyAttribute
    public var wgslLanguageFeatures: WGSLLanguageFeatures
}

public class GPUAdapter: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUAdapter].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _features = ReadonlyAttribute(jsObject: jsObject, name: .features)
        _limits = ReadonlyAttribute(jsObject: jsObject, name: .limits)
        _isFallbackAdapter = ReadonlyAttribute(jsObject: jsObject, name: .isFallbackAdapter)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var features: GPUSupportedFeatures

    @ReadonlyAttribute
    public var limits: GPUSupportedLimits

    @ReadonlyAttribute
    public var isFallbackAdapter: Bool

    @inlinable public func requestDevice(descriptor: GPUDeviceDescriptor? = nil) -> JSPromise {
        let this = jsObject
        return this[.requestDevice].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestDevice(descriptor: GPUDeviceDescriptor? = nil) async throws -> GPUDevice {
        let this = jsObject
        let _promise: JSPromise = this[.requestDevice].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func requestAdapterInfo(unmaskHints: [String]? = nil) -> JSPromise {
        let this = jsObject
        return this[.requestAdapterInfo].function!(this: this, arguments: [_toJSValue(unmaskHints)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestAdapterInfo(unmaskHints: [String]? = nil) async throws -> GPUAdapterInfo {
        let this = jsObject
        let _promise: JSPromise = this[.requestAdapterInfo].function!(this: this, arguments: [_toJSValue(unmaskHints)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class GPUAdapterInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUAdapterInfo].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _vendor = ReadonlyAttribute(jsObject: jsObject, name: .vendor)
        _architecture = ReadonlyAttribute(jsObject: jsObject, name: .architecture)
        _device = ReadonlyAttribute(jsObject: jsObject, name: .device)
        _description = ReadonlyAttribute(jsObject: jsObject, name: .description)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var vendor: String

    @ReadonlyAttribute
    public var architecture: String

    @ReadonlyAttribute
    public var device: String

    @ReadonlyAttribute
    public var description: String
}

public enum GPUAddressMode: JSString, JSValueCompatible {
    case clampToEdge = "clamp-to-edge"
    case `repeat` = "repeat"
    case mirrorRepeat = "mirror-repeat"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUAutoLayoutMode: JSString, JSValueCompatible {
    case auto = "auto"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBindGroup: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUBindGroup].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUBindGroupDescriptor: BridgedDictionary {
    public convenience init(layout: GPUBindGroupLayout, entries: [GPUBindGroupEntry]) {
        let object = JSObject.global[.Object].function!.new()
        object[.layout] = _toJSValue(layout)
        object[.entries] = _toJSValue(entries)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _layout = ReadWriteAttribute(jsObject: object, name: .layout)
        _entries = ReadWriteAttribute(jsObject: object, name: .entries)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var layout: GPUBindGroupLayout

    @ReadWriteAttribute
    public var entries: [GPUBindGroupEntry]
}

public class GPUBindGroupEntry: BridgedDictionary {
    public convenience init(binding: GPUIndex32, resource: GPUBindingResource) {
        let object = JSObject.global[.Object].function!.new()
        object[.binding] = _toJSValue(binding)
        object[.resource] = _toJSValue(resource)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _binding = ReadWriteAttribute(jsObject: object, name: .binding)
        _resource = ReadWriteAttribute(jsObject: object, name: .resource)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var binding: GPUIndex32

    @ReadWriteAttribute
    public var resource: GPUBindingResource
}

public class GPUBindGroupLayout: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUBindGroupLayout].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUBindGroupLayoutDescriptor: BridgedDictionary {
    public convenience init(entries: [GPUBindGroupLayoutEntry]) {
        let object = JSObject.global[.Object].function!.new()
        object[.entries] = _toJSValue(entries)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _entries = ReadWriteAttribute(jsObject: object, name: .entries)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var entries: [GPUBindGroupLayoutEntry]
}

public class GPUBindGroupLayoutEntry: BridgedDictionary {
    public convenience init(binding: GPUIndex32, visibility: GPUShaderStageFlags, buffer: GPUBufferBindingLayout, sampler: GPUSamplerBindingLayout, texture: GPUTextureBindingLayout, storageTexture: GPUStorageTextureBindingLayout, externalTexture: GPUExternalTextureBindingLayout) {
        let object = JSObject.global[.Object].function!.new()
        object[.binding] = _toJSValue(binding)
        object[.visibility] = _toJSValue(visibility)
        object[.buffer] = _toJSValue(buffer)
        object[.sampler] = _toJSValue(sampler)
        object[.texture] = _toJSValue(texture)
        object[.storageTexture] = _toJSValue(storageTexture)
        object[.externalTexture] = _toJSValue(externalTexture)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _binding = ReadWriteAttribute(jsObject: object, name: .binding)
        _visibility = ReadWriteAttribute(jsObject: object, name: .visibility)
        _buffer = ReadWriteAttribute(jsObject: object, name: .buffer)
        _sampler = ReadWriteAttribute(jsObject: object, name: .sampler)
        _texture = ReadWriteAttribute(jsObject: object, name: .texture)
        _storageTexture = ReadWriteAttribute(jsObject: object, name: .storageTexture)
        _externalTexture = ReadWriteAttribute(jsObject: object, name: .externalTexture)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var binding: GPUIndex32

    @ReadWriteAttribute
    public var visibility: GPUShaderStageFlags

    @ReadWriteAttribute
    public var buffer: GPUBufferBindingLayout

    @ReadWriteAttribute
    public var sampler: GPUSamplerBindingLayout

    @ReadWriteAttribute
    public var texture: GPUTextureBindingLayout

    @ReadWriteAttribute
    public var storageTexture: GPUStorageTextureBindingLayout

    @ReadWriteAttribute
    public var externalTexture: GPUExternalTextureBindingLayout
}

public protocol GPUBindingCommandsMixin: JSBridgedClass {}
public extension GPUBindingCommandsMixin {
    @inlinable func setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup?, dynamicOffsets: [GPUBufferDynamicOffset]? = nil) {
        let this = jsObject
        _ = this[.setBindGroup].function!(this: this, arguments: [_toJSValue(index), _toJSValue(bindGroup), _toJSValue(dynamicOffsets)])
    }

    @inlinable func setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup?, dynamicOffsetsData: Uint32Array, dynamicOffsetsDataStart: GPUSize64, dynamicOffsetsDataLength: GPUSize32) {
        let this = jsObject
        _ = this[.setBindGroup].function!(this: this, arguments: [_toJSValue(index), _toJSValue(bindGroup), _toJSValue(dynamicOffsetsData), _toJSValue(dynamicOffsetsDataStart), _toJSValue(dynamicOffsetsDataLength)])
    }
}

public class GPUBlendComponent: BridgedDictionary {
    public convenience init(operation: GPUBlendOperation, srcFactor: GPUBlendFactor, dstFactor: GPUBlendFactor) {
        let object = JSObject.global[.Object].function!.new()
        object[.operation] = _toJSValue(operation)
        object[.srcFactor] = _toJSValue(srcFactor)
        object[.dstFactor] = _toJSValue(dstFactor)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _operation = ReadWriteAttribute(jsObject: object, name: .operation)
        _srcFactor = ReadWriteAttribute(jsObject: object, name: .srcFactor)
        _dstFactor = ReadWriteAttribute(jsObject: object, name: .dstFactor)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var operation: GPUBlendOperation

    @ReadWriteAttribute
    public var srcFactor: GPUBlendFactor

    @ReadWriteAttribute
    public var dstFactor: GPUBlendFactor
}

public enum GPUBlendFactor: JSString, JSValueCompatible {
    case zero = "zero"
    case one = "one"
    case src = "src"
    case oneMinusSrc = "one-minus-src"
    case srcAlpha = "src-alpha"
    case oneMinusSrcAlpha = "one-minus-src-alpha"
    case dst = "dst"
    case oneMinusDst = "one-minus-dst"
    case dstAlpha = "dst-alpha"
    case oneMinusDstAlpha = "one-minus-dst-alpha"
    case srcAlphaSaturated = "src-alpha-saturated"
    case constant = "constant"
    case oneMinusConstant = "one-minus-constant"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUBlendOperation: JSString, JSValueCompatible {
    case add = "add"
    case subtract = "subtract"
    case reverseSubtract = "reverse-subtract"
    case min = "min"
    case max = "max"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBlendState: BridgedDictionary {
    public convenience init(color: GPUBlendComponent, alpha: GPUBlendComponent) {
        let object = JSObject.global[.Object].function!.new()
        object[.color] = _toJSValue(color)
        object[.alpha] = _toJSValue(alpha)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _color = ReadWriteAttribute(jsObject: object, name: .color)
        _alpha = ReadWriteAttribute(jsObject: object, name: .alpha)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var color: GPUBlendComponent

    @ReadWriteAttribute
    public var alpha: GPUBlendComponent
}

public class GPUBuffer: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUBuffer].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _size = ReadonlyAttribute(jsObject: jsObject, name: .size)
        _usage = ReadonlyAttribute(jsObject: jsObject, name: .usage)
        _mapState = ReadonlyAttribute(jsObject: jsObject, name: .mapState)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var size: GPUSize64Out

    @ReadonlyAttribute
    public var usage: GPUFlagsConstant

    @ReadonlyAttribute
    public var mapState: GPUBufferMapState

    @inlinable public func mapAsync(mode: GPUMapModeFlags, offset: GPUSize64? = nil, size: GPUSize64? = nil) -> JSPromise {
        let this = jsObject
        return this[.mapAsync].function!(this: this, arguments: [_toJSValue(mode), _toJSValue(offset), _toJSValue(size)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func mapAsync(mode: GPUMapModeFlags, offset: GPUSize64? = nil, size: GPUSize64? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.mapAsync].function!(this: this, arguments: [_toJSValue(mode), _toJSValue(offset), _toJSValue(size)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func getMappedRange(offset: GPUSize64? = nil, size: GPUSize64? = nil) -> ArrayBuffer {
        let this = jsObject
        return this[.getMappedRange].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(size)]).fromJSValue()!
    }

    @inlinable public func unmap() {
        let this = jsObject
        _ = this[.unmap].function!(this: this, arguments: [])
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[.destroy].function!(this: this, arguments: [])
    }
}

public class GPUBufferBinding: BridgedDictionary {
    public convenience init(buffer: GPUBuffer, offset: GPUSize64, size: GPUSize64) {
        let object = JSObject.global[.Object].function!.new()
        object[.buffer] = _toJSValue(buffer)
        object[.offset] = _toJSValue(offset)
        object[.size] = _toJSValue(size)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: object, name: .buffer)
        _offset = ReadWriteAttribute(jsObject: object, name: .offset)
        _size = ReadWriteAttribute(jsObject: object, name: .size)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffer: GPUBuffer

    @ReadWriteAttribute
    public var offset: GPUSize64

    @ReadWriteAttribute
    public var size: GPUSize64
}

public class GPUBufferBindingLayout: BridgedDictionary {
    public convenience init(type: GPUBufferBindingType, hasDynamicOffset: Bool, minBindingSize: GPUSize64) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.hasDynamicOffset] = _toJSValue(hasDynamicOffset)
        object[.minBindingSize] = _toJSValue(minBindingSize)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        _hasDynamicOffset = ReadWriteAttribute(jsObject: object, name: .hasDynamicOffset)
        _minBindingSize = ReadWriteAttribute(jsObject: object, name: .minBindingSize)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: GPUBufferBindingType

    @ReadWriteAttribute
    public var hasDynamicOffset: Bool

    @ReadWriteAttribute
    public var minBindingSize: GPUSize64
}

public enum GPUBufferBindingType: JSString, JSValueCompatible {
    case uniform = "uniform"
    case storage = "storage"
    case readOnlyStorage = "read-only-storage"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBufferDescriptor: BridgedDictionary {
    public convenience init(size: GPUSize64, usage: GPUBufferUsageFlags, mappedAtCreation: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.size] = _toJSValue(size)
        object[.usage] = _toJSValue(usage)
        object[.mappedAtCreation] = _toJSValue(mappedAtCreation)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _size = ReadWriteAttribute(jsObject: object, name: .size)
        _usage = ReadWriteAttribute(jsObject: object, name: .usage)
        _mappedAtCreation = ReadWriteAttribute(jsObject: object, name: .mappedAtCreation)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var size: GPUSize64

    @ReadWriteAttribute
    public var usage: GPUBufferUsageFlags

    @ReadWriteAttribute
    public var mappedAtCreation: Bool
}

public enum GPUBufferMapState: JSString, JSValueCompatible {
    case unmapped = "unmapped"
    case pending = "pending"
    case mapped = "mapped"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUBufferUsage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[.GPUBufferUsage].object!
    }

    public static let MAP_READ: GPUFlagsConstant = 0x0001

    public static let MAP_WRITE: GPUFlagsConstant = 0x0002

    public static let COPY_SRC: GPUFlagsConstant = 0x0004

    public static let COPY_DST: GPUFlagsConstant = 0x0008

    public static let INDEX: GPUFlagsConstant = 0x0010

    public static let VERTEX: GPUFlagsConstant = 0x0020

    public static let UNIFORM: GPUFlagsConstant = 0x0040

    public static let STORAGE: GPUFlagsConstant = 0x0080

    public static let INDIRECT: GPUFlagsConstant = 0x0100

    public static let QUERY_RESOLVE: GPUFlagsConstant = 0x0200
}

public enum GPUCanvasAlphaMode: JSString, JSValueCompatible {
    case opaque = "opaque"
    case premultiplied = "premultiplied"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUCanvasConfiguration: BridgedDictionary {
    public convenience init(device: GPUDevice, format: GPUTextureFormat, usage: GPUTextureUsageFlags, viewFormats: [GPUTextureFormat], colorSpace: PredefinedColorSpace, alphaMode: GPUCanvasAlphaMode) {
        let object = JSObject.global[.Object].function!.new()
        object[.device] = _toJSValue(device)
        object[.format] = _toJSValue(format)
        object[.usage] = _toJSValue(usage)
        object[.viewFormats] = _toJSValue(viewFormats)
        object[.colorSpace] = _toJSValue(colorSpace)
        object[.alphaMode] = _toJSValue(alphaMode)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _device = ReadWriteAttribute(jsObject: object, name: .device)
        _format = ReadWriteAttribute(jsObject: object, name: .format)
        _usage = ReadWriteAttribute(jsObject: object, name: .usage)
        _viewFormats = ReadWriteAttribute(jsObject: object, name: .viewFormats)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: .colorSpace)
        _alphaMode = ReadWriteAttribute(jsObject: object, name: .alphaMode)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var device: GPUDevice

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var usage: GPUTextureUsageFlags

    @ReadWriteAttribute
    public var viewFormats: [GPUTextureFormat]

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace

    @ReadWriteAttribute
    public var alphaMode: GPUCanvasAlphaMode
}

public class GPUCanvasContext: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUCanvasContext].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _canvas = ReadonlyAttribute(jsObject: jsObject, name: .canvas)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var canvas: RenderingCanvas

    @inlinable public func configure(configuration: GPUCanvasConfiguration) {
        let this = jsObject
        _ = this[.configure].function!(this: this, arguments: [_toJSValue(configuration)])
    }

    @inlinable public func unconfigure() {
        let this = jsObject
        _ = this[.unconfigure].function!(this: this, arguments: [])
    }

    @inlinable public func getCurrentTexture() -> GPUTexture {
        let this = jsObject
        return this[.getCurrentTexture].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class GPUColorDict: BridgedDictionary {
    public convenience init(r: Double, g: Double, b: Double, a: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.r] = _toJSValue(r)
        object[.g] = _toJSValue(g)
        object[.b] = _toJSValue(b)
        object[.a] = _toJSValue(a)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _r = ReadWriteAttribute(jsObject: object, name: .r)
        _g = ReadWriteAttribute(jsObject: object, name: .g)
        _b = ReadWriteAttribute(jsObject: object, name: .b)
        _a = ReadWriteAttribute(jsObject: object, name: .a)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var r: Double

    @ReadWriteAttribute
    public var g: Double

    @ReadWriteAttribute
    public var b: Double

    @ReadWriteAttribute
    public var a: Double
}

public class GPUColorTargetState: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, blend: GPUBlendState, writeMask: GPUColorWriteFlags) {
        let object = JSObject.global[.Object].function!.new()
        object[.format] = _toJSValue(format)
        object[.blend] = _toJSValue(blend)
        object[.writeMask] = _toJSValue(writeMask)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: .format)
        _blend = ReadWriteAttribute(jsObject: object, name: .blend)
        _writeMask = ReadWriteAttribute(jsObject: object, name: .writeMask)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var blend: GPUBlendState

    @ReadWriteAttribute
    public var writeMask: GPUColorWriteFlags
}

public enum GPUColorWrite {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[.GPUColorWrite].object!
    }

    public static let RED: GPUFlagsConstant = 0x1

    public static let GREEN: GPUFlagsConstant = 0x2

    public static let BLUE: GPUFlagsConstant = 0x4

    public static let ALPHA: GPUFlagsConstant = 0x8

    public static let ALL: GPUFlagsConstant = 0xF
}

public class GPUCommandBuffer: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUCommandBuffer].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUCommandBufferDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPUCommandEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUCommandEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func beginRenderPass(descriptor: GPURenderPassDescriptor) -> GPURenderPassEncoder {
        let this = jsObject
        return this[.beginRenderPass].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func beginComputePass(descriptor: GPUComputePassDescriptor? = nil) -> GPUComputePassEncoder {
        let this = jsObject
        return this[.beginComputePass].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func copyBufferToBuffer(source: GPUBuffer, sourceOffset: GPUSize64, destination: GPUBuffer, destinationOffset: GPUSize64, size: GPUSize64) {
        let this = jsObject
        _ = this[.copyBufferToBuffer].function!(this: this, arguments: [_toJSValue(source), _toJSValue(sourceOffset), _toJSValue(destination), _toJSValue(destinationOffset), _toJSValue(size)])
    }

    @inlinable public func copyBufferToTexture(source: GPUImageCopyBuffer, destination: GPUImageCopyTexture, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[.copyBufferToTexture].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }

    @inlinable public func copyTextureToBuffer(source: GPUImageCopyTexture, destination: GPUImageCopyBuffer, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[.copyTextureToBuffer].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }

    @inlinable public func copyTextureToTexture(source: GPUImageCopyTexture, destination: GPUImageCopyTexture, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[.copyTextureToTexture].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }

    @inlinable public func clearBuffer(buffer: GPUBuffer, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[.clearBuffer].function!(this: this, arguments: [_toJSValue(buffer), _toJSValue(offset), _toJSValue(size)])
    }

    @inlinable public func writeTimestamp(querySet: GPUQuerySet, queryIndex: GPUSize32) {
        let this = jsObject
        _ = this[.writeTimestamp].function!(this: this, arguments: [_toJSValue(querySet), _toJSValue(queryIndex)])
    }

    @inlinable public func resolveQuerySet(querySet: GPUQuerySet, firstQuery: GPUSize32, queryCount: GPUSize32, destination: GPUBuffer, destinationOffset: GPUSize64) {
        let this = jsObject
        _ = this[.resolveQuerySet].function!(this: this, arguments: [_toJSValue(querySet), _toJSValue(firstQuery), _toJSValue(queryCount), _toJSValue(destination), _toJSValue(destinationOffset)])
    }

    @inlinable public func finish(descriptor: GPUCommandBufferDescriptor? = nil) -> GPUCommandBuffer {
        let this = jsObject
        return this[.finish].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }
}

public class GPUCommandEncoderDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public protocol GPUCommandsMixin: JSBridgedClass {}
public extension GPUCommandsMixin {}

public enum GPUCompareFunction: JSString, JSValueCompatible {
    case never = "never"
    case less = "less"
    case equal = "equal"
    case lessEqual = "less-equal"
    case greater = "greater"
    case notEqual = "not-equal"
    case greaterEqual = "greater-equal"
    case always = "always"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUCompilationInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUCompilationInfo].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _messages = ReadonlyAttribute(jsObject: jsObject, name: .messages)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var messages: [GPUCompilationMessage]
}

public class GPUCompilationMessage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUCompilationMessage].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _message = ReadonlyAttribute(jsObject: jsObject, name: .message)
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _lineNum = ReadonlyAttribute(jsObject: jsObject, name: .lineNum)
        _linePos = ReadonlyAttribute(jsObject: jsObject, name: .linePos)
        _offset = ReadonlyAttribute(jsObject: jsObject, name: .offset)
        _length = ReadonlyAttribute(jsObject: jsObject, name: .length)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var message: String

    @ReadonlyAttribute
    public var type: GPUCompilationMessageType

    @ReadonlyAttribute
    public var lineNum: UInt64

    @ReadonlyAttribute
    public var linePos: UInt64

    @ReadonlyAttribute
    public var offset: UInt64

    @ReadonlyAttribute
    public var length: UInt64
}

public enum GPUCompilationMessageType: JSString, JSValueCompatible {
    case error = "error"
    case warning = "warning"
    case info = "info"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUComputePassDescriptor: BridgedDictionary {
    public convenience init(timestampWrites: GPUComputePassTimestampWrites) {
        let object = JSObject.global[.Object].function!.new()
        object[.timestampWrites] = _toJSValue(timestampWrites)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _timestampWrites = ReadWriteAttribute(jsObject: object, name: .timestampWrites)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var timestampWrites: GPUComputePassTimestampWrites
}

public class GPUComputePassEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUBindingCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUComputePassEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func setPipeline(pipeline: GPUComputePipeline) {
        let this = jsObject
        _ = this[.setPipeline].function!(this: this, arguments: [_toJSValue(pipeline)])
    }

    @inlinable public func dispatchWorkgroups(workgroupCountX: GPUSize32, workgroupCountY: GPUSize32? = nil, workgroupCountZ: GPUSize32? = nil) {
        let this = jsObject
        _ = this[.dispatchWorkgroups].function!(this: this, arguments: [_toJSValue(workgroupCountX), _toJSValue(workgroupCountY), _toJSValue(workgroupCountZ)])
    }

    @inlinable public func dispatchWorkgroupsIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[.dispatchWorkgroupsIndirect].function!(this: this, arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)])
    }

    @inlinable public func end() {
        let this = jsObject
        _ = this[.end].function!(this: this, arguments: [])
    }
}

public class GPUComputePassTimestampWrites: BridgedDictionary {
    public convenience init(querySet: GPUQuerySet, beginningOfPassWriteIndex: GPUSize32, endOfPassWriteIndex: GPUSize32) {
        let object = JSObject.global[.Object].function!.new()
        object[.querySet] = _toJSValue(querySet)
        object[.beginningOfPassWriteIndex] = _toJSValue(beginningOfPassWriteIndex)
        object[.endOfPassWriteIndex] = _toJSValue(endOfPassWriteIndex)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _querySet = ReadWriteAttribute(jsObject: object, name: .querySet)
        _beginningOfPassWriteIndex = ReadWriteAttribute(jsObject: object, name: .beginningOfPassWriteIndex)
        _endOfPassWriteIndex = ReadWriteAttribute(jsObject: object, name: .endOfPassWriteIndex)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var querySet: GPUQuerySet

    @ReadWriteAttribute
    public var beginningOfPassWriteIndex: GPUSize32

    @ReadWriteAttribute
    public var endOfPassWriteIndex: GPUSize32
}

public class GPUComputePipeline: JSBridgedClass, GPUObjectBase, GPUPipelineBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUComputePipeline].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUComputePipelineDescriptor: BridgedDictionary {
    public convenience init(compute: GPUProgrammableStage) {
        let object = JSObject.global[.Object].function!.new()
        object[.compute] = _toJSValue(compute)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _compute = ReadWriteAttribute(jsObject: object, name: .compute)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var compute: GPUProgrammableStage
}

public enum GPUCullMode: JSString, JSValueCompatible {
    case none = "none"
    case front = "front"
    case back = "back"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol GPUDebugCommandsMixin: JSBridgedClass {}
public extension GPUDebugCommandsMixin {
    @inlinable func pushDebugGroup(groupLabel: String) {
        let this = jsObject
        _ = this[.pushDebugGroup].function!(this: this, arguments: [_toJSValue(groupLabel)])
    }

    @inlinable func popDebugGroup() {
        let this = jsObject
        _ = this[.popDebugGroup].function!(this: this, arguments: [])
    }

    @inlinable func insertDebugMarker(markerLabel: String) {
        let this = jsObject
        _ = this[.insertDebugMarker].function!(this: this, arguments: [_toJSValue(markerLabel)])
    }
}

public class GPUDepthStencilState: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, depthWriteEnabled: Bool, depthCompare: GPUCompareFunction, stencilFront: GPUStencilFaceState, stencilBack: GPUStencilFaceState, stencilReadMask: GPUStencilValue, stencilWriteMask: GPUStencilValue, depthBias: GPUDepthBias, depthBiasSlopeScale: Float, depthBiasClamp: Float) {
        let object = JSObject.global[.Object].function!.new()
        object[.format] = _toJSValue(format)
        object[.depthWriteEnabled] = _toJSValue(depthWriteEnabled)
        object[.depthCompare] = _toJSValue(depthCompare)
        object[.stencilFront] = _toJSValue(stencilFront)
        object[.stencilBack] = _toJSValue(stencilBack)
        object[.stencilReadMask] = _toJSValue(stencilReadMask)
        object[.stencilWriteMask] = _toJSValue(stencilWriteMask)
        object[.depthBias] = _toJSValue(depthBias)
        object[.depthBiasSlopeScale] = _toJSValue(depthBiasSlopeScale)
        object[.depthBiasClamp] = _toJSValue(depthBiasClamp)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: .format)
        _depthWriteEnabled = ReadWriteAttribute(jsObject: object, name: .depthWriteEnabled)
        _depthCompare = ReadWriteAttribute(jsObject: object, name: .depthCompare)
        _stencilFront = ReadWriteAttribute(jsObject: object, name: .stencilFront)
        _stencilBack = ReadWriteAttribute(jsObject: object, name: .stencilBack)
        _stencilReadMask = ReadWriteAttribute(jsObject: object, name: .stencilReadMask)
        _stencilWriteMask = ReadWriteAttribute(jsObject: object, name: .stencilWriteMask)
        _depthBias = ReadWriteAttribute(jsObject: object, name: .depthBias)
        _depthBiasSlopeScale = ReadWriteAttribute(jsObject: object, name: .depthBiasSlopeScale)
        _depthBiasClamp = ReadWriteAttribute(jsObject: object, name: .depthBiasClamp)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var depthWriteEnabled: Bool

    @ReadWriteAttribute
    public var depthCompare: GPUCompareFunction

    @ReadWriteAttribute
    public var stencilFront: GPUStencilFaceState

    @ReadWriteAttribute
    public var stencilBack: GPUStencilFaceState

    @ReadWriteAttribute
    public var stencilReadMask: GPUStencilValue

    @ReadWriteAttribute
    public var stencilWriteMask: GPUStencilValue

    @ReadWriteAttribute
    public var depthBias: GPUDepthBias

    @ReadWriteAttribute
    public var depthBiasSlopeScale: Float

    @ReadWriteAttribute
    public var depthBiasClamp: Float
}

public class GPUDevice: EventTarget, GPUObjectBase {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUDevice].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _features = ReadonlyAttribute(jsObject: jsObject, name: .features)
        _limits = ReadonlyAttribute(jsObject: jsObject, name: .limits)
        _queue = ReadonlyAttribute(jsObject: jsObject, name: .queue)
        _lost = ReadonlyAttribute(jsObject: jsObject, name: .lost)
        _onuncapturederror = ClosureAttribute1Optional(jsObject: jsObject, name: .onuncapturederror)
        super.init(unsafelyWrapping: jsObject)
    }

    @ReadonlyAttribute
    public var features: GPUSupportedFeatures

    @ReadonlyAttribute
    public var limits: GPUSupportedLimits

    @ReadonlyAttribute
    public var queue: GPUQueue

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[.destroy].function!(this: this, arguments: [])
    }

    @inlinable public func createBuffer(descriptor: GPUBufferDescriptor) -> GPUBuffer {
        let this = jsObject
        return this[.createBuffer].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createTexture(descriptor: GPUTextureDescriptor) -> GPUTexture {
        let this = jsObject
        return this[.createTexture].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createSampler(descriptor: GPUSamplerDescriptor? = nil) -> GPUSampler {
        let this = jsObject
        return this[.createSampler].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func importExternalTexture(descriptor: GPUExternalTextureDescriptor) -> GPUExternalTexture {
        let this = jsObject
        return this[.importExternalTexture].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createBindGroupLayout(descriptor: GPUBindGroupLayoutDescriptor) -> GPUBindGroupLayout {
        let this = jsObject
        return this[.createBindGroupLayout].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createPipelineLayout(descriptor: GPUPipelineLayoutDescriptor) -> GPUPipelineLayout {
        let this = jsObject
        return this[.createPipelineLayout].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createBindGroup(descriptor: GPUBindGroupDescriptor) -> GPUBindGroup {
        let this = jsObject
        return this[.createBindGroup].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createShaderModule(descriptor: GPUShaderModuleDescriptor) -> GPUShaderModule {
        let this = jsObject
        return this[.createShaderModule].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createComputePipeline(descriptor: GPUComputePipelineDescriptor) -> GPUComputePipeline {
        let this = jsObject
        return this[.createComputePipeline].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createRenderPipeline(descriptor: GPURenderPipelineDescriptor) -> GPURenderPipeline {
        let this = jsObject
        return this[.createRenderPipeline].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createComputePipelineAsync(descriptor: GPUComputePipelineDescriptor) -> JSPromise {
        let this = jsObject
        return this[.createComputePipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func createComputePipelineAsync(descriptor: GPUComputePipelineDescriptor) async throws -> GPUComputePipeline {
        let this = jsObject
        let _promise: JSPromise = this[.createComputePipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func createRenderPipelineAsync(descriptor: GPURenderPipelineDescriptor) -> JSPromise {
        let this = jsObject
        return this[.createRenderPipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func createRenderPipelineAsync(descriptor: GPURenderPipelineDescriptor) async throws -> GPURenderPipeline {
        let this = jsObject
        let _promise: JSPromise = this[.createRenderPipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func createCommandEncoder(descriptor: GPUCommandEncoderDescriptor? = nil) -> GPUCommandEncoder {
        let this = jsObject
        return this[.createCommandEncoder].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createRenderBundleEncoder(descriptor: GPURenderBundleEncoderDescriptor) -> GPURenderBundleEncoder {
        let this = jsObject
        return this[.createRenderBundleEncoder].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createQuerySet(descriptor: GPUQuerySetDescriptor) -> GPUQuerySet {
        let this = jsObject
        return this[.createQuerySet].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @ReadonlyAttribute
    public var lost: JSPromise

    @inlinable public func pushErrorScope(filter: GPUErrorFilter) {
        let this = jsObject
        _ = this[.pushErrorScope].function!(this: this, arguments: [_toJSValue(filter)])
    }

    @inlinable public func popErrorScope() -> JSPromise {
        let this = jsObject
        return this[.popErrorScope].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func popErrorScope() async throws -> GPUError? {
        let this = jsObject
        let _promise: JSPromise = this[.popErrorScope].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()
    }

    @ClosureAttribute1Optional
    public var onuncapturederror: EventHandler
}

public class GPUDeviceDescriptor: BridgedDictionary {
    public convenience init(requiredFeatures: [GPUFeatureName], requiredLimits: [String: GPUSize64], defaultQueue: GPUQueueDescriptor) {
        let object = JSObject.global[.Object].function!.new()
        object[.requiredFeatures] = _toJSValue(requiredFeatures)
        object[.requiredLimits] = _toJSValue(requiredLimits)
        object[.defaultQueue] = _toJSValue(defaultQueue)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _requiredFeatures = ReadWriteAttribute(jsObject: object, name: .requiredFeatures)
        _requiredLimits = ReadWriteAttribute(jsObject: object, name: .requiredLimits)
        _defaultQueue = ReadWriteAttribute(jsObject: object, name: .defaultQueue)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var requiredFeatures: [GPUFeatureName]

    @ReadWriteAttribute
    public var requiredLimits: [String: GPUSize64]

    @ReadWriteAttribute
    public var defaultQueue: GPUQueueDescriptor
}

public class GPUDeviceLostInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUDeviceLostInfo].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _reason = ReadonlyAttribute(jsObject: jsObject, name: .reason)
        _message = ReadonlyAttribute(jsObject: jsObject, name: .message)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var reason: GPUDeviceLostReason

    @ReadonlyAttribute
    public var message: String
}

public enum GPUDeviceLostReason: JSString, JSValueCompatible {
    case unknown = "unknown"
    case destroyed = "destroyed"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUError: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUError].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _message = ReadonlyAttribute(jsObject: jsObject, name: .message)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var message: String
}

public enum GPUErrorFilter: JSString, JSValueCompatible {
    case validation = "validation"
    case outOfMemory = "out-of-memory"
    case `internal` = "internal"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUExtent3DDict: BridgedDictionary {
    public convenience init(width: GPUIntegerCoordinate, height: GPUIntegerCoordinate, depthOrArrayLayers: GPUIntegerCoordinate) {
        let object = JSObject.global[.Object].function!.new()
        object[.width] = _toJSValue(width)
        object[.height] = _toJSValue(height)
        object[.depthOrArrayLayers] = _toJSValue(depthOrArrayLayers)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _width = ReadWriteAttribute(jsObject: object, name: .width)
        _height = ReadWriteAttribute(jsObject: object, name: .height)
        _depthOrArrayLayers = ReadWriteAttribute(jsObject: object, name: .depthOrArrayLayers)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var width: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var height: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var depthOrArrayLayers: GPUIntegerCoordinate
}

public class GPUExternalTexture: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUExternalTexture].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUExternalTextureBindingLayout: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPUExternalTextureDescriptor: BridgedDictionary {
    public convenience init(source: HTMLVideoElement_or_VideoFrame, colorSpace: PredefinedColorSpace) {
        let object = JSObject.global[.Object].function!.new()
        object[.source] = _toJSValue(source)
        object[.colorSpace] = _toJSValue(colorSpace)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _source = ReadWriteAttribute(jsObject: object, name: .source)
        _colorSpace = ReadWriteAttribute(jsObject: object, name: .colorSpace)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var source: HTMLVideoElement_or_VideoFrame

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace
}

public enum GPUFeatureName: JSString, JSValueCompatible {
    case depthClipControl = "depth-clip-control"
    case depth32floatStencil8 = "depth32float-stencil8"
    case textureCompressionBc = "texture-compression-bc"
    case textureCompressionEtc2 = "texture-compression-etc2"
    case textureCompressionAstc = "texture-compression-astc"
    case timestampQuery = "timestamp-query"
    case indirectFirstInstance = "indirect-first-instance"
    case shaderF16 = "shader-f16"
    case rg11b10ufloatRenderable = "rg11b10ufloat-renderable"
    case bgra8unormStorage = "bgra8unorm-storage"
    case float32Filterable = "float32-filterable"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUFilterMode: JSString, JSValueCompatible {
    case nearest = "nearest"
    case linear = "linear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUFragmentState: BridgedDictionary {
    public convenience init(targets: [GPUColorTargetState?]) {
        let object = JSObject.global[.Object].function!.new()
        object[.targets] = _toJSValue(targets)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _targets = ReadWriteAttribute(jsObject: object, name: .targets)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var targets: [GPUColorTargetState?]
}

public enum GPUFrontFace: JSString, JSValueCompatible {
    case ccw = "ccw"
    case cw = "cw"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUImageCopyBuffer: BridgedDictionary {
    public convenience init(buffer: GPUBuffer) {
        let object = JSObject.global[.Object].function!.new()
        object[.buffer] = _toJSValue(buffer)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffer = ReadWriteAttribute(jsObject: object, name: .buffer)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffer: GPUBuffer
}

public class GPUImageCopyExternalImage: BridgedDictionary {
    public convenience init(source: GPUImageCopyExternalImageSource, origin: GPUOrigin2D, flipY: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.source] = _toJSValue(source)
        object[.origin] = _toJSValue(origin)
        object[.flipY] = _toJSValue(flipY)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _source = ReadWriteAttribute(jsObject: object, name: .source)
        _origin = ReadWriteAttribute(jsObject: object, name: .origin)
        _flipY = ReadWriteAttribute(jsObject: object, name: .flipY)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var source: GPUImageCopyExternalImageSource

    @ReadWriteAttribute
    public var origin: GPUOrigin2D

    @ReadWriteAttribute
    public var flipY: Bool
}

public class GPUImageCopyTexture: BridgedDictionary {
    public convenience init(texture: GPUTexture, mipLevel: GPUIntegerCoordinate, origin: GPUOrigin3D, aspect: GPUTextureAspect) {
        let object = JSObject.global[.Object].function!.new()
        object[.texture] = _toJSValue(texture)
        object[.mipLevel] = _toJSValue(mipLevel)
        object[.origin] = _toJSValue(origin)
        object[.aspect] = _toJSValue(aspect)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _texture = ReadWriteAttribute(jsObject: object, name: .texture)
        _mipLevel = ReadWriteAttribute(jsObject: object, name: .mipLevel)
        _origin = ReadWriteAttribute(jsObject: object, name: .origin)
        _aspect = ReadWriteAttribute(jsObject: object, name: .aspect)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var texture: GPUTexture

    @ReadWriteAttribute
    public var mipLevel: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var origin: GPUOrigin3D

    @ReadWriteAttribute
    public var aspect: GPUTextureAspect
}

public class GPUImageCopyTextureTagged: BridgedDictionary {
    public convenience init(colorSpace: PredefinedColorSpace, premultipliedAlpha: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.colorSpace] = _toJSValue(colorSpace)
        object[.premultipliedAlpha] = _toJSValue(premultipliedAlpha)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorSpace = ReadWriteAttribute(jsObject: object, name: .colorSpace)
        _premultipliedAlpha = ReadWriteAttribute(jsObject: object, name: .premultipliedAlpha)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorSpace: PredefinedColorSpace

    @ReadWriteAttribute
    public var premultipliedAlpha: Bool
}

public class GPUImageDataLayout: BridgedDictionary {
    public convenience init(offset: GPUSize64, bytesPerRow: GPUSize32, rowsPerImage: GPUSize32) {
        let object = JSObject.global[.Object].function!.new()
        object[.offset] = _toJSValue(offset)
        object[.bytesPerRow] = _toJSValue(bytesPerRow)
        object[.rowsPerImage] = _toJSValue(rowsPerImage)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: .offset)
        _bytesPerRow = ReadWriteAttribute(jsObject: object, name: .bytesPerRow)
        _rowsPerImage = ReadWriteAttribute(jsObject: object, name: .rowsPerImage)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: GPUSize64

    @ReadWriteAttribute
    public var bytesPerRow: GPUSize32

    @ReadWriteAttribute
    public var rowsPerImage: GPUSize32
}

public enum GPUIndexFormat: JSString, JSValueCompatible {
    case uint16 = "uint16"
    case uint32 = "uint32"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUInternalError: GPUError {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUInternalError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(message: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

public enum GPULoadOp: JSString, JSValueCompatible {
    case load = "load"
    case clear = "clear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUMapMode {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[.GPUMapMode].object!
    }

    public static let READ: GPUFlagsConstant = 0x0001

    public static let WRITE: GPUFlagsConstant = 0x0002
}

public enum GPUMipmapFilterMode: JSString, JSValueCompatible {
    case nearest = "nearest"
    case linear = "linear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUMultisampleState: BridgedDictionary {
    public convenience init(count: GPUSize32, mask: GPUSampleMask, alphaToCoverageEnabled: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.count] = _toJSValue(count)
        object[.mask] = _toJSValue(mask)
        object[.alphaToCoverageEnabled] = _toJSValue(alphaToCoverageEnabled)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _count = ReadWriteAttribute(jsObject: object, name: .count)
        _mask = ReadWriteAttribute(jsObject: object, name: .mask)
        _alphaToCoverageEnabled = ReadWriteAttribute(jsObject: object, name: .alphaToCoverageEnabled)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var count: GPUSize32

    @ReadWriteAttribute
    public var mask: GPUSampleMask

    @ReadWriteAttribute
    public var alphaToCoverageEnabled: Bool
}

public protocol GPUObjectBase: JSBridgedClass {}
public extension GPUObjectBase {
    @inlinable var label: String {
        get { jsObject[.label].fromJSValue()! }
        nonmutating set { jsObject[.label] = _toJSValue(newValue) }
    }
}

public class GPUObjectDescriptorBase: BridgedDictionary {
    public convenience init(label: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.label] = _toJSValue(label)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _label = ReadWriteAttribute(jsObject: object, name: .label)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var label: String
}

public class GPUOrigin2DDict: BridgedDictionary {
    public convenience init(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate) {
        let object = JSObject.global[.Object].function!.new()
        object[.x] = _toJSValue(x)
        object[.y] = _toJSValue(y)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _x = ReadWriteAttribute(jsObject: object, name: .x)
        _y = ReadWriteAttribute(jsObject: object, name: .y)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var x: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var y: GPUIntegerCoordinate
}

public class GPUOrigin3DDict: BridgedDictionary {
    public convenience init(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate, z: GPUIntegerCoordinate) {
        let object = JSObject.global[.Object].function!.new()
        object[.x] = _toJSValue(x)
        object[.y] = _toJSValue(y)
        object[.z] = _toJSValue(z)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _x = ReadWriteAttribute(jsObject: object, name: .x)
        _y = ReadWriteAttribute(jsObject: object, name: .y)
        _z = ReadWriteAttribute(jsObject: object, name: .z)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var x: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var y: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var z: GPUIntegerCoordinate
}

public class GPUOutOfMemoryError: GPUError {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUOutOfMemoryError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(message: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

public protocol GPUPipelineBase: JSBridgedClass {}
public extension GPUPipelineBase {
    @inlinable func getBindGroupLayout(index: UInt32) -> GPUBindGroupLayout {
        let this = jsObject
        return this[.getBindGroupLayout].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
}

public class GPUPipelineDescriptorBase: BridgedDictionary {
    public convenience init(layout: GPUAutoLayoutMode_or_GPUPipelineLayout) {
        let object = JSObject.global[.Object].function!.new()
        object[.layout] = _toJSValue(layout)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _layout = ReadWriteAttribute(jsObject: object, name: .layout)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var layout: GPUAutoLayoutMode_or_GPUPipelineLayout
}

public class GPUPipelineError: DOMException {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUPipelineError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _reason = ReadonlyAttribute(jsObject: jsObject, name: .reason)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(message: String? = nil, options: GPUPipelineErrorInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message), _toJSValue(options)]))
    }

    @ReadonlyAttribute
    public var reason: GPUPipelineErrorReason
}

public class GPUPipelineErrorInit: BridgedDictionary {
    public convenience init(reason: GPUPipelineErrorReason) {
        let object = JSObject.global[.Object].function!.new()
        object[.reason] = _toJSValue(reason)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _reason = ReadWriteAttribute(jsObject: object, name: .reason)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var reason: GPUPipelineErrorReason
}

public enum GPUPipelineErrorReason: JSString, JSValueCompatible {
    case validation = "validation"
    case `internal` = "internal"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUPipelineLayout: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUPipelineLayout].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUPipelineLayoutDescriptor: BridgedDictionary {
    public convenience init(bindGroupLayouts: [GPUBindGroupLayout]) {
        let object = JSObject.global[.Object].function!.new()
        object[.bindGroupLayouts] = _toJSValue(bindGroupLayouts)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _bindGroupLayouts = ReadWriteAttribute(jsObject: object, name: .bindGroupLayouts)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var bindGroupLayouts: [GPUBindGroupLayout]
}

public enum GPUPowerPreference: JSString, JSValueCompatible {
    case lowPower = "low-power"
    case highPerformance = "high-performance"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUPrimitiveState: BridgedDictionary {
    public convenience init(topology: GPUPrimitiveTopology, stripIndexFormat: GPUIndexFormat, frontFace: GPUFrontFace, cullMode: GPUCullMode, unclippedDepth: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.topology] = _toJSValue(topology)
        object[.stripIndexFormat] = _toJSValue(stripIndexFormat)
        object[.frontFace] = _toJSValue(frontFace)
        object[.cullMode] = _toJSValue(cullMode)
        object[.unclippedDepth] = _toJSValue(unclippedDepth)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _topology = ReadWriteAttribute(jsObject: object, name: .topology)
        _stripIndexFormat = ReadWriteAttribute(jsObject: object, name: .stripIndexFormat)
        _frontFace = ReadWriteAttribute(jsObject: object, name: .frontFace)
        _cullMode = ReadWriteAttribute(jsObject: object, name: .cullMode)
        _unclippedDepth = ReadWriteAttribute(jsObject: object, name: .unclippedDepth)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var topology: GPUPrimitiveTopology

    @ReadWriteAttribute
    public var stripIndexFormat: GPUIndexFormat

    @ReadWriteAttribute
    public var frontFace: GPUFrontFace

    @ReadWriteAttribute
    public var cullMode: GPUCullMode

    @ReadWriteAttribute
    public var unclippedDepth: Bool
}

public enum GPUPrimitiveTopology: JSString, JSValueCompatible {
    case pointList = "point-list"
    case lineList = "line-list"
    case lineStrip = "line-strip"
    case triangleList = "triangle-list"
    case triangleStrip = "triangle-strip"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUProgrammableStage: BridgedDictionary {
    public convenience init(module: GPUShaderModule, entryPoint: String, constants: [String: GPUPipelineConstantValue]) {
        let object = JSObject.global[.Object].function!.new()
        object[.module] = _toJSValue(module)
        object[.entryPoint] = _toJSValue(entryPoint)
        object[.constants] = _toJSValue(constants)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _module = ReadWriteAttribute(jsObject: object, name: .module)
        _entryPoint = ReadWriteAttribute(jsObject: object, name: .entryPoint)
        _constants = ReadWriteAttribute(jsObject: object, name: .constants)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var module: GPUShaderModule

    @ReadWriteAttribute
    public var entryPoint: String

    @ReadWriteAttribute
    public var constants: [String: GPUPipelineConstantValue]
}

public class GPUQuerySet: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUQuerySet].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _type = ReadonlyAttribute(jsObject: jsObject, name: .type)
        _count = ReadonlyAttribute(jsObject: jsObject, name: .count)
        self.jsObject = jsObject
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[.destroy].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var type: GPUQueryType

    @ReadonlyAttribute
    public var count: GPUSize32Out
}

public class GPUQuerySetDescriptor: BridgedDictionary {
    public convenience init(type: GPUQueryType, count: GPUSize32) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.count] = _toJSValue(count)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        _count = ReadWriteAttribute(jsObject: object, name: .count)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: GPUQueryType

    @ReadWriteAttribute
    public var count: GPUSize32
}

public enum GPUQueryType: JSString, JSValueCompatible {
    case occlusion = "occlusion"
    case timestamp = "timestamp"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUQueue: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUQueue].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func submit(commandBuffers: [GPUCommandBuffer]) {
        let this = jsObject
        _ = this[.submit].function!(this: this, arguments: [_toJSValue(commandBuffers)])
    }

    @inlinable public func onSubmittedWorkDone() -> JSPromise {
        let this = jsObject
        return this[.onSubmittedWorkDone].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func onSubmittedWorkDone() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.onSubmittedWorkDone].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func writeBuffer(buffer: GPUBuffer, bufferOffset: GPUSize64, data: AllowSharedBufferSource, dataOffset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[.writeBuffer].function!(this: this, arguments: [_toJSValue(buffer), _toJSValue(bufferOffset), _toJSValue(data), _toJSValue(dataOffset), _toJSValue(size)])
    }

    @inlinable public func writeTexture(destination: GPUImageCopyTexture, data: AllowSharedBufferSource, dataLayout: GPUImageDataLayout, size: GPUExtent3D) {
        let this = jsObject
        _ = this[.writeTexture].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(data), _toJSValue(dataLayout), _toJSValue(size)])
    }

    @inlinable public func copyExternalImageToTexture(source: GPUImageCopyExternalImage, destination: GPUImageCopyTextureTagged, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[.copyExternalImageToTexture].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }
}

public class GPUQueueDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPURenderBundle: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPURenderBundle].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPURenderBundleDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPURenderBundleEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUBindingCommandsMixin, GPURenderCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPURenderBundleEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func finish(descriptor: GPURenderBundleDescriptor? = nil) -> GPURenderBundle {
        let this = jsObject
        return this[.finish].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }
}

public class GPURenderBundleEncoderDescriptor: BridgedDictionary {
    public convenience init(depthReadOnly: Bool, stencilReadOnly: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.depthReadOnly] = _toJSValue(depthReadOnly)
        object[.stencilReadOnly] = _toJSValue(stencilReadOnly)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _depthReadOnly = ReadWriteAttribute(jsObject: object, name: .depthReadOnly)
        _stencilReadOnly = ReadWriteAttribute(jsObject: object, name: .stencilReadOnly)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var depthReadOnly: Bool

    @ReadWriteAttribute
    public var stencilReadOnly: Bool
}

public protocol GPURenderCommandsMixin: JSBridgedClass {}
public extension GPURenderCommandsMixin {
    @inlinable func setPipeline(pipeline: GPURenderPipeline) {
        let this = jsObject
        _ = this[.setPipeline].function!(this: this, arguments: [_toJSValue(pipeline)])
    }

    @inlinable func setIndexBuffer(buffer: GPUBuffer, indexFormat: GPUIndexFormat, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[.setIndexBuffer].function!(this: this, arguments: [_toJSValue(buffer), _toJSValue(indexFormat), _toJSValue(offset), _toJSValue(size)])
    }

    @inlinable func setVertexBuffer(slot: GPUIndex32, buffer: GPUBuffer?, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[.setVertexBuffer].function!(this: this, arguments: [_toJSValue(slot), _toJSValue(buffer), _toJSValue(offset), _toJSValue(size)])
    }

    @inlinable func draw(vertexCount: GPUSize32, instanceCount: GPUSize32? = nil, firstVertex: GPUSize32? = nil, firstInstance: GPUSize32? = nil) {
        let this = jsObject
        _ = this[.draw].function!(this: this, arguments: [_toJSValue(vertexCount), _toJSValue(instanceCount), _toJSValue(firstVertex), _toJSValue(firstInstance)])
    }

    @inlinable func drawIndexed(indexCount: GPUSize32, instanceCount: GPUSize32? = nil, firstIndex: GPUSize32? = nil, baseVertex: GPUSignedOffset32? = nil, firstInstance: GPUSize32? = nil) {
        let this = jsObject
        _ = this[.drawIndexed].function!(this: this, arguments: [_toJSValue(indexCount), _toJSValue(instanceCount), _toJSValue(firstIndex), _toJSValue(baseVertex), _toJSValue(firstInstance)])
    }

    @inlinable func drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[.drawIndirect].function!(this: this, arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)])
    }

    @inlinable func drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[.drawIndexedIndirect].function!(this: this, arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)])
    }
}

public class GPURenderPassColorAttachment: BridgedDictionary {
    public convenience init(view: GPUTextureView, resolveTarget: GPUTextureView, clearValue: GPUColor, loadOp: GPULoadOp, storeOp: GPUStoreOp) {
        let object = JSObject.global[.Object].function!.new()
        object[.view] = _toJSValue(view)
        object[.resolveTarget] = _toJSValue(resolveTarget)
        object[.clearValue] = _toJSValue(clearValue)
        object[.loadOp] = _toJSValue(loadOp)
        object[.storeOp] = _toJSValue(storeOp)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _view = ReadWriteAttribute(jsObject: object, name: .view)
        _resolveTarget = ReadWriteAttribute(jsObject: object, name: .resolveTarget)
        _clearValue = ReadWriteAttribute(jsObject: object, name: .clearValue)
        _loadOp = ReadWriteAttribute(jsObject: object, name: .loadOp)
        _storeOp = ReadWriteAttribute(jsObject: object, name: .storeOp)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var view: GPUTextureView

    @ReadWriteAttribute
    public var resolveTarget: GPUTextureView

    @ReadWriteAttribute
    public var clearValue: GPUColor

    @ReadWriteAttribute
    public var loadOp: GPULoadOp

    @ReadWriteAttribute
    public var storeOp: GPUStoreOp
}

public class GPURenderPassDepthStencilAttachment: BridgedDictionary {
    public convenience init(view: GPUTextureView, depthClearValue: Float, depthLoadOp: GPULoadOp, depthStoreOp: GPUStoreOp, depthReadOnly: Bool, stencilClearValue: GPUStencilValue, stencilLoadOp: GPULoadOp, stencilStoreOp: GPUStoreOp, stencilReadOnly: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.view] = _toJSValue(view)
        object[.depthClearValue] = _toJSValue(depthClearValue)
        object[.depthLoadOp] = _toJSValue(depthLoadOp)
        object[.depthStoreOp] = _toJSValue(depthStoreOp)
        object[.depthReadOnly] = _toJSValue(depthReadOnly)
        object[.stencilClearValue] = _toJSValue(stencilClearValue)
        object[.stencilLoadOp] = _toJSValue(stencilLoadOp)
        object[.stencilStoreOp] = _toJSValue(stencilStoreOp)
        object[.stencilReadOnly] = _toJSValue(stencilReadOnly)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _view = ReadWriteAttribute(jsObject: object, name: .view)
        _depthClearValue = ReadWriteAttribute(jsObject: object, name: .depthClearValue)
        _depthLoadOp = ReadWriteAttribute(jsObject: object, name: .depthLoadOp)
        _depthStoreOp = ReadWriteAttribute(jsObject: object, name: .depthStoreOp)
        _depthReadOnly = ReadWriteAttribute(jsObject: object, name: .depthReadOnly)
        _stencilClearValue = ReadWriteAttribute(jsObject: object, name: .stencilClearValue)
        _stencilLoadOp = ReadWriteAttribute(jsObject: object, name: .stencilLoadOp)
        _stencilStoreOp = ReadWriteAttribute(jsObject: object, name: .stencilStoreOp)
        _stencilReadOnly = ReadWriteAttribute(jsObject: object, name: .stencilReadOnly)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var view: GPUTextureView

    @ReadWriteAttribute
    public var depthClearValue: Float

    @ReadWriteAttribute
    public var depthLoadOp: GPULoadOp

    @ReadWriteAttribute
    public var depthStoreOp: GPUStoreOp

    @ReadWriteAttribute
    public var depthReadOnly: Bool

    @ReadWriteAttribute
    public var stencilClearValue: GPUStencilValue

    @ReadWriteAttribute
    public var stencilLoadOp: GPULoadOp

    @ReadWriteAttribute
    public var stencilStoreOp: GPUStoreOp

    @ReadWriteAttribute
    public var stencilReadOnly: Bool
}

public class GPURenderPassDescriptor: BridgedDictionary {
    public convenience init(colorAttachments: [GPURenderPassColorAttachment?], depthStencilAttachment: GPURenderPassDepthStencilAttachment, occlusionQuerySet: GPUQuerySet, timestampWrites: GPURenderPassTimestampWrites, maxDrawCount: GPUSize64) {
        let object = JSObject.global[.Object].function!.new()
        object[.colorAttachments] = _toJSValue(colorAttachments)
        object[.depthStencilAttachment] = _toJSValue(depthStencilAttachment)
        object[.occlusionQuerySet] = _toJSValue(occlusionQuerySet)
        object[.timestampWrites] = _toJSValue(timestampWrites)
        object[.maxDrawCount] = _toJSValue(maxDrawCount)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorAttachments = ReadWriteAttribute(jsObject: object, name: .colorAttachments)
        _depthStencilAttachment = ReadWriteAttribute(jsObject: object, name: .depthStencilAttachment)
        _occlusionQuerySet = ReadWriteAttribute(jsObject: object, name: .occlusionQuerySet)
        _timestampWrites = ReadWriteAttribute(jsObject: object, name: .timestampWrites)
        _maxDrawCount = ReadWriteAttribute(jsObject: object, name: .maxDrawCount)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorAttachments: [GPURenderPassColorAttachment?]

    @ReadWriteAttribute
    public var depthStencilAttachment: GPURenderPassDepthStencilAttachment

    @ReadWriteAttribute
    public var occlusionQuerySet: GPUQuerySet

    @ReadWriteAttribute
    public var timestampWrites: GPURenderPassTimestampWrites

    @ReadWriteAttribute
    public var maxDrawCount: GPUSize64
}

public class GPURenderPassEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUBindingCommandsMixin, GPURenderCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPURenderPassEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func setViewport(x: Float, y: Float, width: Float, height: Float, minDepth: Float, maxDepth: Float) {
        let this = jsObject
        _ = this[.setViewport].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height), _toJSValue(minDepth), _toJSValue(maxDepth)])
    }

    @inlinable public func setScissorRect(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate, width: GPUIntegerCoordinate, height: GPUIntegerCoordinate) {
        let this = jsObject
        _ = this[.setScissorRect].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height)])
    }

    @inlinable public func setBlendConstant(color: GPUColor) {
        let this = jsObject
        _ = this[.setBlendConstant].function!(this: this, arguments: [_toJSValue(color)])
    }

    @inlinable public func setStencilReference(reference: GPUStencilValue) {
        let this = jsObject
        _ = this[.setStencilReference].function!(this: this, arguments: [_toJSValue(reference)])
    }

    @inlinable public func beginOcclusionQuery(queryIndex: GPUSize32) {
        let this = jsObject
        _ = this[.beginOcclusionQuery].function!(this: this, arguments: [_toJSValue(queryIndex)])
    }

    @inlinable public func endOcclusionQuery() {
        let this = jsObject
        _ = this[.endOcclusionQuery].function!(this: this, arguments: [])
    }

    @inlinable public func executeBundles(bundles: [GPURenderBundle]) {
        let this = jsObject
        _ = this[.executeBundles].function!(this: this, arguments: [_toJSValue(bundles)])
    }

    @inlinable public func end() {
        let this = jsObject
        _ = this[.end].function!(this: this, arguments: [])
    }
}

public class GPURenderPassLayout: BridgedDictionary {
    public convenience init(colorFormats: [GPUTextureFormat?], depthStencilFormat: GPUTextureFormat, sampleCount: GPUSize32) {
        let object = JSObject.global[.Object].function!.new()
        object[.colorFormats] = _toJSValue(colorFormats)
        object[.depthStencilFormat] = _toJSValue(depthStencilFormat)
        object[.sampleCount] = _toJSValue(sampleCount)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _colorFormats = ReadWriteAttribute(jsObject: object, name: .colorFormats)
        _depthStencilFormat = ReadWriteAttribute(jsObject: object, name: .depthStencilFormat)
        _sampleCount = ReadWriteAttribute(jsObject: object, name: .sampleCount)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var colorFormats: [GPUTextureFormat?]

    @ReadWriteAttribute
    public var depthStencilFormat: GPUTextureFormat

    @ReadWriteAttribute
    public var sampleCount: GPUSize32
}

public class GPURenderPassTimestampWrites: BridgedDictionary {
    public convenience init(querySet: GPUQuerySet, beginningOfPassWriteIndex: GPUSize32, endOfPassWriteIndex: GPUSize32) {
        let object = JSObject.global[.Object].function!.new()
        object[.querySet] = _toJSValue(querySet)
        object[.beginningOfPassWriteIndex] = _toJSValue(beginningOfPassWriteIndex)
        object[.endOfPassWriteIndex] = _toJSValue(endOfPassWriteIndex)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _querySet = ReadWriteAttribute(jsObject: object, name: .querySet)
        _beginningOfPassWriteIndex = ReadWriteAttribute(jsObject: object, name: .beginningOfPassWriteIndex)
        _endOfPassWriteIndex = ReadWriteAttribute(jsObject: object, name: .endOfPassWriteIndex)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var querySet: GPUQuerySet

    @ReadWriteAttribute
    public var beginningOfPassWriteIndex: GPUSize32

    @ReadWriteAttribute
    public var endOfPassWriteIndex: GPUSize32
}

public class GPURenderPipeline: JSBridgedClass, GPUObjectBase, GPUPipelineBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPURenderPipeline].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPURenderPipelineDescriptor: BridgedDictionary {
    public convenience init(vertex: GPUVertexState, primitive: GPUPrimitiveState, depthStencil: GPUDepthStencilState, multisample: GPUMultisampleState, fragment: GPUFragmentState) {
        let object = JSObject.global[.Object].function!.new()
        object[.vertex] = _toJSValue(vertex)
        object[.primitive] = _toJSValue(primitive)
        object[.depthStencil] = _toJSValue(depthStencil)
        object[.multisample] = _toJSValue(multisample)
        object[.fragment] = _toJSValue(fragment)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _vertex = ReadWriteAttribute(jsObject: object, name: .vertex)
        _primitive = ReadWriteAttribute(jsObject: object, name: .primitive)
        _depthStencil = ReadWriteAttribute(jsObject: object, name: .depthStencil)
        _multisample = ReadWriteAttribute(jsObject: object, name: .multisample)
        _fragment = ReadWriteAttribute(jsObject: object, name: .fragment)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var vertex: GPUVertexState

    @ReadWriteAttribute
    public var primitive: GPUPrimitiveState

    @ReadWriteAttribute
    public var depthStencil: GPUDepthStencilState

    @ReadWriteAttribute
    public var multisample: GPUMultisampleState

    @ReadWriteAttribute
    public var fragment: GPUFragmentState
}

public class GPURequestAdapterOptions: BridgedDictionary {
    public convenience init(powerPreference: GPUPowerPreference, forceFallbackAdapter: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.powerPreference] = _toJSValue(powerPreference)
        object[.forceFallbackAdapter] = _toJSValue(forceFallbackAdapter)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _powerPreference = ReadWriteAttribute(jsObject: object, name: .powerPreference)
        _forceFallbackAdapter = ReadWriteAttribute(jsObject: object, name: .forceFallbackAdapter)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var powerPreference: GPUPowerPreference

    @ReadWriteAttribute
    public var forceFallbackAdapter: Bool
}

public class GPUSampler: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUSampler].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUSamplerBindingLayout: BridgedDictionary {
    public convenience init(type: GPUSamplerBindingType) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _type = ReadWriteAttribute(jsObject: object, name: .type)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var type: GPUSamplerBindingType
}

public enum GPUSamplerBindingType: JSString, JSValueCompatible {
    case filtering = "filtering"
    case nonFiltering = "non-filtering"
    case comparison = "comparison"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUSamplerDescriptor: BridgedDictionary {
    public convenience init(addressModeU: GPUAddressMode, addressModeV: GPUAddressMode, addressModeW: GPUAddressMode, magFilter: GPUFilterMode, minFilter: GPUFilterMode, mipmapFilter: GPUMipmapFilterMode, lodMinClamp: Float, lodMaxClamp: Float, compare: GPUCompareFunction, maxAnisotropy: UInt16) {
        let object = JSObject.global[.Object].function!.new()
        object[.addressModeU] = _toJSValue(addressModeU)
        object[.addressModeV] = _toJSValue(addressModeV)
        object[.addressModeW] = _toJSValue(addressModeW)
        object[.magFilter] = _toJSValue(magFilter)
        object[.minFilter] = _toJSValue(minFilter)
        object[.mipmapFilter] = _toJSValue(mipmapFilter)
        object[.lodMinClamp] = _toJSValue(lodMinClamp)
        object[.lodMaxClamp] = _toJSValue(lodMaxClamp)
        object[.compare] = _toJSValue(compare)
        object[.maxAnisotropy] = _toJSValue(maxAnisotropy)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _addressModeU = ReadWriteAttribute(jsObject: object, name: .addressModeU)
        _addressModeV = ReadWriteAttribute(jsObject: object, name: .addressModeV)
        _addressModeW = ReadWriteAttribute(jsObject: object, name: .addressModeW)
        _magFilter = ReadWriteAttribute(jsObject: object, name: .magFilter)
        _minFilter = ReadWriteAttribute(jsObject: object, name: .minFilter)
        _mipmapFilter = ReadWriteAttribute(jsObject: object, name: .mipmapFilter)
        _lodMinClamp = ReadWriteAttribute(jsObject: object, name: .lodMinClamp)
        _lodMaxClamp = ReadWriteAttribute(jsObject: object, name: .lodMaxClamp)
        _compare = ReadWriteAttribute(jsObject: object, name: .compare)
        _maxAnisotropy = ReadWriteAttribute(jsObject: object, name: .maxAnisotropy)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var addressModeU: GPUAddressMode

    @ReadWriteAttribute
    public var addressModeV: GPUAddressMode

    @ReadWriteAttribute
    public var addressModeW: GPUAddressMode

    @ReadWriteAttribute
    public var magFilter: GPUFilterMode

    @ReadWriteAttribute
    public var minFilter: GPUFilterMode

    @ReadWriteAttribute
    public var mipmapFilter: GPUMipmapFilterMode

    @ReadWriteAttribute
    public var lodMinClamp: Float

    @ReadWriteAttribute
    public var lodMaxClamp: Float

    @ReadWriteAttribute
    public var compare: GPUCompareFunction

    @ReadWriteAttribute
    public var maxAnisotropy: UInt16
}

public class GPUShaderModule: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUShaderModule].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func getCompilationInfo() -> JSPromise {
        let this = jsObject
        return this[.getCompilationInfo].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getCompilationInfo() async throws -> GPUCompilationInfo {
        let this = jsObject
        let _promise: JSPromise = this[.getCompilationInfo].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class GPUShaderModuleCompilationHint: BridgedDictionary {
    public convenience init(layout: GPUAutoLayoutMode_or_GPUPipelineLayout) {
        let object = JSObject.global[.Object].function!.new()
        object[.layout] = _toJSValue(layout)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _layout = ReadWriteAttribute(jsObject: object, name: .layout)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var layout: GPUAutoLayoutMode_or_GPUPipelineLayout
}

public class GPUShaderModuleDescriptor: BridgedDictionary {
    public convenience init(code: String, sourceMap: JSObject, hints: [String: GPUShaderModuleCompilationHint]) {
        let object = JSObject.global[.Object].function!.new()
        object[.code] = _toJSValue(code)
        object[.sourceMap] = _toJSValue(sourceMap)
        object[.hints] = _toJSValue(hints)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _code = ReadWriteAttribute(jsObject: object, name: .code)
        _sourceMap = ReadWriteAttribute(jsObject: object, name: .sourceMap)
        _hints = ReadWriteAttribute(jsObject: object, name: .hints)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var code: String

    @ReadWriteAttribute
    public var sourceMap: JSObject

    @ReadWriteAttribute
    public var hints: [String: GPUShaderModuleCompilationHint]
}

public enum GPUShaderStage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[.GPUShaderStage].object!
    }

    public static let VERTEX: GPUFlagsConstant = 0x1

    public static let FRAGMENT: GPUFlagsConstant = 0x2

    public static let COMPUTE: GPUFlagsConstant = 0x4
}

public class GPUStencilFaceState: BridgedDictionary {
    public convenience init(compare: GPUCompareFunction, failOp: GPUStencilOperation, depthFailOp: GPUStencilOperation, passOp: GPUStencilOperation) {
        let object = JSObject.global[.Object].function!.new()
        object[.compare] = _toJSValue(compare)
        object[.failOp] = _toJSValue(failOp)
        object[.depthFailOp] = _toJSValue(depthFailOp)
        object[.passOp] = _toJSValue(passOp)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _compare = ReadWriteAttribute(jsObject: object, name: .compare)
        _failOp = ReadWriteAttribute(jsObject: object, name: .failOp)
        _depthFailOp = ReadWriteAttribute(jsObject: object, name: .depthFailOp)
        _passOp = ReadWriteAttribute(jsObject: object, name: .passOp)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var compare: GPUCompareFunction

    @ReadWriteAttribute
    public var failOp: GPUStencilOperation

    @ReadWriteAttribute
    public var depthFailOp: GPUStencilOperation

    @ReadWriteAttribute
    public var passOp: GPUStencilOperation
}

public enum GPUStencilOperation: JSString, JSValueCompatible {
    case keep = "keep"
    case zero = "zero"
    case replace = "replace"
    case invert = "invert"
    case incrementClamp = "increment-clamp"
    case decrementClamp = "decrement-clamp"
    case incrementWrap = "increment-wrap"
    case decrementWrap = "decrement-wrap"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUStorageTextureAccess: JSString, JSValueCompatible {
    case writeOnly = "write-only"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUStorageTextureBindingLayout: BridgedDictionary {
    public convenience init(access: GPUStorageTextureAccess, format: GPUTextureFormat, viewDimension: GPUTextureViewDimension) {
        let object = JSObject.global[.Object].function!.new()
        object[.access] = _toJSValue(access)
        object[.format] = _toJSValue(format)
        object[.viewDimension] = _toJSValue(viewDimension)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _access = ReadWriteAttribute(jsObject: object, name: .access)
        _format = ReadWriteAttribute(jsObject: object, name: .format)
        _viewDimension = ReadWriteAttribute(jsObject: object, name: .viewDimension)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var access: GPUStorageTextureAccess

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var viewDimension: GPUTextureViewDimension
}

public enum GPUStoreOp: JSString, JSValueCompatible {
    case store = "store"
    case discard = "discard"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUSupportedFeatures: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUSupportedFeatures].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    // XXX: make me Set-like!
}

public class GPUSupportedLimits: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUSupportedLimits].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _maxTextureDimension1D = ReadonlyAttribute(jsObject: jsObject, name: .maxTextureDimension1D)
        _maxTextureDimension2D = ReadonlyAttribute(jsObject: jsObject, name: .maxTextureDimension2D)
        _maxTextureDimension3D = ReadonlyAttribute(jsObject: jsObject, name: .maxTextureDimension3D)
        _maxTextureArrayLayers = ReadonlyAttribute(jsObject: jsObject, name: .maxTextureArrayLayers)
        _maxBindGroups = ReadonlyAttribute(jsObject: jsObject, name: .maxBindGroups)
        _maxBindGroupsPlusVertexBuffers = ReadonlyAttribute(jsObject: jsObject, name: .maxBindGroupsPlusVertexBuffers)
        _maxBindingsPerBindGroup = ReadonlyAttribute(jsObject: jsObject, name: .maxBindingsPerBindGroup)
        _maxDynamicUniformBuffersPerPipelineLayout = ReadonlyAttribute(jsObject: jsObject, name: .maxDynamicUniformBuffersPerPipelineLayout)
        _maxDynamicStorageBuffersPerPipelineLayout = ReadonlyAttribute(jsObject: jsObject, name: .maxDynamicStorageBuffersPerPipelineLayout)
        _maxSampledTexturesPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: .maxSampledTexturesPerShaderStage)
        _maxSamplersPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: .maxSamplersPerShaderStage)
        _maxStorageBuffersPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: .maxStorageBuffersPerShaderStage)
        _maxStorageTexturesPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: .maxStorageTexturesPerShaderStage)
        _maxUniformBuffersPerShaderStage = ReadonlyAttribute(jsObject: jsObject, name: .maxUniformBuffersPerShaderStage)
        _maxUniformBufferBindingSize = ReadonlyAttribute(jsObject: jsObject, name: .maxUniformBufferBindingSize)
        _maxStorageBufferBindingSize = ReadonlyAttribute(jsObject: jsObject, name: .maxStorageBufferBindingSize)
        _minUniformBufferOffsetAlignment = ReadonlyAttribute(jsObject: jsObject, name: .minUniformBufferOffsetAlignment)
        _minStorageBufferOffsetAlignment = ReadonlyAttribute(jsObject: jsObject, name: .minStorageBufferOffsetAlignment)
        _maxVertexBuffers = ReadonlyAttribute(jsObject: jsObject, name: .maxVertexBuffers)
        _maxBufferSize = ReadonlyAttribute(jsObject: jsObject, name: .maxBufferSize)
        _maxVertexAttributes = ReadonlyAttribute(jsObject: jsObject, name: .maxVertexAttributes)
        _maxVertexBufferArrayStride = ReadonlyAttribute(jsObject: jsObject, name: .maxVertexBufferArrayStride)
        _maxInterStageShaderComponents = ReadonlyAttribute(jsObject: jsObject, name: .maxInterStageShaderComponents)
        _maxInterStageShaderVariables = ReadonlyAttribute(jsObject: jsObject, name: .maxInterStageShaderVariables)
        _maxColorAttachments = ReadonlyAttribute(jsObject: jsObject, name: .maxColorAttachments)
        _maxColorAttachmentBytesPerSample = ReadonlyAttribute(jsObject: jsObject, name: .maxColorAttachmentBytesPerSample)
        _maxComputeWorkgroupStorageSize = ReadonlyAttribute(jsObject: jsObject, name: .maxComputeWorkgroupStorageSize)
        _maxComputeInvocationsPerWorkgroup = ReadonlyAttribute(jsObject: jsObject, name: .maxComputeInvocationsPerWorkgroup)
        _maxComputeWorkgroupSizeX = ReadonlyAttribute(jsObject: jsObject, name: .maxComputeWorkgroupSizeX)
        _maxComputeWorkgroupSizeY = ReadonlyAttribute(jsObject: jsObject, name: .maxComputeWorkgroupSizeY)
        _maxComputeWorkgroupSizeZ = ReadonlyAttribute(jsObject: jsObject, name: .maxComputeWorkgroupSizeZ)
        _maxComputeWorkgroupsPerDimension = ReadonlyAttribute(jsObject: jsObject, name: .maxComputeWorkgroupsPerDimension)
        self.jsObject = jsObject
    }

    @ReadonlyAttribute
    public var maxTextureDimension1D: UInt32

    @ReadonlyAttribute
    public var maxTextureDimension2D: UInt32

    @ReadonlyAttribute
    public var maxTextureDimension3D: UInt32

    @ReadonlyAttribute
    public var maxTextureArrayLayers: UInt32

    @ReadonlyAttribute
    public var maxBindGroups: UInt32

    @ReadonlyAttribute
    public var maxBindGroupsPlusVertexBuffers: UInt32

    @ReadonlyAttribute
    public var maxBindingsPerBindGroup: UInt32

    @ReadonlyAttribute
    public var maxDynamicUniformBuffersPerPipelineLayout: UInt32

    @ReadonlyAttribute
    public var maxDynamicStorageBuffersPerPipelineLayout: UInt32

    @ReadonlyAttribute
    public var maxSampledTexturesPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxSamplersPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxStorageBuffersPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxStorageTexturesPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxUniformBuffersPerShaderStage: UInt32

    @ReadonlyAttribute
    public var maxUniformBufferBindingSize: UInt64

    @ReadonlyAttribute
    public var maxStorageBufferBindingSize: UInt64

    @ReadonlyAttribute
    public var minUniformBufferOffsetAlignment: UInt32

    @ReadonlyAttribute
    public var minStorageBufferOffsetAlignment: UInt32

    @ReadonlyAttribute
    public var maxVertexBuffers: UInt32

    @ReadonlyAttribute
    public var maxBufferSize: UInt64

    @ReadonlyAttribute
    public var maxVertexAttributes: UInt32

    @ReadonlyAttribute
    public var maxVertexBufferArrayStride: UInt32

    @ReadonlyAttribute
    public var maxInterStageShaderComponents: UInt32

    @ReadonlyAttribute
    public var maxInterStageShaderVariables: UInt32

    @ReadonlyAttribute
    public var maxColorAttachments: UInt32

    @ReadonlyAttribute
    public var maxColorAttachmentBytesPerSample: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupStorageSize: UInt32

    @ReadonlyAttribute
    public var maxComputeInvocationsPerWorkgroup: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupSizeX: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupSizeY: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupSizeZ: UInt32

    @ReadonlyAttribute
    public var maxComputeWorkgroupsPerDimension: UInt32
}

public class GPUTexture: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUTexture].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        _width = ReadonlyAttribute(jsObject: jsObject, name: .width)
        _height = ReadonlyAttribute(jsObject: jsObject, name: .height)
        _depthOrArrayLayers = ReadonlyAttribute(jsObject: jsObject, name: .depthOrArrayLayers)
        _mipLevelCount = ReadonlyAttribute(jsObject: jsObject, name: .mipLevelCount)
        _sampleCount = ReadonlyAttribute(jsObject: jsObject, name: .sampleCount)
        _dimension = ReadonlyAttribute(jsObject: jsObject, name: .dimension)
        _format = ReadonlyAttribute(jsObject: jsObject, name: .format)
        _usage = ReadonlyAttribute(jsObject: jsObject, name: .usage)
        self.jsObject = jsObject
    }

    @inlinable public func createView(descriptor: GPUTextureViewDescriptor? = nil) -> GPUTextureView {
        let this = jsObject
        return this[.createView].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[.destroy].function!(this: this, arguments: [])
    }

    @ReadonlyAttribute
    public var width: GPUIntegerCoordinateOut

    @ReadonlyAttribute
    public var height: GPUIntegerCoordinateOut

    @ReadonlyAttribute
    public var depthOrArrayLayers: GPUIntegerCoordinateOut

    @ReadonlyAttribute
    public var mipLevelCount: GPUIntegerCoordinateOut

    @ReadonlyAttribute
    public var sampleCount: GPUSize32Out

    @ReadonlyAttribute
    public var dimension: GPUTextureDimension

    @ReadonlyAttribute
    public var format: GPUTextureFormat

    @ReadonlyAttribute
    public var usage: GPUFlagsConstant
}

public enum GPUTextureAspect: JSString, JSValueCompatible {
    case all = "all"
    case stencilOnly = "stencil-only"
    case depthOnly = "depth-only"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUTextureBindingLayout: BridgedDictionary {
    public convenience init(sampleType: GPUTextureSampleType, viewDimension: GPUTextureViewDimension, multisampled: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.sampleType] = _toJSValue(sampleType)
        object[.viewDimension] = _toJSValue(viewDimension)
        object[.multisampled] = _toJSValue(multisampled)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _sampleType = ReadWriteAttribute(jsObject: object, name: .sampleType)
        _viewDimension = ReadWriteAttribute(jsObject: object, name: .viewDimension)
        _multisampled = ReadWriteAttribute(jsObject: object, name: .multisampled)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var sampleType: GPUTextureSampleType

    @ReadWriteAttribute
    public var viewDimension: GPUTextureViewDimension

    @ReadWriteAttribute
    public var multisampled: Bool
}

public class GPUTextureDescriptor: BridgedDictionary {
    public convenience init(size: GPUExtent3D, mipLevelCount: GPUIntegerCoordinate, sampleCount: GPUSize32, dimension: GPUTextureDimension, format: GPUTextureFormat, usage: GPUTextureUsageFlags, viewFormats: [GPUTextureFormat]) {
        let object = JSObject.global[.Object].function!.new()
        object[.size] = _toJSValue(size)
        object[.mipLevelCount] = _toJSValue(mipLevelCount)
        object[.sampleCount] = _toJSValue(sampleCount)
        object[.dimension] = _toJSValue(dimension)
        object[.format] = _toJSValue(format)
        object[.usage] = _toJSValue(usage)
        object[.viewFormats] = _toJSValue(viewFormats)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _size = ReadWriteAttribute(jsObject: object, name: .size)
        _mipLevelCount = ReadWriteAttribute(jsObject: object, name: .mipLevelCount)
        _sampleCount = ReadWriteAttribute(jsObject: object, name: .sampleCount)
        _dimension = ReadWriteAttribute(jsObject: object, name: .dimension)
        _format = ReadWriteAttribute(jsObject: object, name: .format)
        _usage = ReadWriteAttribute(jsObject: object, name: .usage)
        _viewFormats = ReadWriteAttribute(jsObject: object, name: .viewFormats)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var size: GPUExtent3D

    @ReadWriteAttribute
    public var mipLevelCount: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var sampleCount: GPUSize32

    @ReadWriteAttribute
    public var dimension: GPUTextureDimension

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var usage: GPUTextureUsageFlags

    @ReadWriteAttribute
    public var viewFormats: [GPUTextureFormat]
}

public enum GPUTextureDimension: JSString, JSValueCompatible {
    case _1d = "1d"
    case _2d = "2d"
    case _3d = "3d"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureFormat: JSString, JSValueCompatible {
    case r8unorm = "r8unorm"
    case r8snorm = "r8snorm"
    case r8uint = "r8uint"
    case r8sint = "r8sint"
    case r16uint = "r16uint"
    case r16sint = "r16sint"
    case r16float = "r16float"
    case rg8unorm = "rg8unorm"
    case rg8snorm = "rg8snorm"
    case rg8uint = "rg8uint"
    case rg8sint = "rg8sint"
    case r32uint = "r32uint"
    case r32sint = "r32sint"
    case r32float = "r32float"
    case rg16uint = "rg16uint"
    case rg16sint = "rg16sint"
    case rg16float = "rg16float"
    case rgba8unorm = "rgba8unorm"
    case rgba8unormSrgb = "rgba8unorm-srgb"
    case rgba8snorm = "rgba8snorm"
    case rgba8uint = "rgba8uint"
    case rgba8sint = "rgba8sint"
    case bgra8unorm = "bgra8unorm"
    case bgra8unormSrgb = "bgra8unorm-srgb"
    case rgb9e5ufloat = "rgb9e5ufloat"
    case rgb10a2unorm = "rgb10a2unorm"
    case rg11b10ufloat = "rg11b10ufloat"
    case rg32uint = "rg32uint"
    case rg32sint = "rg32sint"
    case rg32float = "rg32float"
    case rgba16uint = "rgba16uint"
    case rgba16sint = "rgba16sint"
    case rgba16float = "rgba16float"
    case rgba32uint = "rgba32uint"
    case rgba32sint = "rgba32sint"
    case rgba32float = "rgba32float"
    case stencil8 = "stencil8"
    case depth16unorm = "depth16unorm"
    case depth24plus = "depth24plus"
    case depth24plusStencil8 = "depth24plus-stencil8"
    case depth32float = "depth32float"
    case depth32floatStencil8 = "depth32float-stencil8"
    case bc1RgbaUnorm = "bc1-rgba-unorm"
    case bc1RgbaUnormSrgb = "bc1-rgba-unorm-srgb"
    case bc2RgbaUnorm = "bc2-rgba-unorm"
    case bc2RgbaUnormSrgb = "bc2-rgba-unorm-srgb"
    case bc3RgbaUnorm = "bc3-rgba-unorm"
    case bc3RgbaUnormSrgb = "bc3-rgba-unorm-srgb"
    case bc4RUnorm = "bc4-r-unorm"
    case bc4RSnorm = "bc4-r-snorm"
    case bc5RgUnorm = "bc5-rg-unorm"
    case bc5RgSnorm = "bc5-rg-snorm"
    case bc6hRgbUfloat = "bc6h-rgb-ufloat"
    case bc6hRgbFloat = "bc6h-rgb-float"
    case bc7RgbaUnorm = "bc7-rgba-unorm"
    case bc7RgbaUnormSrgb = "bc7-rgba-unorm-srgb"
    case etc2Rgb8unorm = "etc2-rgb8unorm"
    case etc2Rgb8unormSrgb = "etc2-rgb8unorm-srgb"
    case etc2Rgb8a1unorm = "etc2-rgb8a1unorm"
    case etc2Rgb8a1unormSrgb = "etc2-rgb8a1unorm-srgb"
    case etc2Rgba8unorm = "etc2-rgba8unorm"
    case etc2Rgba8unormSrgb = "etc2-rgba8unorm-srgb"
    case eacR11unorm = "eac-r11unorm"
    case eacR11snorm = "eac-r11snorm"
    case eacRg11unorm = "eac-rg11unorm"
    case eacRg11snorm = "eac-rg11snorm"
    case astc4x4Unorm = "astc-4x4-unorm"
    case astc4x4UnormSrgb = "astc-4x4-unorm-srgb"
    case astc5x4Unorm = "astc-5x4-unorm"
    case astc5x4UnormSrgb = "astc-5x4-unorm-srgb"
    case astc5x5Unorm = "astc-5x5-unorm"
    case astc5x5UnormSrgb = "astc-5x5-unorm-srgb"
    case astc6x5Unorm = "astc-6x5-unorm"
    case astc6x5UnormSrgb = "astc-6x5-unorm-srgb"
    case astc6x6Unorm = "astc-6x6-unorm"
    case astc6x6UnormSrgb = "astc-6x6-unorm-srgb"
    case astc8x5Unorm = "astc-8x5-unorm"
    case astc8x5UnormSrgb = "astc-8x5-unorm-srgb"
    case astc8x6Unorm = "astc-8x6-unorm"
    case astc8x6UnormSrgb = "astc-8x6-unorm-srgb"
    case astc8x8Unorm = "astc-8x8-unorm"
    case astc8x8UnormSrgb = "astc-8x8-unorm-srgb"
    case astc10x5Unorm = "astc-10x5-unorm"
    case astc10x5UnormSrgb = "astc-10x5-unorm-srgb"
    case astc10x6Unorm = "astc-10x6-unorm"
    case astc10x6UnormSrgb = "astc-10x6-unorm-srgb"
    case astc10x8Unorm = "astc-10x8-unorm"
    case astc10x8UnormSrgb = "astc-10x8-unorm-srgb"
    case astc10x10Unorm = "astc-10x10-unorm"
    case astc10x10UnormSrgb = "astc-10x10-unorm-srgb"
    case astc12x10Unorm = "astc-12x10-unorm"
    case astc12x10UnormSrgb = "astc-12x10-unorm-srgb"
    case astc12x12Unorm = "astc-12x12-unorm"
    case astc12x12UnormSrgb = "astc-12x12-unorm-srgb"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureSampleType: JSString, JSValueCompatible {
    case float = "float"
    case unfilterableFloat = "unfilterable-float"
    case depth = "depth"
    case sint = "sint"
    case uint = "uint"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureUsage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[.GPUTextureUsage].object!
    }

    public static let COPY_SRC: GPUFlagsConstant = 0x01

    public static let COPY_DST: GPUFlagsConstant = 0x02

    public static let TEXTURE_BINDING: GPUFlagsConstant = 0x04

    public static let STORAGE_BINDING: GPUFlagsConstant = 0x08

    public static let RENDER_ATTACHMENT: GPUFlagsConstant = 0x10
}

public class GPUTextureView: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUTextureView].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUTextureViewDescriptor: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, dimension: GPUTextureViewDimension, aspect: GPUTextureAspect, baseMipLevel: GPUIntegerCoordinate, mipLevelCount: GPUIntegerCoordinate, baseArrayLayer: GPUIntegerCoordinate, arrayLayerCount: GPUIntegerCoordinate) {
        let object = JSObject.global[.Object].function!.new()
        object[.format] = _toJSValue(format)
        object[.dimension] = _toJSValue(dimension)
        object[.aspect] = _toJSValue(aspect)
        object[.baseMipLevel] = _toJSValue(baseMipLevel)
        object[.mipLevelCount] = _toJSValue(mipLevelCount)
        object[.baseArrayLayer] = _toJSValue(baseArrayLayer)
        object[.arrayLayerCount] = _toJSValue(arrayLayerCount)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: .format)
        _dimension = ReadWriteAttribute(jsObject: object, name: .dimension)
        _aspect = ReadWriteAttribute(jsObject: object, name: .aspect)
        _baseMipLevel = ReadWriteAttribute(jsObject: object, name: .baseMipLevel)
        _mipLevelCount = ReadWriteAttribute(jsObject: object, name: .mipLevelCount)
        _baseArrayLayer = ReadWriteAttribute(jsObject: object, name: .baseArrayLayer)
        _arrayLayerCount = ReadWriteAttribute(jsObject: object, name: .arrayLayerCount)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUTextureFormat

    @ReadWriteAttribute
    public var dimension: GPUTextureViewDimension

    @ReadWriteAttribute
    public var aspect: GPUTextureAspect

    @ReadWriteAttribute
    public var baseMipLevel: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var mipLevelCount: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var baseArrayLayer: GPUIntegerCoordinate

    @ReadWriteAttribute
    public var arrayLayerCount: GPUIntegerCoordinate
}

public enum GPUTextureViewDimension: JSString, JSValueCompatible {
    case _1d = "1d"
    case _2d = "2d"
    case _2dArray = "2d-array"
    case cube = "cube"
    case cubeArray = "cube-array"
    case _3d = "3d"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUUncapturedErrorEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUUncapturedErrorEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _error = ReadonlyAttribute(jsObject: jsObject, name: .error)
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(type: String, gpuUncapturedErrorEventInitDict: GPUUncapturedErrorEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(gpuUncapturedErrorEventInitDict)]))
    }

    @ReadonlyAttribute
    public var error: GPUError
}

public class GPUUncapturedErrorEventInit: BridgedDictionary {
    public convenience init(error: GPUError) {
        let object = JSObject.global[.Object].function!.new()
        object[.error] = _toJSValue(error)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _error = ReadWriteAttribute(jsObject: object, name: .error)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var error: GPUError
}

public class GPUValidationError: GPUError {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUValidationError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(message: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

public class GPUVertexAttribute: BridgedDictionary {
    public convenience init(format: GPUVertexFormat, offset: GPUSize64, shaderLocation: GPUIndex32) {
        let object = JSObject.global[.Object].function!.new()
        object[.format] = _toJSValue(format)
        object[.offset] = _toJSValue(offset)
        object[.shaderLocation] = _toJSValue(shaderLocation)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _format = ReadWriteAttribute(jsObject: object, name: .format)
        _offset = ReadWriteAttribute(jsObject: object, name: .offset)
        _shaderLocation = ReadWriteAttribute(jsObject: object, name: .shaderLocation)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var format: GPUVertexFormat

    @ReadWriteAttribute
    public var offset: GPUSize64

    @ReadWriteAttribute
    public var shaderLocation: GPUIndex32
}

public class GPUVertexBufferLayout: BridgedDictionary {
    public convenience init(arrayStride: GPUSize64, stepMode: GPUVertexStepMode, attributes: [GPUVertexAttribute]) {
        let object = JSObject.global[.Object].function!.new()
        object[.arrayStride] = _toJSValue(arrayStride)
        object[.stepMode] = _toJSValue(stepMode)
        object[.attributes] = _toJSValue(attributes)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _arrayStride = ReadWriteAttribute(jsObject: object, name: .arrayStride)
        _stepMode = ReadWriteAttribute(jsObject: object, name: .stepMode)
        _attributes = ReadWriteAttribute(jsObject: object, name: .attributes)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var arrayStride: GPUSize64

    @ReadWriteAttribute
    public var stepMode: GPUVertexStepMode

    @ReadWriteAttribute
    public var attributes: [GPUVertexAttribute]
}

public enum GPUVertexFormat: JSString, JSValueCompatible {
    case uint8x2 = "uint8x2"
    case uint8x4 = "uint8x4"
    case sint8x2 = "sint8x2"
    case sint8x4 = "sint8x4"
    case unorm8x2 = "unorm8x2"
    case unorm8x4 = "unorm8x4"
    case snorm8x2 = "snorm8x2"
    case snorm8x4 = "snorm8x4"
    case uint16x2 = "uint16x2"
    case uint16x4 = "uint16x4"
    case sint16x2 = "sint16x2"
    case sint16x4 = "sint16x4"
    case unorm16x2 = "unorm16x2"
    case unorm16x4 = "unorm16x4"
    case snorm16x2 = "snorm16x2"
    case snorm16x4 = "snorm16x4"
    case float16x2 = "float16x2"
    case float16x4 = "float16x4"
    case float32 = "float32"
    case float32x2 = "float32x2"
    case float32x3 = "float32x3"
    case float32x4 = "float32x4"
    case uint32 = "uint32"
    case uint32x2 = "uint32x2"
    case uint32x3 = "uint32x3"
    case uint32x4 = "uint32x4"
    case sint32 = "sint32"
    case sint32x2 = "sint32x2"
    case sint32x3 = "sint32x3"
    case sint32x4 = "sint32x4"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUVertexState: BridgedDictionary {
    public convenience init(buffers: [GPUVertexBufferLayout?]) {
        let object = JSObject.global[.Object].function!.new()
        object[.buffers] = _toJSValue(buffers)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _buffers = ReadWriteAttribute(jsObject: object, name: .buffers)
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var buffers: [GPUVertexBufferLayout?]
}

public enum GPUVertexStepMode: JSString, JSValueCompatible {
    case vertex = "vertex"
    case instance = "instance"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol NavigatorGPU: JSBridgedClass {}
public extension NavigatorGPU {
    @inlinable var gpu: GPU { jsObject[.gpu].fromJSValue()! }
}

extension Navigator: NavigatorGPU {}

public class WGSLLanguageFeatures: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.WGSLLanguageFeatures].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    // XXX: make me Set-like!
}



public enum GPUAutoLayoutMode_or_GPUPipelineLayout: JSValueCompatible  {
    case gpuAutoLayoutMode(GPUAutoLayoutMode)
    case gpuPipelineLayout(GPUPipelineLayout)

    public static func construct(from value: JSValue) -> Self? {
        if let gpuAutoLayoutMode: GPUAutoLayoutMode = value.fromJSValue() {
            return .gpuAutoLayoutMode(gpuAutoLayoutMode)
        }
        if let gpuPipelineLayout: GPUPipelineLayout = value.fromJSValue() {
            return .gpuPipelineLayout(gpuPipelineLayout)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuAutoLayoutMode(gpuAutoLayoutMode):
            return gpuAutoLayoutMode.jsValue
        case let .gpuPipelineLayout(gpuPipelineLayout):
            return gpuPipelineLayout.jsValue
        }
    }
}

public enum GPUBindingResource: JSValueCompatible {
    case gpuBufferBinding(GPUBufferBinding)
    case gpuExternalTexture(GPUExternalTexture)
    case gpuSampler(GPUSampler)
    case gpuTextureView(GPUTextureView)

    public static func construct(from value: JSValue) -> Self? {
        if let gpuBufferBinding: GPUBufferBinding = value.fromJSValue() {
            return .gpuBufferBinding(gpuBufferBinding)
        }
        if let gpuExternalTexture: GPUExternalTexture = value.fromJSValue() {
            return .gpuExternalTexture(gpuExternalTexture)
        }
        if let gpuSampler: GPUSampler = value.fromJSValue() {
            return .gpuSampler(gpuSampler)
        }
        if let gpuTextureView: GPUTextureView = value.fromJSValue() {
            return .gpuTextureView(gpuTextureView)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuBufferBinding(gpuBufferBinding):
            return gpuBufferBinding.jsValue
        case let .gpuExternalTexture(gpuExternalTexture):
            return gpuExternalTexture.jsValue
        case let .gpuSampler(gpuSampler):
            return gpuSampler.jsValue
        case let .gpuTextureView(gpuTextureView):
            return gpuTextureView.jsValue
        }
    }
}

public enum GPUColor: JSValueCompatible {
    case gpuColorDict(GPUColorDict)
    case seq_of_Double([Double])

    public static func construct(from value: JSValue) -> Self? {
        if let gpuColorDict: GPUColorDict = value.fromJSValue() {
            return .gpuColorDict(gpuColorDict)
        }
        if let seq_of_Double: [Double] = value.fromJSValue() {
            return .seq_of_Double(seq_of_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuColorDict(gpuColorDict):
            return gpuColorDict.jsValue
        case let .seq_of_Double(seq_of_Double):
            return seq_of_Double.jsValue
        }
    }
}

public enum GPUExtent3D: JSValueCompatible {
    case gpuExtent3DDict(GPUExtent3DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    public static func construct(from value: JSValue) -> Self? {
        if let gpuExtent3DDict: GPUExtent3DDict = value.fromJSValue() {
            return .gpuExtent3DDict(gpuExtent3DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuExtent3DDict(gpuExtent3DDict):
            return gpuExtent3DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public enum GPUImageCopyExternalImageSource: JSValueCompatible {
    case htmlCanvasElement(HTMLCanvasElement)
    case htmlVideoElement(HTMLVideoElement)
    case imageBitmap(ImageBitmap)
    case offscreenCanvas(OffscreenCanvas)
    case videoFrame(VideoFrame)

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let htmlVideoElement: HTMLVideoElement = value.fromJSValue() {
            return .htmlVideoElement(htmlVideoElement)
        }
        if let imageBitmap: ImageBitmap = value.fromJSValue() {
            return .imageBitmap(imageBitmap)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        if let videoFrame: VideoFrame = value.fromJSValue() {
            return .videoFrame(videoFrame)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .htmlVideoElement(htmlVideoElement):
            return htmlVideoElement.jsValue
        case let .imageBitmap(imageBitmap):
            return imageBitmap.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        case let .videoFrame(videoFrame):
            return videoFrame.jsValue
        }
    }
}

public enum GPUOrigin2D: JSValueCompatible {
    case gpuOrigin2DDict(GPUOrigin2DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    public static func construct(from value: JSValue) -> Self? {
        if let gpuOrigin2DDict: GPUOrigin2DDict = value.fromJSValue() {
            return .gpuOrigin2DDict(gpuOrigin2DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuOrigin2DDict(gpuOrigin2DDict):
            return gpuOrigin2DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public enum GPUOrigin3D: JSValueCompatible {
    case gpuOrigin3DDict(GPUOrigin3DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    public static func construct(from value: JSValue) -> Self? {
        if let gpuOrigin3DDict: GPUOrigin3DDict = value.fromJSValue() {
            return .gpuOrigin3DDict(gpuOrigin3DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuOrigin3DDict(gpuOrigin3DDict):
            return gpuOrigin3DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public enum HTMLVideoElement_or_VideoFrame: JSValueCompatible {
    case htmlVideoElement(HTMLVideoElement)
    case videoFrame(VideoFrame)

    public static func construct(from value: JSValue) -> Self? {
        if let htmlVideoElement: HTMLVideoElement = value.fromJSValue() {
            return .htmlVideoElement(htmlVideoElement)
        }
        if let videoFrame: VideoFrame = value.fromJSValue() {
            return .videoFrame(videoFrame)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlVideoElement(htmlVideoElement):
            return htmlVideoElement.jsValue
        case let .videoFrame(videoFrame):
            return videoFrame.jsValue
        }
    }
}
