// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptBigIntSupport
import JavaScriptEventLoop
import JavaScriptKit
import WebAnimations
import WebAPIBase
import WebGL1

public class GPU: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPU].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func requestAdapter(options: GPURequestAdapterOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.requestAdapter].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestAdapter(options: GPURequestAdapterOptions? = nil) async throws -> GPUAdapter? {
        let this = jsObject
        let _promise: JSPromise = this[.requestAdapter].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()
    }

    @inlinable public func getPreferredCanvasFormat() -> GPUTextureFormat {
        let this = jsObject
        return this[.getPreferredCanvasFormat].function!(this: this, arguments: []).fromJSValue()!
    }

public var wgslLanguageFeatures: WGSLLanguageFeatures {
jsObject[.wgslLanguageFeatures].fromJSValue()!
    }
}

public class GPUAdapter: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUAdapter].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }

public var features: GPUSupportedFeatures {
jsObject[.features].fromJSValue()!
    }

public var limits: GPUSupportedLimits {
jsObject[.limits].fromJSValue()!
    }

public var isFallbackAdapter: Bool {
jsObject[.isFallbackAdapter].fromJSValue()!
    }

    @inlinable public func requestDevice(descriptor: GPUDeviceDescriptor? = nil) -> JSPromise {
        let this = jsObject
        return this[.requestDevice].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestDevice(descriptor: GPUDeviceDescriptor? = nil) async throws -> GPUDevice {
        let this = jsObject
        let _promise: JSPromise = this[.requestDevice].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func requestAdapterInfo(unmaskHints: [String]? = nil) -> JSPromise {
        let this = jsObject
        return this[.requestAdapterInfo].function!(this: this, arguments: [_toJSValue(unmaskHints)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestAdapterInfo(unmaskHints: [String]? = nil) async throws -> GPUAdapterInfo {
        let this = jsObject
        let _promise: JSPromise = this[.requestAdapterInfo].function!(this: this, arguments: [_toJSValue(unmaskHints)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class GPUAdapterInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUAdapterInfo].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }

public var vendor: String {
jsObject[.vendor].fromJSValue()!
    }

public var architecture: String {
jsObject[.architecture].fromJSValue()!
    }

public var device: String {
jsObject[.device].fromJSValue()!
    }

public var description: String {
jsObject[.description].fromJSValue()!
    }
}

public enum GPUAddressMode: JSString, JSValueCompatible {
    case clampToEdge = "clamp-to-edge"
    case `repeat` = "repeat"
    case mirrorRepeat = "mirror-repeat"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUAutoLayoutMode: JSString, JSValueCompatible {
    case auto = "auto"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBindGroup: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUBindGroup].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUBindGroupDescriptor: BridgedDictionary {
    public convenience init(layout: GPUBindGroupLayout, entries: [GPUBindGroupEntry]) {
        let object = JSObject.global[.Object].function!.new()
        object[.layout] = _toJSValue(layout)
        object[.entries] = _toJSValue(entries)
        self.init(unsafelyWrapping: object)
    }

    public var layout: GPUBindGroupLayout {
        get { jsObject[.layout].fromJSValue()!}
        set { jsObject[.layout] = newValue.jsValue }
    }

    public var entries: [GPUBindGroupEntry] {
        get { jsObject[.entries].fromJSValue()!}
        set { jsObject[.entries] = newValue.jsValue }
    }
}

public class GPUBindGroupEntry: BridgedDictionary {
    public convenience init(binding: GPUIndex32, resource: GPUBindingResource) {
        let object = JSObject.global[.Object].function!.new()
        object[.binding] = _toJSValue(binding)
        object[.resource] = _toJSValue(resource)
        self.init(unsafelyWrapping: object)
    }

    public var binding: GPUIndex32 {
        get { jsObject[.binding].fromJSValue()!}
        set { jsObject[.binding] = newValue.jsValue }
    }

    public var resource: GPUBindingResource {
        get { jsObject[.resource].fromJSValue()!}
        set { jsObject[.resource] = newValue.jsValue }
    }
}

public class GPUBindGroupLayout: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUBindGroupLayout].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUBindGroupLayoutDescriptor: BridgedDictionary {
    public convenience init(entries: [GPUBindGroupLayoutEntry]) {
        let object = JSObject.global[.Object].function!.new()
        object[.entries] = _toJSValue(entries)
        self.init(unsafelyWrapping: object)
    }

    public var entries: [GPUBindGroupLayoutEntry] {
        get { jsObject[.entries].fromJSValue()!}
        set { jsObject[.entries] = newValue.jsValue }
    }
}

public class GPUBindGroupLayoutEntry: BridgedDictionary {
    public convenience init(binding: GPUIndex32, visibility: GPUShaderStageFlags, buffer: GPUBufferBindingLayout, sampler: GPUSamplerBindingLayout, texture: GPUTextureBindingLayout, storageTexture: GPUStorageTextureBindingLayout, externalTexture: GPUExternalTextureBindingLayout) {
        let object = JSObject.global[.Object].function!.new()
        object[.binding] = _toJSValue(binding)
        object[.visibility] = _toJSValue(visibility)
        object[.buffer] = _toJSValue(buffer)
        object[.sampler] = _toJSValue(sampler)
        object[.texture] = _toJSValue(texture)
        object[.storageTexture] = _toJSValue(storageTexture)
        object[.externalTexture] = _toJSValue(externalTexture)
        self.init(unsafelyWrapping: object)
    }

    public var binding: GPUIndex32 {
        get { jsObject[.binding].fromJSValue()!}
        set { jsObject[.binding] = newValue.jsValue }
    }

    public var visibility: GPUShaderStageFlags {
        get { jsObject[.visibility].fromJSValue()!}
        set { jsObject[.visibility] = newValue.jsValue }
    }

    public var buffer: GPUBufferBindingLayout {
        get { jsObject[.buffer].fromJSValue()!}
        set { jsObject[.buffer] = newValue.jsValue }
    }

    public var sampler: GPUSamplerBindingLayout {
        get { jsObject[.sampler].fromJSValue()!}
        set { jsObject[.sampler] = newValue.jsValue }
    }

    public var texture: GPUTextureBindingLayout {
        get { jsObject[.texture].fromJSValue()!}
        set { jsObject[.texture] = newValue.jsValue }
    }

    public var storageTexture: GPUStorageTextureBindingLayout {
        get { jsObject[.storageTexture].fromJSValue()!}
        set { jsObject[.storageTexture] = newValue.jsValue }
    }

    public var externalTexture: GPUExternalTextureBindingLayout {
        get { jsObject[.externalTexture].fromJSValue()!}
        set { jsObject[.externalTexture] = newValue.jsValue }
    }
}

public protocol GPUBindingCommandsMixin: JSBridgedClass {}
public extension GPUBindingCommandsMixin {
    @inlinable func setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup?, dynamicOffsets: [GPUBufferDynamicOffset]? = nil) {
        let this = jsObject
        _ = this[.setBindGroup].function!(this: this, arguments: [_toJSValue(index), _toJSValue(bindGroup), _toJSValue(dynamicOffsets)])
    }

    @inlinable func setBindGroup(index: GPUIndex32, bindGroup: GPUBindGroup?, dynamicOffsetsData: Uint32Array, dynamicOffsetsDataStart: GPUSize64, dynamicOffsetsDataLength: GPUSize32) {
        let this = jsObject
        _ = this[.setBindGroup].function!(this: this, arguments: [_toJSValue(index), _toJSValue(bindGroup), _toJSValue(dynamicOffsetsData), _toJSValue(dynamicOffsetsDataStart), _toJSValue(dynamicOffsetsDataLength)])
    }
}

public class GPUBlendComponent: BridgedDictionary {
    public convenience init(operation: GPUBlendOperation, srcFactor: GPUBlendFactor, dstFactor: GPUBlendFactor) {
        let object = JSObject.global[.Object].function!.new()
        object[.operation] = _toJSValue(operation)
        object[.srcFactor] = _toJSValue(srcFactor)
        object[.dstFactor] = _toJSValue(dstFactor)
        self.init(unsafelyWrapping: object)
    }

    public var operation: GPUBlendOperation {
        get { jsObject[.operation].fromJSValue()!}
        set { jsObject[.operation] = newValue.jsValue }
    }

    public var srcFactor: GPUBlendFactor {
        get { jsObject[.srcFactor].fromJSValue()!}
        set { jsObject[.srcFactor] = newValue.jsValue }
    }

    public var dstFactor: GPUBlendFactor {
        get { jsObject[.dstFactor].fromJSValue()!}
        set { jsObject[.dstFactor] = newValue.jsValue }
    }
}

public enum GPUBlendFactor: JSString, JSValueCompatible {
    case zero = "zero"
    case one = "one"
    case src = "src"
    case oneMinusSrc = "one-minus-src"
    case srcAlpha = "src-alpha"
    case oneMinusSrcAlpha = "one-minus-src-alpha"
    case dst = "dst"
    case oneMinusDst = "one-minus-dst"
    case dstAlpha = "dst-alpha"
    case oneMinusDstAlpha = "one-minus-dst-alpha"
    case srcAlphaSaturated = "src-alpha-saturated"
    case constant = "constant"
    case oneMinusConstant = "one-minus-constant"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUBlendOperation: JSString, JSValueCompatible {
    case add = "add"
    case subtract = "subtract"
    case reverseSubtract = "reverse-subtract"
    case min = "min"
    case max = "max"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBlendState: BridgedDictionary {
    public convenience init(color: GPUBlendComponent, alpha: GPUBlendComponent) {
        let object = JSObject.global[.Object].function!.new()
        object[.color] = _toJSValue(color)
        object[.alpha] = _toJSValue(alpha)
        self.init(unsafelyWrapping: object)
    }
    
    public var color: GPUBlendComponent {
        get { jsObject[.color].fromJSValue()!}
        set { jsObject[.color] = newValue.jsValue }
    }

    public var alpha: GPUBlendComponent {
        get { jsObject[.alpha].fromJSValue()!}
        set { jsObject[.alpha] = newValue.jsValue }
    }
}

public class GPUBuffer: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUBuffer].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }

public var size: GPUSize64Out {
jsObject[.size].fromJSValue()!
    }

public var usage: GPUFlagsConstant {
jsObject[.usage].fromJSValue()!
    }

public var mapState: GPUBufferMapState {
jsObject[.mapState].fromJSValue()!
    }

    @inlinable public func mapAsync(mode: GPUMapModeFlags, offset: GPUSize64? = nil, size: GPUSize64? = nil) -> JSPromise {
        let this = jsObject
        return this[.mapAsync].function!(this: this, arguments: [_toJSValue(mode), _toJSValue(offset), _toJSValue(size)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func mapAsync(mode: GPUMapModeFlags, offset: GPUSize64? = nil, size: GPUSize64? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.mapAsync].function!(this: this, arguments: [_toJSValue(mode), _toJSValue(offset), _toJSValue(size)]).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func getMappedRange(offset: GPUSize64? = nil, size: GPUSize64? = nil) -> ArrayBuffer {
        let this = jsObject
        return this[.getMappedRange].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(size)]).fromJSValue()!
    }

    @inlinable public func unmap() {
        let this = jsObject
        _ = this[.unmap].function!(this: this, arguments: [])
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[.destroy].function!(this: this, arguments: [])
    }
}

public class GPUBufferBinding: BridgedDictionary {
    public convenience init(buffer: GPUBuffer, offset: GPUSize64, size: GPUSize64) {
        let object = JSObject.global[.Object].function!.new()
        object[.buffer] = _toJSValue(buffer)
        object[.offset] = _toJSValue(offset)
        object[.size] = _toJSValue(size)
        self.init(unsafelyWrapping: object)
    }

    public var buffer: GPUBuffer {
        get { jsObject[.buffer].fromJSValue()!}
        set { jsObject[.buffer] = newValue.jsValue }
    }

    public var offset: GPUSize64 {
        get { jsObject[.offset].fromJSValue()!}
        set { jsObject[.offset] = newValue.jsValue }
    }

    public var size: GPUSize64 {
        get { jsObject[.size].fromJSValue()!}
        set { jsObject[.size] = newValue.jsValue }
    }
}

public class GPUBufferBindingLayout: BridgedDictionary {
    public convenience init(type: GPUBufferBindingType, hasDynamicOffset: Bool, minBindingSize: GPUSize64) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.hasDynamicOffset] = _toJSValue(hasDynamicOffset)
        object[.minBindingSize] = _toJSValue(minBindingSize)
        self.init(unsafelyWrapping: object)
    }

    public var type: GPUBufferBindingType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }

    public var hasDynamicOffset: Bool {
        get { jsObject[.hasDynamicOffset].fromJSValue()!}
        set { jsObject[.hasDynamicOffset] = newValue.jsValue }
    }

    public var minBindingSize: GPUSize64 {
        get { jsObject[.minBindingSize].fromJSValue()!}
        set { jsObject[.minBindingSize] = newValue.jsValue }
    }
}

public enum GPUBufferBindingType: JSString, JSValueCompatible {
    case uniform = "uniform"
    case storage = "storage"
    case readOnlyStorage = "read-only-storage"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUBufferDescriptor: BridgedDictionary {
    public convenience init(size: GPUSize64, usage: GPUBufferUsageFlags, mappedAtCreation: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.size] = _toJSValue(size)
        object[.usage] = _toJSValue(usage)
        object[.mappedAtCreation] = _toJSValue(mappedAtCreation)
        self.init(unsafelyWrapping: object)
    }

    public var size: GPUSize64 {
        get { jsObject[.size].fromJSValue()!}
        set { jsObject[.size] = newValue.jsValue }
    }

    public var usage: GPUBufferUsageFlags {
        get { jsObject[.usage].fromJSValue()!}
        set { jsObject[.usage] = newValue.jsValue }
    }

    public var mappedAtCreation: Bool {
        get { jsObject[.mappedAtCreation].fromJSValue()!}
        set { jsObject[.mappedAtCreation] = newValue.jsValue }
    }
}

public enum GPUBufferMapState: JSString, JSValueCompatible {
    case unmapped = "unmapped"
    case pending = "pending"
    case mapped = "mapped"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUBufferUsage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[.GPUBufferUsage].object!
    }

    public static let MAP_READ: GPUFlagsConstant = 0x0001

    public static let MAP_WRITE: GPUFlagsConstant = 0x0002

    public static let COPY_SRC: GPUFlagsConstant = 0x0004

    public static let COPY_DST: GPUFlagsConstant = 0x0008

    public static let INDEX: GPUFlagsConstant = 0x0010

    public static let VERTEX: GPUFlagsConstant = 0x0020

    public static let UNIFORM: GPUFlagsConstant = 0x0040

    public static let STORAGE: GPUFlagsConstant = 0x0080

    public static let INDIRECT: GPUFlagsConstant = 0x0100

    public static let QUERY_RESOLVE: GPUFlagsConstant = 0x0200
}

public enum GPUCanvasAlphaMode: JSString, JSValueCompatible {
    case opaque = "opaque"
    case premultiplied = "premultiplied"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUCanvasConfiguration: BridgedDictionary {
    public convenience init(device: GPUDevice, format: GPUTextureFormat, usage: GPUTextureUsageFlags, viewFormats: [GPUTextureFormat], colorSpace: PredefinedColorSpace, alphaMode: GPUCanvasAlphaMode) {
        let object = JSObject.global[.Object].function!.new()
        object[.device] = _toJSValue(device)
        object[.format] = _toJSValue(format)
        object[.usage] = _toJSValue(usage)
        object[.viewFormats] = _toJSValue(viewFormats)
        object[.colorSpace] = _toJSValue(colorSpace)
        object[.alphaMode] = _toJSValue(alphaMode)
        self.init(unsafelyWrapping: object)
    }

    public var device: GPUDevice {
        get { jsObject[.device].fromJSValue()!}
        set { jsObject[.device] = newValue.jsValue }
    }

    public var format: GPUTextureFormat {
        get { jsObject[.format].fromJSValue()!}
        set { jsObject[.format] = newValue.jsValue }
    }

    public var usage: GPUTextureUsageFlags {
        get { jsObject[.usage].fromJSValue()!}
        set { jsObject[.usage] = newValue.jsValue }
    }

    public var viewFormats: [GPUTextureFormat] {
        get { jsObject[.viewFormats].fromJSValue()!}
        set { jsObject[.viewFormats] = newValue.jsValue }
    }

    public var colorSpace: PredefinedColorSpace {
        get { jsObject[.colorSpace].fromJSValue()!}
        set { jsObject[.colorSpace] = newValue.jsValue }
    }

    public var alphaMode: GPUCanvasAlphaMode {
        get { jsObject[.alphaMode].fromJSValue()!}
        set { jsObject[.alphaMode] = newValue.jsValue }
    }
}

public class GPUCanvasContext: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUCanvasContext].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

public var canvas: RenderingCanvas {
jsObject[.canvas].fromJSValue()!
    }

    @inlinable public func configure(configuration: GPUCanvasConfiguration) {
        let this = jsObject
        _ = this[.configure].function!(this: this, arguments: [_toJSValue(configuration)])
    }

    @inlinable public func unconfigure() {
        let this = jsObject
        _ = this[.unconfigure].function!(this: this, arguments: [])
    }

    @inlinable public func getCurrentTexture() -> GPUTexture {
        let this = jsObject
        return this[.getCurrentTexture].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class GPUColorDict: BridgedDictionary {
    public convenience init(r: Double, g: Double, b: Double, a: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.r] = _toJSValue(r)
        object[.g] = _toJSValue(g)
        object[.b] = _toJSValue(b)
        object[.a] = _toJSValue(a)
        self.init(unsafelyWrapping: object)
    }

    public var r: Double {
        get { jsObject[.r].fromJSValue()!}
        set { jsObject[.r] = newValue.jsValue }
    }

    public var g: Double {
        get { jsObject[.g].fromJSValue()!}
        set { jsObject[.g] = newValue.jsValue }
    }

    public var b: Double {
        get { jsObject[.b].fromJSValue()!}
        set { jsObject[.b] = newValue.jsValue }
    }

    public var a: Double {
        get { jsObject[.a].fromJSValue()!}
        set { jsObject[.a] = newValue.jsValue }
    }
}

public class GPUColorTargetState: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, blend: GPUBlendState, writeMask: GPUColorWriteFlags) {
        let object = JSObject.global[.Object].function!.new()
        object[.format] = _toJSValue(format)
        object[.blend] = _toJSValue(blend)
        object[.writeMask] = _toJSValue(writeMask)
        self.init(unsafelyWrapping: object)
    }

    public var format: GPUTextureFormat {
        get { jsObject[.format].fromJSValue()!}
        set { jsObject[.format] = newValue.jsValue }
    }

    public var blend: GPUBlendState {
        get { jsObject[.blend].fromJSValue()!}
        set { jsObject[.blend] = newValue.jsValue }
    }

    public var writeMask: GPUColorWriteFlags {
        get { jsObject[.writeMask].fromJSValue()!}
        set { jsObject[.writeMask] = newValue.jsValue }
    }
}

public enum GPUColorWrite {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[.GPUColorWrite].object!
    }

    public static let RED: GPUFlagsConstant = 0x1

    public static let GREEN: GPUFlagsConstant = 0x2

    public static let BLUE: GPUFlagsConstant = 0x4

    public static let ALPHA: GPUFlagsConstant = 0x8

    public static let ALL: GPUFlagsConstant = 0xF
}

public class GPUCommandBuffer: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUCommandBuffer].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUCommandBufferDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPUCommandEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUCommandEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func beginRenderPass(descriptor: GPURenderPassDescriptor) -> GPURenderPassEncoder {
        let this = jsObject
        return this[.beginRenderPass].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func beginComputePass(descriptor: GPUComputePassDescriptor? = nil) -> GPUComputePassEncoder {
        let this = jsObject
        return this[.beginComputePass].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func copyBufferToBuffer(source: GPUBuffer, sourceOffset: GPUSize64, destination: GPUBuffer, destinationOffset: GPUSize64, size: GPUSize64) {
        let this = jsObject
        _ = this[.copyBufferToBuffer].function!(this: this, arguments: [_toJSValue(source), _toJSValue(sourceOffset), _toJSValue(destination), _toJSValue(destinationOffset), _toJSValue(size)])
    }

    @inlinable public func copyBufferToTexture(source: GPUImageCopyBuffer, destination: GPUImageCopyTexture, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[.copyBufferToTexture].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }

    @inlinable public func copyTextureToBuffer(source: GPUImageCopyTexture, destination: GPUImageCopyBuffer, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[.copyTextureToBuffer].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }

    @inlinable public func copyTextureToTexture(source: GPUImageCopyTexture, destination: GPUImageCopyTexture, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[.copyTextureToTexture].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }

    @inlinable public func clearBuffer(buffer: GPUBuffer, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[.clearBuffer].function!(this: this, arguments: [_toJSValue(buffer), _toJSValue(offset), _toJSValue(size)])
    }

    @inlinable public func writeTimestamp(querySet: GPUQuerySet, queryIndex: GPUSize32) {
        let this = jsObject
        _ = this[.writeTimestamp].function!(this: this, arguments: [_toJSValue(querySet), _toJSValue(queryIndex)])
    }

    @inlinable public func resolveQuerySet(querySet: GPUQuerySet, firstQuery: GPUSize32, queryCount: GPUSize32, destination: GPUBuffer, destinationOffset: GPUSize64) {
        let this = jsObject
        _ = this[.resolveQuerySet].function!(this: this, arguments: [_toJSValue(querySet), _toJSValue(firstQuery), _toJSValue(queryCount), _toJSValue(destination), _toJSValue(destinationOffset)])
    }

    @inlinable public func finish(descriptor: GPUCommandBufferDescriptor? = nil) -> GPUCommandBuffer {
        let this = jsObject
        return this[.finish].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }
}

public class GPUCommandEncoderDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public protocol GPUCommandsMixin: JSBridgedClass {}
public extension GPUCommandsMixin {}

public enum GPUCompareFunction: JSString, JSValueCompatible {
    case never = "never"
    case less = "less"
    case equal = "equal"
    case lessEqual = "less-equal"
    case greater = "greater"
    case notEqual = "not-equal"
    case greaterEqual = "greater-equal"
    case always = "always"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUCompilationInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUCompilationInfo].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

public var messages: [GPUCompilationMessage] {
jsObject[.messages].fromJSValue()!
    }
}

public class GPUCompilationMessage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUCompilationMessage].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }

public var message: String {
jsObject[.message].fromJSValue()!
    }

public var type: GPUCompilationMessageType {
jsObject[.type].fromJSValue()!
    }

public var lineNum: UInt64 {
jsObject[.lineNum].fromJSValue()!
    }

public var linePos: UInt64 {
jsObject[.linePos].fromJSValue()!
    }

public var offset: UInt64 {
jsObject[.offset].fromJSValue()!
    }

public var length: UInt64 {
jsObject[.length].fromJSValue()!
    }
}

public enum GPUCompilationMessageType: JSString, JSValueCompatible {
    case error = "error"
    case warning = "warning"
    case info = "info"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUComputePassDescriptor: BridgedDictionary {
    public convenience init(timestampWrites: GPUComputePassTimestampWrites) {
        let object = JSObject.global[.Object].function!.new()
        object[.timestampWrites] = _toJSValue(timestampWrites)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }

    public var timestampWrites: GPUComputePassTimestampWrites {
        get { jsObject[.timestampWrites].fromJSValue()!}
        set { jsObject[.timestampWrites] = newValue.jsValue }
    }
}

public class GPUComputePassEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUBindingCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUComputePassEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func setPipeline(pipeline: GPUComputePipeline) {
        let this = jsObject
        _ = this[.setPipeline].function!(this: this, arguments: [_toJSValue(pipeline)])
    }

    @inlinable public func dispatchWorkgroups(workgroupCountX: GPUSize32, workgroupCountY: GPUSize32? = nil, workgroupCountZ: GPUSize32? = nil) {
        let this = jsObject
        _ = this[.dispatchWorkgroups].function!(this: this, arguments: [_toJSValue(workgroupCountX), _toJSValue(workgroupCountY), _toJSValue(workgroupCountZ)])
    }

    @inlinable public func dispatchWorkgroupsIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[.dispatchWorkgroupsIndirect].function!(this: this, arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)])
    }

    @inlinable public func end() {
        let this = jsObject
        _ = this[.end].function!(this: this, arguments: [])
    }
}

public class GPUComputePassTimestampWrites: BridgedDictionary {
    public convenience init(querySet: GPUQuerySet, beginningOfPassWriteIndex: GPUSize32, endOfPassWriteIndex: GPUSize32) {
        let object = JSObject.global[.Object].function!.new()
        object[.querySet] = _toJSValue(querySet)
        object[.beginningOfPassWriteIndex] = _toJSValue(beginningOfPassWriteIndex)
        object[.endOfPassWriteIndex] = _toJSValue(endOfPassWriteIndex)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
       super.init(unsafelyWrapping: object)
    }

    public var querySet: GPUQuerySet {
        get { jsObject[.querySet].fromJSValue()!}
        set { jsObject[.querySet] = newValue.jsValue }
    }

    public var beginningOfPassWriteIndex: GPUSize32 {
        get { jsObject[.beginningOfPassWriteIndex].fromJSValue()!}
        set { jsObject[.beginningOfPassWriteIndex] = newValue.jsValue }
    }

    public var endOfPassWriteIndex: GPUSize32 {
        get { jsObject[.endOfPassWriteIndex].fromJSValue()!}
        set { jsObject[.endOfPassWriteIndex] = newValue.jsValue }
    }
}

public class GPUComputePipeline: JSBridgedClass, GPUObjectBase, GPUPipelineBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUComputePipeline].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUComputePipelineDescriptor: BridgedDictionary {
    public convenience init(compute: GPUProgrammableStage) {
        let object = JSObject.global[.Object].function!.new()
        object[.compute] = _toJSValue(compute)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }

    public var compute: GPUProgrammableStage {
        get { jsObject[.compute].fromJSValue()!}
        set { jsObject[.compute] = newValue.jsValue }
    }
}

public enum GPUCullMode: JSString, JSValueCompatible {
    case none = "none"
    case front = "front"
    case back = "back"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol GPUDebugCommandsMixin: JSBridgedClass {}
public extension GPUDebugCommandsMixin {
    @inlinable func pushDebugGroup(groupLabel: String) {
        let this = jsObject
        _ = this[.pushDebugGroup].function!(this: this, arguments: [_toJSValue(groupLabel)])
    }

    @inlinable func popDebugGroup() {
        let this = jsObject
        _ = this[.popDebugGroup].function!(this: this, arguments: [])
    }

    @inlinable func insertDebugMarker(markerLabel: String) {
        let this = jsObject
        _ = this[.insertDebugMarker].function!(this: this, arguments: [_toJSValue(markerLabel)])
    }
}

public class GPUDepthStencilState: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, depthWriteEnabled: Bool, depthCompare: GPUCompareFunction, stencilFront: GPUStencilFaceState, stencilBack: GPUStencilFaceState, stencilReadMask: GPUStencilValue, stencilWriteMask: GPUStencilValue, depthBias: GPUDepthBias, depthBiasSlopeScale: Float, depthBiasClamp: Float) {
        let object = JSObject.global[.Object].function!.new()
        object[.format] = _toJSValue(format)
        object[.depthWriteEnabled] = _toJSValue(depthWriteEnabled)
        object[.depthCompare] = _toJSValue(depthCompare)
        object[.stencilFront] = _toJSValue(stencilFront)
        object[.stencilBack] = _toJSValue(stencilBack)
        object[.stencilReadMask] = _toJSValue(stencilReadMask)
        object[.stencilWriteMask] = _toJSValue(stencilWriteMask)
        object[.depthBias] = _toJSValue(depthBias)
        object[.depthBiasSlopeScale] = _toJSValue(depthBiasSlopeScale)
        object[.depthBiasClamp] = _toJSValue(depthBiasClamp)
        self.init(unsafelyWrapping: object)
    }

    public var format: GPUTextureFormat {
        get { jsObject[.format].fromJSValue()!}
        set { jsObject[.format] = newValue.jsValue }
    }

    public var depthWriteEnabled: Bool {
        get { jsObject[.depthWriteEnabled].fromJSValue()!}
        set { jsObject[.depthWriteEnabled] = newValue.jsValue }
    }

    public var depthCompare: GPUCompareFunction {
        get { jsObject[.depthCompare].fromJSValue()!}
        set { jsObject[.depthCompare] = newValue.jsValue }
    }

    public var stencilFront: GPUStencilFaceState {
        get { jsObject[.stencilFront].fromJSValue()!}
        set { jsObject[.stencilFront] = newValue.jsValue }
    }

    public var stencilBack: GPUStencilFaceState {
        get { jsObject[.stencilBack].fromJSValue()!}
        set { jsObject[.stencilBack] = newValue.jsValue }
    }

    public var stencilReadMask: GPUStencilValue {
        get { jsObject[.stencilReadMask].fromJSValue()!}
        set { jsObject[.stencilReadMask] = newValue.jsValue }
    }

    public var stencilWriteMask: GPUStencilValue {
        get { jsObject[.stencilWriteMask].fromJSValue()!}
        set { jsObject[.stencilWriteMask] = newValue.jsValue }
    }

    public var depthBias: GPUDepthBias {
        get { jsObject[.depthBias].fromJSValue()!}
        set { jsObject[.depthBias] = newValue.jsValue }
    }

    public var depthBiasSlopeScale: Float {
        get { jsObject[.depthBiasSlopeScale].fromJSValue()!}
        set { jsObject[.depthBiasSlopeScale] = newValue.jsValue }
    }

    public var depthBiasClamp: Float {
        get { jsObject[.depthBiasClamp].fromJSValue()!}
        set { jsObject[.depthBiasClamp] = newValue.jsValue }
    }
}

public class GPUDevice: EventTarget, GPUObjectBase {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUDevice].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
       _onuncapturederror = ClosureAttribute1Optional(jsObject: jsObject, name: .onuncapturederror)
        super.init(unsafelyWrapping: jsObject)
    }

public var features: GPUSupportedFeatures {
jsObject[.features].fromJSValue()!
    }

public var limits: GPUSupportedLimits {
jsObject[.limits].fromJSValue()!
    }

public var queue: GPUQueue {
jsObject[.queue].fromJSValue()!
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[.destroy].function!(this: this, arguments: [])
    }

    @inlinable public func createBuffer(descriptor: GPUBufferDescriptor) -> GPUBuffer {
        let this = jsObject
        return this[.createBuffer].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createTexture(descriptor: GPUTextureDescriptor) -> GPUTexture {
        let this = jsObject
        return this[.createTexture].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createSampler(descriptor: GPUSamplerDescriptor? = nil) -> GPUSampler {
        let this = jsObject
        return this[.createSampler].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func importExternalTexture(descriptor: GPUExternalTextureDescriptor) -> GPUExternalTexture {
        let this = jsObject
        return this[.importExternalTexture].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createBindGroupLayout(descriptor: GPUBindGroupLayoutDescriptor) -> GPUBindGroupLayout {
        let this = jsObject
        return this[.createBindGroupLayout].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createPipelineLayout(descriptor: GPUPipelineLayoutDescriptor) -> GPUPipelineLayout {
        let this = jsObject
        return this[.createPipelineLayout].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createBindGroup(descriptor: GPUBindGroupDescriptor) -> GPUBindGroup {
        let this = jsObject
        return this[.createBindGroup].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createShaderModule(descriptor: GPUShaderModuleDescriptor) -> GPUShaderModule {
        let this = jsObject
        return this[.createShaderModule].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createComputePipeline(descriptor: GPUComputePipelineDescriptor) -> GPUComputePipeline {
        let this = jsObject
        return this[.createComputePipeline].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createRenderPipeline(descriptor: GPURenderPipelineDescriptor) -> GPURenderPipeline {
        let this = jsObject
        return this[.createRenderPipeline].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createComputePipelineAsync(descriptor: GPUComputePipelineDescriptor) -> JSPromise {
        let this = jsObject
        return this[.createComputePipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func createComputePipelineAsync(descriptor: GPUComputePipelineDescriptor) async throws -> GPUComputePipeline {
        let this = jsObject
        let _promise: JSPromise = this[.createComputePipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func createRenderPipelineAsync(descriptor: GPURenderPipelineDescriptor) -> JSPromise {
        let this = jsObject
        return this[.createRenderPipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func createRenderPipelineAsync(descriptor: GPURenderPipelineDescriptor) async throws -> GPURenderPipeline {
        let this = jsObject
        let _promise: JSPromise = this[.createRenderPipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func createCommandEncoder(descriptor: GPUCommandEncoderDescriptor? = nil) -> GPUCommandEncoder {
        let this = jsObject
        return this[.createCommandEncoder].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createRenderBundleEncoder(descriptor: GPURenderBundleEncoderDescriptor) -> GPURenderBundleEncoder {
        let this = jsObject
        return this[.createRenderBundleEncoder].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func createQuerySet(descriptor: GPUQuerySetDescriptor) -> GPUQuerySet {
        let this = jsObject
        return this[.createQuerySet].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

public var lost: JSPromise {
jsObject[.lost].fromJSValue()!
    }

    @inlinable public func pushErrorScope(filter: GPUErrorFilter) {
        let this = jsObject
        _ = this[.pushErrorScope].function!(this: this, arguments: [_toJSValue(filter)])
    }

    @inlinable public func popErrorScope() -> JSPromise {
        let this = jsObject
        return this[.popErrorScope].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func popErrorScope() async throws -> GPUError? {
        let this = jsObject
        let _promise: JSPromise = this[.popErrorScope].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()
    }

    @ClosureAttribute1Optional
    public var onuncapturederror: EventHandler
}

public class GPUDeviceDescriptor: BridgedDictionary {
    public convenience init(requiredFeatures: [GPUFeatureName], requiredLimits: [String: GPUSize64], defaultQueue: GPUQueueDescriptor) {
        let object = JSObject.global[.Object].function!.new()
        object[.requiredFeatures] = _toJSValue(requiredFeatures)
        object[.requiredLimits] = _toJSValue(requiredLimits)
        object[.defaultQueue] = _toJSValue(defaultQueue)
        self.init(unsafelyWrapping: object)
    }

    public var requiredFeatures: [GPUFeatureName] {
        get { jsObject[.requiredFeatures].fromJSValue()!}
        set { jsObject[.requiredFeatures] = newValue.jsValue }
    }

    public var requiredLimits: [String: GPUSize64] {
        get { jsObject[.requiredLimits].fromJSValue()!}
        set { jsObject[.requiredLimits] = newValue.jsValue }
    }

    public var defaultQueue: GPUQueueDescriptor {
        get { jsObject[.defaultQueue].fromJSValue()!}
        set { jsObject[.defaultQueue] = newValue.jsValue }
    }
}

public class GPUDeviceLostInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUDeviceLostInfo].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

public var reason: GPUDeviceLostReason {
jsObject[.reason].fromJSValue()!
    }

public var message: String {
jsObject[.message].fromJSValue()!
    }
}

public enum GPUDeviceLostReason: JSString, JSValueCompatible {
    case unknown = "unknown"
    case destroyed = "destroyed"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUError: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUError].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

public var message: String {
jsObject[.message].fromJSValue()!
    }
}

public enum GPUErrorFilter: JSString, JSValueCompatible {
    case validation = "validation"
    case outOfMemory = "out-of-memory"
    case `internal` = "internal"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUExtent3DDict: BridgedDictionary {
    public convenience init(width: GPUIntegerCoordinate, height: GPUIntegerCoordinate, depthOrArrayLayers: GPUIntegerCoordinate) {
        let object = JSObject.global[.Object].function!.new()
        object[.width] = _toJSValue(width)
        object[.height] = _toJSValue(height)
        object[.depthOrArrayLayers] = _toJSValue(depthOrArrayLayers)
        self.init(unsafelyWrapping: object)
    }

    public var width: GPUIntegerCoordinate {
        get { jsObject[.width].fromJSValue()!}
        set { jsObject[.width] = newValue.jsValue }
    }

    public var height: GPUIntegerCoordinate {
        get { jsObject[.height].fromJSValue()!}
        set { jsObject[.height] = newValue.jsValue }
    }

    public var depthOrArrayLayers: GPUIntegerCoordinate {
        get { jsObject[.depthOrArrayLayers].fromJSValue()!}
        set { jsObject[.depthOrArrayLayers] = newValue.jsValue }
    }
}

public class GPUExternalTexture: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUExternalTexture].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUExternalTextureBindingLayout: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPUExternalTextureDescriptor: BridgedDictionary {
    public convenience init(source: HTMLVideoElement_or_VideoFrame, colorSpace: PredefinedColorSpace) {
        let object = JSObject.global[.Object].function!.new()
        object[.source] = _toJSValue(source)
        object[.colorSpace] = _toJSValue(colorSpace)
        self.init(unsafelyWrapping: object)
    }

    public var source: HTMLVideoElement_or_VideoFrame {
        get { jsObject[.source].fromJSValue()!}
        set { jsObject[.source] = newValue.jsValue }
    }

    public var colorSpace: PredefinedColorSpace {
        get { jsObject[.colorSpace].fromJSValue()!}
        set { jsObject[.colorSpace] = newValue.jsValue }
    }
}

public enum GPUFeatureName: JSString, JSValueCompatible {
    case depthClipControl = "depth-clip-control"
    case depth32floatStencil8 = "depth32float-stencil8"
    case textureCompressionBc = "texture-compression-bc"
    case textureCompressionEtc2 = "texture-compression-etc2"
    case textureCompressionAstc = "texture-compression-astc"
    case timestampQuery = "timestamp-query"
    case indirectFirstInstance = "indirect-first-instance"
    case shaderF16 = "shader-f16"
    case rg11b10ufloatRenderable = "rg11b10ufloat-renderable"
    case bgra8unormStorage = "bgra8unorm-storage"
    case float32Filterable = "float32-filterable"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUFilterMode: JSString, JSValueCompatible {
    case nearest = "nearest"
    case linear = "linear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUFragmentState: BridgedDictionary {
    public convenience init(targets: [GPUColorTargetState?]) {
        let object = JSObject.global[.Object].function!.new()
        object[.targets] = _toJSValue(targets)
        self.init(unsafelyWrapping: object)
    }

    // TODO: fixme
    public var targets: [GPUColorTargetState?] {
        get { jsObject[.targets].fromJSValue()!}
        set { jsObject[.targets] = newValue.jsValue }
    }
}

public enum GPUFrontFace: JSString, JSValueCompatible {
    case ccw = "ccw"
    case cw = "cw"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUImageCopyBuffer: BridgedDictionary {
    public convenience init(buffer: GPUBuffer) {
        let object = JSObject.global[.Object].function!.new()
        object[.buffer] = _toJSValue(buffer)
        self.init(unsafelyWrapping: object)
    }

    public var buffer: GPUBuffer {
        get { jsObject[.buffer].fromJSValue()!}
        set { jsObject[.buffer] = newValue.jsValue }
    }
}

public class GPUImageCopyExternalImage: BridgedDictionary {
    public convenience init(source: GPUImageCopyExternalImageSource, origin: GPUOrigin2D, flipY: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.source] = _toJSValue(source)
        object[.origin] = _toJSValue(origin)
        object[.flipY] = _toJSValue(flipY)
        self.init(unsafelyWrapping: object)
    }

    public var source: GPUImageCopyExternalImageSource {
        get { jsObject[.source].fromJSValue()!}
        set { jsObject[.source] = newValue.jsValue }
    }

    public var origin: GPUOrigin2D {
        get { jsObject[.origin].fromJSValue()!}
        set { jsObject[.origin] = newValue.jsValue }
    }

    public var flipY: Bool {
        get { jsObject[.flipY].fromJSValue()!}
        set { jsObject[.flipY] = newValue.jsValue }
    }
}

public class GPUImageCopyTexture: BridgedDictionary {
    public convenience init(texture: GPUTexture, mipLevel: GPUIntegerCoordinate, origin: GPUOrigin3D, aspect: GPUTextureAspect) {
        let object = JSObject.global[.Object].function!.new()
        object[.texture] = _toJSValue(texture)
        object[.mipLevel] = _toJSValue(mipLevel)
        object[.origin] = _toJSValue(origin)
        object[.aspect] = _toJSValue(aspect)
        self.init(unsafelyWrapping: object)
    }

    public var texture: GPUTexture {
        get { jsObject[.texture].fromJSValue()!}
        set { jsObject[.texture] = newValue.jsValue }
    }

    public var mipLevel: GPUIntegerCoordinate {
        get { jsObject[.mipLevel].fromJSValue()!}
        set { jsObject[.mipLevel] = newValue.jsValue }
    }

    public var origin: GPUOrigin3D {
        get { jsObject[.origin].fromJSValue()!}
        set { jsObject[.origin] = newValue.jsValue }
    }

    public var aspect: GPUTextureAspect {
        get { jsObject[.aspect].fromJSValue()!}
        set { jsObject[.aspect] = newValue.jsValue }
    }
}

public class GPUImageCopyTextureTagged: BridgedDictionary {
    public convenience init(colorSpace: PredefinedColorSpace, premultipliedAlpha: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.colorSpace] = _toJSValue(colorSpace)
        object[.premultipliedAlpha] = _toJSValue(premultipliedAlpha)
        self.init(unsafelyWrapping: object)
    }

    public var colorSpace: PredefinedColorSpace {
        get { jsObject[.colorSpace].fromJSValue()!}
        set { jsObject[.colorSpace] = newValue.jsValue }
    }

    public var premultipliedAlpha: Bool {
        get { jsObject[.premultipliedAlpha].fromJSValue()!}
        set { jsObject[.premultipliedAlpha] = newValue.jsValue }
    }
}

public class GPUImageDataLayout: BridgedDictionary {
    public convenience init(offset: GPUSize64, bytesPerRow: GPUSize32, rowsPerImage: GPUSize32) {
        let object = JSObject.global[.Object].function!.new()
        object[.offset] = _toJSValue(offset)
        object[.bytesPerRow] = _toJSValue(bytesPerRow)
        object[.rowsPerImage] = _toJSValue(rowsPerImage)
        self.init(unsafelyWrapping: object)
    }
    
    public var offset: GPUSize64 {
        get { jsObject[.offset].fromJSValue()!}
        set { jsObject[.offset] = newValue.jsValue }
    }

    public var bytesPerRow: GPUSize32 {
        get { jsObject[.bytesPerRow].fromJSValue()!}
        set { jsObject[.bytesPerRow] = newValue.jsValue }
    }

    public var rowsPerImage: GPUSize32 {
        get { jsObject[.rowsPerImage].fromJSValue()!}
        set { jsObject[.rowsPerImage] = newValue.jsValue }
    }
}

public enum GPUIndexFormat: JSString, JSValueCompatible {
    case uint16 = "uint16"
    case uint32 = "uint32"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUInternalError: GPUError {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUInternalError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(message: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

public enum GPULoadOp: JSString, JSValueCompatible {
    case load = "load"
    case clear = "clear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUMapMode {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[.GPUMapMode].object!
    }

    public static let READ: GPUFlagsConstant = 0x0001

    public static let WRITE: GPUFlagsConstant = 0x0002
}

public enum GPUMipmapFilterMode: JSString, JSValueCompatible {
    case nearest = "nearest"
    case linear = "linear"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUMultisampleState: BridgedDictionary {
    public convenience init(count: GPUSize32, mask: GPUSampleMask, alphaToCoverageEnabled: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.count] = _toJSValue(count)
        object[.mask] = _toJSValue(mask)
        object[.alphaToCoverageEnabled] = _toJSValue(alphaToCoverageEnabled)
        self.init(unsafelyWrapping: object)
    }
    
    public var count: GPUSize32 {
        get { jsObject[.count].fromJSValue()!}
        set { jsObject[.count] = newValue.jsValue }
    }

    public var mask: GPUSampleMask {
        get { jsObject[.mask].fromJSValue()!}
        set { jsObject[.mask] = newValue.jsValue }
    }

    public var alphaToCoverageEnabled: Bool {
        get { jsObject[.alphaToCoverageEnabled].fromJSValue()!}
        set { jsObject[.alphaToCoverageEnabled] = newValue.jsValue }
    }
}

public protocol GPUObjectBase: JSBridgedClass {}
public extension GPUObjectBase {
    @inlinable var label: String {
        get { jsObject[.label].fromJSValue()! }
        nonmutating set { jsObject[.label] = _toJSValue(newValue) }
    }
}

public class GPUObjectDescriptorBase: BridgedDictionary {
    public convenience init(label: String) {
        let object = JSObject.global[.Object].function!.new()
        object[.label] = _toJSValue(label)
        self.init(unsafelyWrapping: object)
    }

    public var label: String {
        get { jsObject[.label].fromJSValue()!}
        set { jsObject[.label] = newValue.jsValue }
    }
}

public class GPUOrigin2DDict: BridgedDictionary {
    public convenience init(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate) {
        let object = JSObject.global[.Object].function!.new()
        object[.x] = _toJSValue(x)
        object[.y] = _toJSValue(y)
        self.init(unsafelyWrapping: object)
    }
    
    public var x: GPUIntegerCoordinate {
        get { jsObject[.x].fromJSValue()!}
        set { jsObject[.x] = newValue.jsValue }
    }

    public var y: GPUIntegerCoordinate {
        get { jsObject[.y].fromJSValue()!}
        set { jsObject[.y] = newValue.jsValue }
    }
}

public class GPUOrigin3DDict: BridgedDictionary {
    public convenience init(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate, z: GPUIntegerCoordinate) {
        let object = JSObject.global[.Object].function!.new()
        object[.x] = _toJSValue(x)
        object[.y] = _toJSValue(y)
        object[.z] = _toJSValue(z)
        self.init(unsafelyWrapping: object)
    }
    
    public var x: GPUIntegerCoordinate {
        get { jsObject[.x].fromJSValue()!}
        set { jsObject[.x] = newValue.jsValue }
    }

    public var y: GPUIntegerCoordinate {
        get { jsObject[.y].fromJSValue()!}
        set { jsObject[.y] = newValue.jsValue }
    }

    public var z: GPUIntegerCoordinate {
        get { jsObject[.z].fromJSValue()!}
        set { jsObject[.z] = newValue.jsValue }
    }
}

public class GPUOutOfMemoryError: GPUError {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUOutOfMemoryError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(message: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

public protocol GPUPipelineBase: JSBridgedClass {}
public extension GPUPipelineBase {
    @inlinable func getBindGroupLayout(index: UInt32) -> GPUBindGroupLayout {
        let this = jsObject
        return this[.getBindGroupLayout].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
}

public class GPUPipelineDescriptorBase: BridgedDictionary {
    public convenience init(layout: GPUAutoLayoutMode_or_GPUPipelineLayout) {
        let object = JSObject.global[.Object].function!.new()
        object[.layout] = _toJSValue(layout)
        self.init(unsafelyWrapping: object)
    }
    
    public var layout: GPUAutoLayoutMode_or_GPUPipelineLayout {
        get { jsObject[.layout].fromJSValue()!}
        set { jsObject[.layout] = newValue.jsValue }
    }
}

public class GPUPipelineError: DOMException {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUPipelineError].function }

    @inlinable public convenience init(message: String? = nil, options: GPUPipelineErrorInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message), _toJSValue(options)]))
    }

public var reason: GPUPipelineErrorReason {
jsObject[.reason].fromJSValue()!
    }
}

public class GPUPipelineErrorInit: BridgedDictionary {
    public convenience init(reason: GPUPipelineErrorReason) {
        let object = JSObject.global[.Object].function!.new()
        object[.reason] = _toJSValue(reason)
        self.init(unsafelyWrapping: object)
    }
    
    public var reason: GPUPipelineErrorReason {
        get { jsObject[.reason].fromJSValue()!}
        set { jsObject[.reason] = newValue.jsValue }
    }
}

public enum GPUPipelineErrorReason: JSString, JSValueCompatible {
    case validation = "validation"
    case `internal` = "internal"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUPipelineLayout: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUPipelineLayout].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUPipelineLayoutDescriptor: BridgedDictionary {
    public convenience init(bindGroupLayouts: [GPUBindGroupLayout]) {
        let object = JSObject.global[.Object].function!.new()
        object[.bindGroupLayouts] = _toJSValue(bindGroupLayouts)
        self.init(unsafelyWrapping: object)
    }

    public var bindGroupLayouts: [GPUBindGroupLayout] {
        get { jsObject[.bindGroupLayouts].fromJSValue()!}
        set { jsObject[.bindGroupLayouts] = newValue.jsValue }
    }
}

public enum GPUPowerPreference: JSString, JSValueCompatible {
    case lowPower = "low-power"
    case highPerformance = "high-performance"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUPrimitiveState: BridgedDictionary {
    public convenience init(topology: GPUPrimitiveTopology, stripIndexFormat: GPUIndexFormat, frontFace: GPUFrontFace, cullMode: GPUCullMode, unclippedDepth: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.topology] = _toJSValue(topology)
        object[.stripIndexFormat] = _toJSValue(stripIndexFormat)
        object[.frontFace] = _toJSValue(frontFace)
        object[.cullMode] = _toJSValue(cullMode)
        object[.unclippedDepth] = _toJSValue(unclippedDepth)
        self.init(unsafelyWrapping: object)
    }
    
    public var topology: GPUPrimitiveTopology {
        get { jsObject[.topology].fromJSValue()!}
        set { jsObject[.topology] = newValue.jsValue }
    }

    public var stripIndexFormat: GPUIndexFormat {
        get { jsObject[.stripIndexFormat].fromJSValue()!}
        set { jsObject[.stripIndexFormat] = newValue.jsValue }
    }

    public var frontFace: GPUFrontFace {
        get { jsObject[.frontFace].fromJSValue()!}
        set { jsObject[.frontFace] = newValue.jsValue }
    }

    public var cullMode: GPUCullMode {
        get { jsObject[.cullMode].fromJSValue()!}
        set { jsObject[.cullMode] = newValue.jsValue }
    }

    public var unclippedDepth: Bool {
        get { jsObject[.unclippedDepth].fromJSValue()!}
        set { jsObject[.unclippedDepth] = newValue.jsValue }
    }
}

public enum GPUPrimitiveTopology: JSString, JSValueCompatible {
    case pointList = "point-list"
    case lineList = "line-list"
    case lineStrip = "line-strip"
    case triangleList = "triangle-list"
    case triangleStrip = "triangle-strip"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUProgrammableStage: BridgedDictionary {
    public convenience init(module: GPUShaderModule, entryPoint: String, constants: [String: GPUPipelineConstantValue]) {
        let object = JSObject.global[.Object].function!.new()
        object[.module] = _toJSValue(module)
        object[.entryPoint] = _toJSValue(entryPoint)
        object[.constants] = _toJSValue(constants)
        self.init(unsafelyWrapping: object)
    }
    public var module: GPUShaderModule {
        get { jsObject[.module].fromJSValue()!}
        set { jsObject[.module] = newValue.jsValue }
    }

    public var entryPoint: String {
        get { jsObject[.entryPoint].fromJSValue()!}
        set { jsObject[.entryPoint] = newValue.jsValue }
    }

    public var constants: [String: GPUPipelineConstantValue] {
        get { jsObject[.constants].fromJSValue()!}
        set { jsObject[.constants] = newValue.jsValue }
    }
}

public class GPUQuerySet: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUQuerySet].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public func destroy() {
        let this = jsObject
        _ = this[.destroy].function!(this: this, arguments: [])
    }

public var type: GPUQueryType {
jsObject[.type].fromJSValue()!
    }

public var count: GPUSize32Out {
jsObject[.count].fromJSValue()!
    }
}

public class GPUQuerySetDescriptor: BridgedDictionary {
    public convenience init(type: GPUQueryType, count: GPUSize32) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.count] = _toJSValue(count)
        self.init(unsafelyWrapping: object)
    }
    
    public var type: GPUQueryType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }

    public var count: GPUSize32 {
        get { jsObject[.count].fromJSValue()!}
        set { jsObject[.count] = newValue.jsValue }
    }
}

public enum GPUQueryType: JSString, JSValueCompatible {
    case occlusion = "occlusion"
    case timestamp = "timestamp"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUQueue: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUQueue].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func submit(commandBuffers: [GPUCommandBuffer]) {
        let this = jsObject
        _ = this[.submit].function!(this: this, arguments: [_toJSValue(commandBuffers)])
    }

    @inlinable public func onSubmittedWorkDone() -> JSPromise {
        let this = jsObject
        return this[.onSubmittedWorkDone].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func onSubmittedWorkDone() async throws {
        let this = jsObject
        let _promise: JSPromise = this[.onSubmittedWorkDone].function!(this: this, arguments: []).fromJSValue()!
        _ = try await _promise.value
    }

    @inlinable public func writeBuffer(buffer: GPUBuffer, bufferOffset: GPUSize64, data: AllowSharedBufferSource, dataOffset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[.writeBuffer].function!(this: this, arguments: [_toJSValue(buffer), _toJSValue(bufferOffset), _toJSValue(data), _toJSValue(dataOffset), _toJSValue(size)])
    }

    @inlinable public func writeTexture(destination: GPUImageCopyTexture, data: AllowSharedBufferSource, dataLayout: GPUImageDataLayout, size: GPUExtent3D) {
        let this = jsObject
        _ = this[.writeTexture].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(data), _toJSValue(dataLayout), _toJSValue(size)])
    }

    @inlinable public func copyExternalImageToTexture(source: GPUImageCopyExternalImage, destination: GPUImageCopyTextureTagged, copySize: GPUExtent3D) {
        let this = jsObject
        _ = this[.copyExternalImageToTexture].function!(this: this, arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)])
    }
}

public class GPUQueueDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPURenderBundle: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPURenderBundle].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPURenderBundleDescriptor: BridgedDictionary {
    public convenience init() {
        let object = JSObject.global[.Object].function!.new()

        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        super.init(unsafelyWrapping: object)
    }
}

public class GPURenderBundleEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUBindingCommandsMixin, GPURenderCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPURenderBundleEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func finish(descriptor: GPURenderBundleDescriptor? = nil) -> GPURenderBundle {
        let this = jsObject
        return this[.finish].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }
}

public class GPURenderBundleEncoderDescriptor: BridgedDictionary {
    public convenience init(depthReadOnly: Bool, stencilReadOnly: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.depthReadOnly] = _toJSValue(depthReadOnly)
        object[.stencilReadOnly] = _toJSValue(stencilReadOnly)
        self.init(unsafelyWrapping: object)
    }
    
    public var depthReadOnly: Bool {
        get { jsObject[.depthReadOnly].fromJSValue()!}
        set { jsObject[.depthReadOnly] = newValue.jsValue }
    }

    public var stencilReadOnly: Bool {
        get { jsObject[.stencilReadOnly].fromJSValue()!}
        set { jsObject[.stencilReadOnly] = newValue.jsValue }
    }
}

public protocol GPURenderCommandsMixin: JSBridgedClass {}
public extension GPURenderCommandsMixin {
    @inlinable func setPipeline(pipeline: GPURenderPipeline) {
        let this = jsObject
        _ = this[.setPipeline].function!(this: this, arguments: [_toJSValue(pipeline)])
    }

    @inlinable func setIndexBuffer(buffer: GPUBuffer, indexFormat: GPUIndexFormat, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[.setIndexBuffer].function!(this: this, arguments: [_toJSValue(buffer), _toJSValue(indexFormat), _toJSValue(offset), _toJSValue(size)])
    }

    @inlinable func setVertexBuffer(slot: GPUIndex32, buffer: GPUBuffer?, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        let this = jsObject
        _ = this[.setVertexBuffer].function!(this: this, arguments: [_toJSValue(slot), _toJSValue(buffer), _toJSValue(offset), _toJSValue(size)])
    }

    @inlinable func draw(vertexCount: GPUSize32, instanceCount: GPUSize32? = nil, firstVertex: GPUSize32? = nil, firstInstance: GPUSize32? = nil) {
        let this = jsObject
        _ = this[.draw].function!(this: this, arguments: [_toJSValue(vertexCount), _toJSValue(instanceCount), _toJSValue(firstVertex), _toJSValue(firstInstance)])
    }

    @inlinable func drawIndexed(indexCount: GPUSize32, instanceCount: GPUSize32? = nil, firstIndex: GPUSize32? = nil, baseVertex: GPUSignedOffset32? = nil, firstInstance: GPUSize32? = nil) {
        let this = jsObject
        _ = this[.drawIndexed].function!(this: this, arguments: [_toJSValue(indexCount), _toJSValue(instanceCount), _toJSValue(firstIndex), _toJSValue(baseVertex), _toJSValue(firstInstance)])
    }

    @inlinable func drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[.drawIndirect].function!(this: this, arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)])
    }

    @inlinable func drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        let this = jsObject
        _ = this[.drawIndexedIndirect].function!(this: this, arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)])
    }
}

public class GPURenderPassColorAttachment: BridgedDictionary {
    public convenience init(view: GPUTextureView, resolveTarget: GPUTextureView, clearValue: GPUColor, loadOp: GPULoadOp, storeOp: GPUStoreOp) {
        let object = JSObject.global[.Object].function!.new()
        object[.view] = _toJSValue(view)
        object[.resolveTarget] = _toJSValue(resolveTarget)
        object[.clearValue] = _toJSValue(clearValue)
        object[.loadOp] = _toJSValue(loadOp)
        object[.storeOp] = _toJSValue(storeOp)
        self.init(unsafelyWrapping: object)
    }

    public var view: GPUTextureView {
        get { jsObject[.view].fromJSValue()!}
        set { jsObject[.view] = newValue.jsValue }
    }

    public var resolveTarget: GPUTextureView {
        get { jsObject[.resolveTarget].fromJSValue()!}
        set { jsObject[.resolveTarget] = newValue.jsValue }
    }

    public var clearValue: GPUColor {
        get { jsObject[.clearValue].fromJSValue()!}
        set { jsObject[.clearValue] = newValue.jsValue }
    }

    public var loadOp: GPULoadOp {
        get { jsObject[.loadOp].fromJSValue()!}
        set { jsObject[.loadOp] = newValue.jsValue }
    }

    public var storeOp: GPUStoreOp {
        get { jsObject[.storeOp].fromJSValue()!}
        set { jsObject[.storeOp] = newValue.jsValue }
    }
}

public class GPURenderPassDepthStencilAttachment: BridgedDictionary {
    public convenience init(view: GPUTextureView, depthClearValue: Float, depthLoadOp: GPULoadOp, depthStoreOp: GPUStoreOp, depthReadOnly: Bool, stencilClearValue: GPUStencilValue, stencilLoadOp: GPULoadOp, stencilStoreOp: GPUStoreOp, stencilReadOnly: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.view] = _toJSValue(view)
        object[.depthClearValue] = _toJSValue(depthClearValue)
        object[.depthLoadOp] = _toJSValue(depthLoadOp)
        object[.depthStoreOp] = _toJSValue(depthStoreOp)
        object[.depthReadOnly] = _toJSValue(depthReadOnly)
        object[.stencilClearValue] = _toJSValue(stencilClearValue)
        object[.stencilLoadOp] = _toJSValue(stencilLoadOp)
        object[.stencilStoreOp] = _toJSValue(stencilStoreOp)
        object[.stencilReadOnly] = _toJSValue(stencilReadOnly)
        self.init(unsafelyWrapping: object)
    }

    public var view: GPUTextureView {
        get { jsObject[.view].fromJSValue()!}
        set { jsObject[.view] = newValue.jsValue }
    }

    public var depthClearValue: Float {
        get { jsObject[.depthClearValue].fromJSValue()!}
        set { jsObject[.depthClearValue] = newValue.jsValue }
    }

    public var depthLoadOp: GPULoadOp {
        get { jsObject[.depthLoadOp].fromJSValue()!}
        set { jsObject[.depthLoadOp] = newValue.jsValue }
    }

    public var depthStoreOp: GPUStoreOp {
        get { jsObject[.depthStoreOp].fromJSValue()!}
        set { jsObject[.depthStoreOp] = newValue.jsValue }
    }

    public var depthReadOnly: Bool {
        get { jsObject[.depthReadOnly].fromJSValue()!}
        set { jsObject[.depthReadOnly] = newValue.jsValue }
    }

    public var stencilClearValue: GPUStencilValue {
        get { jsObject[.stencilClearValue].fromJSValue()!}
        set { jsObject[.stencilClearValue] = newValue.jsValue }
    }

    public var stencilLoadOp: GPULoadOp {
        get { jsObject[.stencilLoadOp].fromJSValue()!}
        set { jsObject[.stencilLoadOp] = newValue.jsValue }
    }

    public var stencilStoreOp: GPUStoreOp {
        get { jsObject[.stencilStoreOp].fromJSValue()!}
        set { jsObject[.stencilStoreOp] = newValue.jsValue }
    }

    public var stencilReadOnly: Bool {
        get { jsObject[.stencilReadOnly].fromJSValue()!}
        set { jsObject[.stencilReadOnly] = newValue.jsValue }
    }
}

public class GPURenderPassDescriptor: BridgedDictionary {
    public convenience init(colorAttachments: [GPURenderPassColorAttachment?], depthStencilAttachment: GPURenderPassDepthStencilAttachment, occlusionQuerySet: GPUQuerySet, timestampWrites: GPURenderPassTimestampWrites, maxDrawCount: GPUSize64) {
        let object = JSObject.global[.Object].function!.new()
        object[.colorAttachments] = _toJSValue(colorAttachments)
        object[.depthStencilAttachment] = _toJSValue(depthStencilAttachment)
        object[.occlusionQuerySet] = _toJSValue(occlusionQuerySet)
        object[.timestampWrites] = _toJSValue(timestampWrites)
        object[.maxDrawCount] = _toJSValue(maxDrawCount)
        self.init(unsafelyWrapping: object)
    }

    // TODO: fixme
    public var colorAttachments: [GPURenderPassColorAttachment?] {
        get { jsObject[.colorAttachments].fromJSValue()!}
        set { jsObject[.colorAttachments] = newValue.jsValue }
    }

    public var depthStencilAttachment: GPURenderPassDepthStencilAttachment {
        get { jsObject[.depthStencilAttachment].fromJSValue()!}
        set { jsObject[.depthStencilAttachment] = newValue.jsValue }
    }

    public var occlusionQuerySet: GPUQuerySet {
        get { jsObject[.occlusionQuerySet].fromJSValue()!}
        set { jsObject[.occlusionQuerySet] = newValue.jsValue }
    }

    public var timestampWrites: GPURenderPassTimestampWrites {
        get { jsObject[.timestampWrites].fromJSValue()!}
        set { jsObject[.timestampWrites] = newValue.jsValue }
    }

    public var maxDrawCount: GPUSize64 {
        get { jsObject[.maxDrawCount].fromJSValue()!}
        set { jsObject[.maxDrawCount] = newValue.jsValue }
    }
}

public class GPURenderPassEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin, GPUBindingCommandsMixin, GPURenderCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPURenderPassEncoder].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func setViewport(x: Float, y: Float, width: Float, height: Float, minDepth: Float, maxDepth: Float) {
        let this = jsObject
        _ = this[.setViewport].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height), _toJSValue(minDepth), _toJSValue(maxDepth)])
    }

    @inlinable public func setScissorRect(x: GPUIntegerCoordinate, y: GPUIntegerCoordinate, width: GPUIntegerCoordinate, height: GPUIntegerCoordinate) {
        let this = jsObject
        _ = this[.setScissorRect].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height)])
    }

    @inlinable public func setBlendConstant(color: GPUColor) {
        let this = jsObject
        _ = this[.setBlendConstant].function!(this: this, arguments: [_toJSValue(color)])
    }

    @inlinable public func setStencilReference(reference: GPUStencilValue) {
        let this = jsObject
        _ = this[.setStencilReference].function!(this: this, arguments: [_toJSValue(reference)])
    }

    @inlinable public func beginOcclusionQuery(queryIndex: GPUSize32) {
        let this = jsObject
        _ = this[.beginOcclusionQuery].function!(this: this, arguments: [_toJSValue(queryIndex)])
    }

    @inlinable public func endOcclusionQuery() {
        let this = jsObject
        _ = this[.endOcclusionQuery].function!(this: this, arguments: [])
    }

    @inlinable public func executeBundles(bundles: [GPURenderBundle]) {
        let this = jsObject
        _ = this[.executeBundles].function!(this: this, arguments: [_toJSValue(bundles)])
    }

    @inlinable public func end() {
        let this = jsObject
        _ = this[.end].function!(this: this, arguments: [])
    }
}

public class GPURenderPassLayout: BridgedDictionary {
    public convenience init(colorFormats: [GPUTextureFormat?], depthStencilFormat: GPUTextureFormat, sampleCount: GPUSize32) {
        let object = JSObject.global[.Object].function!.new()
        object[.colorFormats] = _toJSValue(colorFormats)
        object[.depthStencilFormat] = _toJSValue(depthStencilFormat)
        object[.sampleCount] = _toJSValue(sampleCount)
        self.init(unsafelyWrapping: object)
    }
    public var colorFormats: [GPUTextureFormat?] {
        get { jsObject[.colorFormats].fromJSValue()!}
        set { jsObject[.colorFormats] = newValue.jsValue }
    }

    public var depthStencilFormat: GPUTextureFormat {
        get { jsObject[.depthStencilFormat].fromJSValue()!}
        set { jsObject[.depthStencilFormat] = newValue.jsValue }
    }

    public var sampleCount: GPUSize32 {
        get { jsObject[.sampleCount].fromJSValue()!}
        set { jsObject[.sampleCount] = newValue.jsValue }
    }
}

public class GPURenderPassTimestampWrites: BridgedDictionary {
    public convenience init(querySet: GPUQuerySet, beginningOfPassWriteIndex: GPUSize32, endOfPassWriteIndex: GPUSize32) {
        let object = JSObject.global[.Object].function!.new()
        object[.querySet] = _toJSValue(querySet)
        object[.beginningOfPassWriteIndex] = _toJSValue(beginningOfPassWriteIndex)
        object[.endOfPassWriteIndex] = _toJSValue(endOfPassWriteIndex)
        self.init(unsafelyWrapping: object)
    }
    
    public var querySet: GPUQuerySet {
        get { jsObject[.querySet].fromJSValue()!}
        set { jsObject[.querySet] = newValue.jsValue }
    }

    public var beginningOfPassWriteIndex: GPUSize32 {
        get { jsObject[.beginningOfPassWriteIndex].fromJSValue()!}
        set { jsObject[.beginningOfPassWriteIndex] = newValue.jsValue }
    }

    public var endOfPassWriteIndex: GPUSize32 {
        get { jsObject[.endOfPassWriteIndex].fromJSValue()!}
        set { jsObject[.endOfPassWriteIndex] = newValue.jsValue }
    }
}

public class GPURenderPipeline: JSBridgedClass, GPUObjectBase, GPUPipelineBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPURenderPipeline].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPURenderPipelineDescriptor: BridgedDictionary {
    public convenience init(vertex: GPUVertexState, primitive: GPUPrimitiveState, depthStencil: GPUDepthStencilState, multisample: GPUMultisampleState, fragment: GPUFragmentState) {
        let object = JSObject.global[.Object].function!.new()
        object[.vertex] = _toJSValue(vertex)
        object[.primitive] = _toJSValue(primitive)
        object[.depthStencil] = _toJSValue(depthStencil)
        object[.multisample] = _toJSValue(multisample)
        object[.fragment] = _toJSValue(fragment)
        self.init(unsafelyWrapping: object)
    }

    public var vertex: GPUVertexState {
        get { jsObject[.vertex].fromJSValue()!}
        set { jsObject[.vertex] = newValue.jsValue }
    }

    public var primitive: GPUPrimitiveState {
        get { jsObject[.primitive].fromJSValue()!}
        set { jsObject[.primitive] = newValue.jsValue }
    }

    public var depthStencil: GPUDepthStencilState {
        get { jsObject[.depthStencil].fromJSValue()!}
        set { jsObject[.depthStencil] = newValue.jsValue }
    }

    public var multisample: GPUMultisampleState {
        get { jsObject[.multisample].fromJSValue()!}
        set { jsObject[.multisample] = newValue.jsValue }
    }

    public var fragment: GPUFragmentState {
        get { jsObject[.fragment].fromJSValue()!}
        set { jsObject[.fragment] = newValue.jsValue }
    }
}

public class GPURequestAdapterOptions: BridgedDictionary {
    public convenience init(powerPreference: GPUPowerPreference, forceFallbackAdapter: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.powerPreference] = _toJSValue(powerPreference)
        object[.forceFallbackAdapter] = _toJSValue(forceFallbackAdapter)
        self.init(unsafelyWrapping: object)
    }

    public var powerPreference: GPUPowerPreference {
        get { jsObject[.powerPreference].fromJSValue()!}
        set { jsObject[.powerPreference] = newValue.jsValue }
    }

    public var forceFallbackAdapter: Bool {
        get { jsObject[.forceFallbackAdapter].fromJSValue()!}
        set { jsObject[.forceFallbackAdapter] = newValue.jsValue }
    }
}

public class GPUSampler: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUSampler].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUSamplerBindingLayout: BridgedDictionary {
    public convenience init(type: GPUSamplerBindingType) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        self.init(unsafelyWrapping: object)
    }

    public var type: GPUSamplerBindingType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
}

public enum GPUSamplerBindingType: JSString, JSValueCompatible {
    case filtering = "filtering"
    case nonFiltering = "non-filtering"
    case comparison = "comparison"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUSamplerDescriptor: BridgedDictionary {
    public convenience init(addressModeU: GPUAddressMode, addressModeV: GPUAddressMode, addressModeW: GPUAddressMode, magFilter: GPUFilterMode, minFilter: GPUFilterMode, mipmapFilter: GPUMipmapFilterMode, lodMinClamp: Float, lodMaxClamp: Float, compare: GPUCompareFunction, maxAnisotropy: UInt16) {
        let object = JSObject.global[.Object].function!.new()
        object[.addressModeU] = _toJSValue(addressModeU)
        object[.addressModeV] = _toJSValue(addressModeV)
        object[.addressModeW] = _toJSValue(addressModeW)
        object[.magFilter] = _toJSValue(magFilter)
        object[.minFilter] = _toJSValue(minFilter)
        object[.mipmapFilter] = _toJSValue(mipmapFilter)
        object[.lodMinClamp] = _toJSValue(lodMinClamp)
        object[.lodMaxClamp] = _toJSValue(lodMaxClamp)
        object[.compare] = _toJSValue(compare)
        object[.maxAnisotropy] = _toJSValue(maxAnisotropy)
        self.init(unsafelyWrapping: object)
    }
    
    public var addressModeU: GPUAddressMode {
        get { jsObject[.addressModeU].fromJSValue()!}
        set { jsObject[.addressModeU] = newValue.jsValue }
    }

    public var addressModeV: GPUAddressMode {
        get { jsObject[.addressModeV].fromJSValue()!}
        set { jsObject[.addressModeV] = newValue.jsValue }
    }

    public var addressModeW: GPUAddressMode {
        get { jsObject[.addressModeW].fromJSValue()!}
        set { jsObject[.addressModeW] = newValue.jsValue }
    }

    public var magFilter: GPUFilterMode {
        get { jsObject[.magFilter].fromJSValue()!}
        set { jsObject[.magFilter] = newValue.jsValue }
    }

    public var minFilter: GPUFilterMode {
        get { jsObject[.minFilter].fromJSValue()!}
        set { jsObject[.minFilter] = newValue.jsValue }
    }

    public var mipmapFilter: GPUMipmapFilterMode {
        get { jsObject[.mipmapFilter].fromJSValue()!}
        set { jsObject[.mipmapFilter] = newValue.jsValue }
    }

    public var lodMinClamp: Float {
        get { jsObject[.lodMinClamp].fromJSValue()!}
        set { jsObject[.lodMinClamp] = newValue.jsValue }
    }

    public var lodMaxClamp: Float {
        get { jsObject[.lodMaxClamp].fromJSValue()!}
        set { jsObject[.lodMaxClamp] = newValue.jsValue }
    }

    public var compare: GPUCompareFunction {
        get { jsObject[.compare].fromJSValue()!}
        set { jsObject[.compare] = newValue.jsValue }
    }

    public var maxAnisotropy: UInt16 {
        get { jsObject[.maxAnisotropy].fromJSValue()!}
        set { jsObject[.maxAnisotropy] = newValue.jsValue }
    }
}

public class GPUShaderModule: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUShaderModule].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func getCompilationInfo() -> JSPromise {
        let this = jsObject
        return this[.getCompilationInfo].function!(this: this, arguments: []).fromJSValue()!
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getCompilationInfo() async throws -> GPUCompilationInfo {
        let this = jsObject
        let _promise: JSPromise = this[.getCompilationInfo].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public class GPUShaderModuleCompilationHint: BridgedDictionary {
    public convenience init(layout: GPUAutoLayoutMode_or_GPUPipelineLayout) {
        let object = JSObject.global[.Object].function!.new()
        object[.layout] = _toJSValue(layout)
        self.init(unsafelyWrapping: object)
    }

    public var layout: GPUAutoLayoutMode_or_GPUPipelineLayout {
        get { jsObject[.layout].fromJSValue()!}
        set { jsObject[.layout] = newValue.jsValue }
    }
}

public class GPUShaderModuleDescriptor: BridgedDictionary {
    public convenience init(code: String, sourceMap: JSObject, hints: [String: GPUShaderModuleCompilationHint]) {
        let object = JSObject.global[.Object].function!.new()
        object[.code] = _toJSValue(code)
        object[.sourceMap] = _toJSValue(sourceMap)
        object[.hints] = _toJSValue(hints)
        self.init(unsafelyWrapping: object)
    }

    public var code: String {
        get { jsObject[.code].fromJSValue()!}
        set { jsObject[.code] = newValue.jsValue }
    }

    public var sourceMap: JSObject {
        get { jsObject[.sourceMap].fromJSValue()!}
        set { jsObject[.sourceMap] = newValue.jsValue }
    }

    public var hints: [String: GPUShaderModuleCompilationHint] {
        get { jsObject[.hints].fromJSValue()!}
        set { jsObject[.hints] = newValue.jsValue }
    }
}

public enum GPUShaderStage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[.GPUShaderStage].object!
    }

    public static let VERTEX: GPUFlagsConstant = 0x1

    public static let FRAGMENT: GPUFlagsConstant = 0x2

    public static let COMPUTE: GPUFlagsConstant = 0x4
}

public class GPUStencilFaceState: BridgedDictionary {
    public convenience init(compare: GPUCompareFunction, failOp: GPUStencilOperation, depthFailOp: GPUStencilOperation, passOp: GPUStencilOperation) {
        let object = JSObject.global[.Object].function!.new()
        object[.compare] = _toJSValue(compare)
        object[.failOp] = _toJSValue(failOp)
        object[.depthFailOp] = _toJSValue(depthFailOp)
        object[.passOp] = _toJSValue(passOp)
        self.init(unsafelyWrapping: object)
    }

    public var compare: GPUCompareFunction {
        get { jsObject[.compare].fromJSValue()!}
        set { jsObject[.compare] = newValue.jsValue }
    }

    public var failOp: GPUStencilOperation {
        get { jsObject[.failOp].fromJSValue()!}
        set { jsObject[.failOp] = newValue.jsValue }
    }

    public var depthFailOp: GPUStencilOperation {
        get { jsObject[.depthFailOp].fromJSValue()!}
        set { jsObject[.depthFailOp] = newValue.jsValue }
    }

    public var passOp: GPUStencilOperation {
        get { jsObject[.passOp].fromJSValue()!}
        set { jsObject[.passOp] = newValue.jsValue }
    }
}

public enum GPUStencilOperation: JSString, JSValueCompatible {
    case keep = "keep"
    case zero = "zero"
    case replace = "replace"
    case invert = "invert"
    case incrementClamp = "increment-clamp"
    case decrementClamp = "decrement-clamp"
    case incrementWrap = "increment-wrap"
    case decrementWrap = "decrement-wrap"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUStorageTextureAccess: JSString, JSValueCompatible {
    case writeOnly = "write-only"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUStorageTextureBindingLayout: BridgedDictionary {
    public convenience init(access: GPUStorageTextureAccess, format: GPUTextureFormat, viewDimension: GPUTextureViewDimension) {
        let object = JSObject.global[.Object].function!.new()
        object[.access] = _toJSValue(access)
        object[.format] = _toJSValue(format)
        object[.viewDimension] = _toJSValue(viewDimension)
        self.init(unsafelyWrapping: object)
    }
    
    public var access: GPUStorageTextureAccess {
        get { jsObject[.access].fromJSValue()!}
        set { jsObject[.access] = newValue.jsValue }
    }

    public var format: GPUTextureFormat {
        get { jsObject[.format].fromJSValue()!}
        set { jsObject[.format] = newValue.jsValue }
    }

    public var viewDimension: GPUTextureViewDimension {
        get { jsObject[.viewDimension].fromJSValue()!}
        set { jsObject[.viewDimension] = newValue.jsValue }
    }
}

public enum GPUStoreOp: JSString, JSValueCompatible {
    case store = "store"
    case discard = "discard"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUSupportedFeatures: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUSupportedFeatures].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    // XXX: make me Set-like!
}

public class GPUSupportedLimits: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUSupportedLimits].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

public var maxTextureDimension1D: UInt32 {
jsObject[.maxTextureDimension1D].fromJSValue()!
    }

public var maxTextureDimension2D: UInt32 {
jsObject[.maxTextureDimension2D].fromJSValue()!
    }

public var maxTextureDimension3D: UInt32 {
jsObject[.maxTextureDimension3D].fromJSValue()!
    }

public var maxTextureArrayLayers: UInt32 {
jsObject[.maxTextureArrayLayers].fromJSValue()!
    }

public var maxBindGroups: UInt32 {
jsObject[.maxBindGroups].fromJSValue()!
    }

public var maxBindGroupsPlusVertexBuffers: UInt32 {
jsObject[.maxBindGroupsPlusVertexBuffers].fromJSValue()!
    }

public var maxBindingsPerBindGroup: UInt32 {
jsObject[.maxBindingsPerBindGroup].fromJSValue()!
    }

public var maxDynamicUniformBuffersPerPipelineLayout: UInt32 {
jsObject[.maxDynamicUniformBuffersPerPipelineLayout].fromJSValue()!
    }

public var maxDynamicStorageBuffersPerPipelineLayout: UInt32 {
jsObject[.maxDynamicStorageBuffersPerPipelineLayout].fromJSValue()!
    }

public var maxSampledTexturesPerShaderStage: UInt32 {
jsObject[.maxSampledTexturesPerShaderStage].fromJSValue()!
    }

public var maxSamplersPerShaderStage: UInt32 {
jsObject[.maxSamplersPerShaderStage].fromJSValue()!
    }

public var maxStorageBuffersPerShaderStage: UInt32 {
jsObject[.maxStorageBuffersPerShaderStage].fromJSValue()!
    }

public var maxStorageTexturesPerShaderStage: UInt32 {
jsObject[.maxStorageTexturesPerShaderStage].fromJSValue()!
    }

public var maxUniformBuffersPerShaderStage: UInt32 {
jsObject[.maxUniformBuffersPerShaderStage].fromJSValue()!
    }

public var maxUniformBufferBindingSize: UInt64 {
jsObject[.maxUniformBufferBindingSize].fromJSValue()!
    }

public var maxStorageBufferBindingSize: UInt64 {
jsObject[.maxStorageBufferBindingSize].fromJSValue()!
    }

public var minUniformBufferOffsetAlignment: UInt32 {
jsObject[.minUniformBufferOffsetAlignment].fromJSValue()!
    }

public var minStorageBufferOffsetAlignment: UInt32 {
jsObject[.minStorageBufferOffsetAlignment].fromJSValue()!
    }

public var maxVertexBuffers: UInt32 {
jsObject[.maxVertexBuffers].fromJSValue()!
    }

public var maxBufferSize: UInt64 {
jsObject[.maxBufferSize].fromJSValue()!
    }

public var maxVertexAttributes: UInt32 {
jsObject[.maxVertexAttributes].fromJSValue()!
    }

public var maxVertexBufferArrayStride: UInt32 {
jsObject[.maxVertexBufferArrayStride].fromJSValue()!
    }

public var maxInterStageShaderComponents: UInt32 {
jsObject[.maxInterStageShaderComponents].fromJSValue()!
    }

public var maxInterStageShaderVariables: UInt32 {
jsObject[.maxInterStageShaderVariables].fromJSValue()!
    }

public var maxColorAttachments: UInt32 {
jsObject[.maxColorAttachments].fromJSValue()!
    }

public var maxColorAttachmentBytesPerSample: UInt32 {
jsObject[.maxColorAttachmentBytesPerSample].fromJSValue()!
    }

public var maxComputeWorkgroupStorageSize: UInt32 {
jsObject[.maxComputeWorkgroupStorageSize].fromJSValue()!
    }

public var maxComputeInvocationsPerWorkgroup: UInt32 {
jsObject[.maxComputeInvocationsPerWorkgroup].fromJSValue()!
    }

public var maxComputeWorkgroupSizeX: UInt32 {
jsObject[.maxComputeWorkgroupSizeX].fromJSValue()!
    }

public var maxComputeWorkgroupSizeY: UInt32 {
jsObject[.maxComputeWorkgroupSizeY].fromJSValue()!
    }

public var maxComputeWorkgroupSizeZ: UInt32 {
jsObject[.maxComputeWorkgroupSizeZ].fromJSValue()!
    }

public var maxComputeWorkgroupsPerDimension: UInt32 {
jsObject[.maxComputeWorkgroupsPerDimension].fromJSValue()!
    }
}

public class GPUTexture: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUTexture].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }

    @inlinable public func createView(descriptor: GPUTextureViewDescriptor? = nil) -> GPUTextureView {
        let this = jsObject
        return this[.createView].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public func destroy() {
        let this = jsObject
        _ = this[.destroy].function!(this: this, arguments: [])
    }

public var width: GPUIntegerCoordinateOut {
jsObject[.width].fromJSValue()!
    }

public var height: GPUIntegerCoordinateOut {
jsObject[.height].fromJSValue()!
    }

public var depthOrArrayLayers: GPUIntegerCoordinateOut {
jsObject[.depthOrArrayLayers].fromJSValue()!
    }

public var mipLevelCount: GPUIntegerCoordinateOut {
jsObject[.mipLevelCount].fromJSValue()!
    }

public var sampleCount: GPUSize32Out {
jsObject[.sampleCount].fromJSValue()!
    }

public var dimension: GPUTextureDimension {
jsObject[.dimension].fromJSValue()!
    }

public var format: GPUTextureFormat {
jsObject[.format].fromJSValue()!
    }

public var usage: GPUFlagsConstant {
jsObject[.usage].fromJSValue()!
    }
}

public enum GPUTextureAspect: JSString, JSValueCompatible {
    case all = "all"
    case stencilOnly = "stencil-only"
    case depthOnly = "depth-only"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUTextureBindingLayout: BridgedDictionary {
    public convenience init(sampleType: GPUTextureSampleType, viewDimension: GPUTextureViewDimension, multisampled: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.sampleType] = _toJSValue(sampleType)
        object[.viewDimension] = _toJSValue(viewDimension)
        object[.multisampled] = _toJSValue(multisampled)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
       super.init(unsafelyWrapping: object)
    }

    public var sampleType: GPUTextureSampleType {
        get { jsObject[.sampleType].fromJSValue()!}
        set { jsObject[.sampleType] = newValue.jsValue }
    }

    public var viewDimension: GPUTextureViewDimension {
        get { jsObject[.viewDimension].fromJSValue()!}
        set { jsObject[.viewDimension] = newValue.jsValue }
    }

    public var multisampled: Bool {
        get { jsObject[.multisampled].fromJSValue()!}
        set { jsObject[.multisampled] = newValue.jsValue }
    }
}

public class GPUTextureDescriptor: BridgedDictionary {
    public convenience init(size: GPUExtent3D, mipLevelCount: GPUIntegerCoordinate, sampleCount: GPUSize32, dimension: GPUTextureDimension, format: GPUTextureFormat, usage: GPUTextureUsageFlags, viewFormats: [GPUTextureFormat]) {
        let object = JSObject.global[.Object].function!.new()
        object[.size] = _toJSValue(size)
        object[.mipLevelCount] = _toJSValue(mipLevelCount)
        object[.sampleCount] = _toJSValue(sampleCount)
        object[.dimension] = _toJSValue(dimension)
        object[.format] = _toJSValue(format)
        object[.usage] = _toJSValue(usage)
        object[.viewFormats] = _toJSValue(viewFormats)
        self.init(unsafelyWrapping: object)
    }

    public var size: GPUExtent3D {
        get { jsObject[.size].fromJSValue()!}
        set { jsObject[.size] = newValue.jsValue }
    }

    public var mipLevelCount: GPUIntegerCoordinate {
        get { jsObject[.mipLevelCount].fromJSValue()!}
        set { jsObject[.mipLevelCount] = newValue.jsValue }
    }

    public var sampleCount: GPUSize32 {
        get { jsObject[.sampleCount].fromJSValue()!}
        set { jsObject[.sampleCount] = newValue.jsValue }
    }

    public var dimension: GPUTextureDimension {
        get { jsObject[.dimension].fromJSValue()!}
        set { jsObject[.dimension] = newValue.jsValue }
    }

    public var format: GPUTextureFormat {
        get { jsObject[.format].fromJSValue()!}
        set { jsObject[.format] = newValue.jsValue }
    }

    public var usage: GPUTextureUsageFlags {
        get { jsObject[.usage].fromJSValue()!}
        set { jsObject[.usage] = newValue.jsValue }
    }

    public var viewFormats: [GPUTextureFormat] {
        get { jsObject[.viewFormats].fromJSValue()!}
        set { jsObject[.viewFormats] = newValue.jsValue }
    }
}

public enum GPUTextureDimension: JSString, JSValueCompatible {
    case _1d = "1d"
    case _2d = "2d"
    case _3d = "3d"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureFormat: JSString, JSValueCompatible {
    case r8unorm = "r8unorm"
    case r8snorm = "r8snorm"
    case r8uint = "r8uint"
    case r8sint = "r8sint"
    case r16uint = "r16uint"
    case r16sint = "r16sint"
    case r16float = "r16float"
    case rg8unorm = "rg8unorm"
    case rg8snorm = "rg8snorm"
    case rg8uint = "rg8uint"
    case rg8sint = "rg8sint"
    case r32uint = "r32uint"
    case r32sint = "r32sint"
    case r32float = "r32float"
    case rg16uint = "rg16uint"
    case rg16sint = "rg16sint"
    case rg16float = "rg16float"
    case rgba8unorm = "rgba8unorm"
    case rgba8unormSrgb = "rgba8unorm-srgb"
    case rgba8snorm = "rgba8snorm"
    case rgba8uint = "rgba8uint"
    case rgba8sint = "rgba8sint"
    case bgra8unorm = "bgra8unorm"
    case bgra8unormSrgb = "bgra8unorm-srgb"
    case rgb9e5ufloat = "rgb9e5ufloat"
    case rgb10a2unorm = "rgb10a2unorm"
    case rg11b10ufloat = "rg11b10ufloat"
    case rg32uint = "rg32uint"
    case rg32sint = "rg32sint"
    case rg32float = "rg32float"
    case rgba16uint = "rgba16uint"
    case rgba16sint = "rgba16sint"
    case rgba16float = "rgba16float"
    case rgba32uint = "rgba32uint"
    case rgba32sint = "rgba32sint"
    case rgba32float = "rgba32float"
    case stencil8 = "stencil8"
    case depth16unorm = "depth16unorm"
    case depth24plus = "depth24plus"
    case depth24plusStencil8 = "depth24plus-stencil8"
    case depth32float = "depth32float"
    case depth32floatStencil8 = "depth32float-stencil8"
    case bc1RgbaUnorm = "bc1-rgba-unorm"
    case bc1RgbaUnormSrgb = "bc1-rgba-unorm-srgb"
    case bc2RgbaUnorm = "bc2-rgba-unorm"
    case bc2RgbaUnormSrgb = "bc2-rgba-unorm-srgb"
    case bc3RgbaUnorm = "bc3-rgba-unorm"
    case bc3RgbaUnormSrgb = "bc3-rgba-unorm-srgb"
    case bc4RUnorm = "bc4-r-unorm"
    case bc4RSnorm = "bc4-r-snorm"
    case bc5RgUnorm = "bc5-rg-unorm"
    case bc5RgSnorm = "bc5-rg-snorm"
    case bc6hRgbUfloat = "bc6h-rgb-ufloat"
    case bc6hRgbFloat = "bc6h-rgb-float"
    case bc7RgbaUnorm = "bc7-rgba-unorm"
    case bc7RgbaUnormSrgb = "bc7-rgba-unorm-srgb"
    case etc2Rgb8unorm = "etc2-rgb8unorm"
    case etc2Rgb8unormSrgb = "etc2-rgb8unorm-srgb"
    case etc2Rgb8a1unorm = "etc2-rgb8a1unorm"
    case etc2Rgb8a1unormSrgb = "etc2-rgb8a1unorm-srgb"
    case etc2Rgba8unorm = "etc2-rgba8unorm"
    case etc2Rgba8unormSrgb = "etc2-rgba8unorm-srgb"
    case eacR11unorm = "eac-r11unorm"
    case eacR11snorm = "eac-r11snorm"
    case eacRg11unorm = "eac-rg11unorm"
    case eacRg11snorm = "eac-rg11snorm"
    case astc4x4Unorm = "astc-4x4-unorm"
    case astc4x4UnormSrgb = "astc-4x4-unorm-srgb"
    case astc5x4Unorm = "astc-5x4-unorm"
    case astc5x4UnormSrgb = "astc-5x4-unorm-srgb"
    case astc5x5Unorm = "astc-5x5-unorm"
    case astc5x5UnormSrgb = "astc-5x5-unorm-srgb"
    case astc6x5Unorm = "astc-6x5-unorm"
    case astc6x5UnormSrgb = "astc-6x5-unorm-srgb"
    case astc6x6Unorm = "astc-6x6-unorm"
    case astc6x6UnormSrgb = "astc-6x6-unorm-srgb"
    case astc8x5Unorm = "astc-8x5-unorm"
    case astc8x5UnormSrgb = "astc-8x5-unorm-srgb"
    case astc8x6Unorm = "astc-8x6-unorm"
    case astc8x6UnormSrgb = "astc-8x6-unorm-srgb"
    case astc8x8Unorm = "astc-8x8-unorm"
    case astc8x8UnormSrgb = "astc-8x8-unorm-srgb"
    case astc10x5Unorm = "astc-10x5-unorm"
    case astc10x5UnormSrgb = "astc-10x5-unorm-srgb"
    case astc10x6Unorm = "astc-10x6-unorm"
    case astc10x6UnormSrgb = "astc-10x6-unorm-srgb"
    case astc10x8Unorm = "astc-10x8-unorm"
    case astc10x8UnormSrgb = "astc-10x8-unorm-srgb"
    case astc10x10Unorm = "astc-10x10-unorm"
    case astc10x10UnormSrgb = "astc-10x10-unorm-srgb"
    case astc12x10Unorm = "astc-12x10-unorm"
    case astc12x10UnormSrgb = "astc-12x10-unorm-srgb"
    case astc12x12Unorm = "astc-12x12-unorm"
    case astc12x12UnormSrgb = "astc-12x12-unorm-srgb"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureSampleType: JSString, JSValueCompatible {
    case float = "float"
    case unfilterableFloat = "unfilterable-float"
    case depth = "depth"
    case sint = "sint"
    case uint = "uint"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GPUTextureUsage {
    @inlinable public static var jsObject: JSObject {
        JSObject.global[.GPUTextureUsage].object!
    }

    public static let COPY_SRC: GPUFlagsConstant = 0x01

    public static let COPY_DST: GPUFlagsConstant = 0x02

    public static let TEXTURE_BINDING: GPUFlagsConstant = 0x04

    public static let STORAGE_BINDING: GPUFlagsConstant = 0x08

    public static let RENDER_ATTACHMENT: GPUFlagsConstant = 0x10
}

public class GPUTextureView: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GPUTextureView].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class GPUTextureViewDescriptor: BridgedDictionary {
    public convenience init(format: GPUTextureFormat, dimension: GPUTextureViewDimension, aspect: GPUTextureAspect, baseMipLevel: GPUIntegerCoordinate, mipLevelCount: GPUIntegerCoordinate, baseArrayLayer: GPUIntegerCoordinate, arrayLayerCount: GPUIntegerCoordinate) {
        let object = JSObject.global[.Object].function!.new()
        object[.format] = _toJSValue(format)
        object[.dimension] = _toJSValue(dimension)
        object[.aspect] = _toJSValue(aspect)
        object[.baseMipLevel] = _toJSValue(baseMipLevel)
        object[.mipLevelCount] = _toJSValue(mipLevelCount)
        object[.baseArrayLayer] = _toJSValue(baseArrayLayer)
        object[.arrayLayerCount] = _toJSValue(arrayLayerCount)
        self.init(unsafelyWrapping: object)
    }

    public var format: GPUTextureFormat {
        get { jsObject[.format].fromJSValue()!}
        set { jsObject[.format] = newValue.jsValue }
    }

    public var dimension: GPUTextureViewDimension {
        get { jsObject[.dimension].fromJSValue()!}
        set { jsObject[.dimension] = newValue.jsValue }
    }

    public var aspect: GPUTextureAspect {
        get { jsObject[.aspect].fromJSValue()!}
        set { jsObject[.aspect] = newValue.jsValue }
    }

    public var baseMipLevel: GPUIntegerCoordinate {
        get { jsObject[.baseMipLevel].fromJSValue()!}
        set { jsObject[.baseMipLevel] = newValue.jsValue }
    }

    public var mipLevelCount: GPUIntegerCoordinate {
        get { jsObject[.mipLevelCount].fromJSValue()!}
        set { jsObject[.mipLevelCount] = newValue.jsValue }
    }

    public var baseArrayLayer: GPUIntegerCoordinate {
        get { jsObject[.baseArrayLayer].fromJSValue()!}
        set { jsObject[.baseArrayLayer] = newValue.jsValue }
    }

    public var arrayLayerCount: GPUIntegerCoordinate {
        get { jsObject[.arrayLayerCount].fromJSValue()!}
        set { jsObject[.arrayLayerCount] = newValue.jsValue }
    }
}

public enum GPUTextureViewDimension: JSString, JSValueCompatible {
    case _1d = "1d"
    case _2d = "2d"
    case _2dArray = "2d-array"
    case cube = "cube"
    case cubeArray = "cube-array"
    case _3d = "3d"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUUncapturedErrorEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUUncapturedErrorEvent].function }

    @inlinable public convenience init(type: String, gpuUncapturedErrorEventInitDict: GPUUncapturedErrorEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(gpuUncapturedErrorEventInitDict)]))
    }

public var error: GPUError {
jsObject[.error].fromJSValue()!
    }
}

public class GPUUncapturedErrorEventInit: BridgedDictionary {
    public convenience init(error: GPUError) {
        let object = JSObject.global[.Object].function!.new()
        object[.error] = _toJSValue(error)
        self.init(unsafelyWrapping: object)
    }
    public var error: GPUError {
        get { jsObject[.error].fromJSValue()!}
        set { jsObject[.error] = newValue.jsValue }
    }
}

public class GPUValidationError: GPUError {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GPUValidationError].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(message: String) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

public class GPUVertexAttribute: BridgedDictionary {
    public convenience init(format: GPUVertexFormat, offset: GPUSize64, shaderLocation: GPUIndex32) {
        let object = JSObject.global[.Object].function!.new()
        object[.format] = _toJSValue(format)
        object[.offset] = _toJSValue(offset)
        object[.shaderLocation] = _toJSValue(shaderLocation)
        self.init(unsafelyWrapping: object)
    }

    public var format: GPUVertexFormat {
        get { jsObject[.format].fromJSValue()!}
        set { jsObject[.format] = newValue.jsValue }
    }

    public var offset: GPUSize64 {
        get { jsObject[.offset].fromJSValue()!}
        set { jsObject[.offset] = newValue.jsValue }
    }

    public var shaderLocation: GPUIndex32 {
        get { jsObject[.shaderLocation].fromJSValue()!}
        set { jsObject[.shaderLocation] = newValue.jsValue }
    }
}

public class GPUVertexBufferLayout: BridgedDictionary {
    public convenience init(arrayStride: GPUSize64, stepMode: GPUVertexStepMode, attributes: [GPUVertexAttribute]) {
        let object = JSObject.global[.Object].function!.new()
        object[.arrayStride] = _toJSValue(arrayStride)
        object[.stepMode] = _toJSValue(stepMode)
        object[.attributes] = _toJSValue(attributes)
        self.init(unsafelyWrapping: object)
    }

    public var arrayStride: GPUSize64 {
        get { jsObject[.arrayStride].fromJSValue()!}
        set { jsObject[.arrayStride] = newValue.jsValue }
    }

    public var stepMode: GPUVertexStepMode {
        get { jsObject[.stepMode].fromJSValue()!}
        set { jsObject[.stepMode] = newValue.jsValue }
    }

    public var attributes: [GPUVertexAttribute] {
        get { jsObject[.attributes].fromJSValue()!}
        set { jsObject[.attributes] = newValue.jsValue }
    }
}

public enum GPUVertexFormat: JSString, JSValueCompatible {
    case uint8x2 = "uint8x2"
    case uint8x4 = "uint8x4"
    case sint8x2 = "sint8x2"
    case sint8x4 = "sint8x4"
    case unorm8x2 = "unorm8x2"
    case unorm8x4 = "unorm8x4"
    case snorm8x2 = "snorm8x2"
    case snorm8x4 = "snorm8x4"
    case uint16x2 = "uint16x2"
    case uint16x4 = "uint16x4"
    case sint16x2 = "sint16x2"
    case sint16x4 = "sint16x4"
    case unorm16x2 = "unorm16x2"
    case unorm16x4 = "unorm16x4"
    case snorm16x2 = "snorm16x2"
    case snorm16x4 = "snorm16x4"
    case float16x2 = "float16x2"
    case float16x4 = "float16x4"
    case float32 = "float32"
    case float32x2 = "float32x2"
    case float32x3 = "float32x3"
    case float32x4 = "float32x4"
    case uint32 = "uint32"
    case uint32x2 = "uint32x2"
    case uint32x3 = "uint32x3"
    case uint32x4 = "uint32x4"
    case sint32 = "sint32"
    case sint32x2 = "sint32x2"
    case sint32x3 = "sint32x3"
    case sint32x4 = "sint32x4"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GPUVertexState: BridgedDictionary {
    public convenience init(buffers: [GPUVertexBufferLayout?]) {
        let object = JSObject.global[.Object].function!.new()
        object[.buffers] = _toJSValue(buffers)
        self.init(unsafelyWrapping: object)
    }

    public var buffers: [GPUVertexBufferLayout?] {
        get { jsObject[.buffers].fromJSValue()!}
        set { jsObject[.buffers] = newValue.jsValue }
    }
}

public enum GPUVertexStepMode: JSString, JSValueCompatible {
    case vertex = "vertex"
    case instance = "instance"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public protocol NavigatorGPU: JSBridgedClass {}
public extension NavigatorGPU {
    @inlinable var gpu: GPU { jsObject[.gpu].fromJSValue()! }
}

extension Navigator: NavigatorGPU {}

public class WGSLLanguageFeatures: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.WGSLLanguageFeatures].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    // XXX: make me Set-like!
}



public enum GPUAutoLayoutMode_or_GPUPipelineLayout: JSValueCompatible  {
    case gpuAutoLayoutMode(GPUAutoLayoutMode)
    case gpuPipelineLayout(GPUPipelineLayout)

    public static func construct(from value: JSValue) -> Self? {
        if let gpuAutoLayoutMode: GPUAutoLayoutMode = value.fromJSValue() {
            return .gpuAutoLayoutMode(gpuAutoLayoutMode)
        }
        if let gpuPipelineLayout: GPUPipelineLayout = value.fromJSValue() {
            return .gpuPipelineLayout(gpuPipelineLayout)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuAutoLayoutMode(gpuAutoLayoutMode):
            return gpuAutoLayoutMode.jsValue
        case let .gpuPipelineLayout(gpuPipelineLayout):
            return gpuPipelineLayout.jsValue
        }
    }
}

public enum GPUBindingResource: JSValueCompatible {
    case gpuBufferBinding(GPUBufferBinding)
    case gpuExternalTexture(GPUExternalTexture)
    case gpuSampler(GPUSampler)
    case gpuTextureView(GPUTextureView)

    public static func construct(from value: JSValue) -> Self? {
        if let gpuBufferBinding: GPUBufferBinding = value.fromJSValue() {
            return .gpuBufferBinding(gpuBufferBinding)
        }
        if let gpuExternalTexture: GPUExternalTexture = value.fromJSValue() {
            return .gpuExternalTexture(gpuExternalTexture)
        }
        if let gpuSampler: GPUSampler = value.fromJSValue() {
            return .gpuSampler(gpuSampler)
        }
        if let gpuTextureView: GPUTextureView = value.fromJSValue() {
            return .gpuTextureView(gpuTextureView)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuBufferBinding(gpuBufferBinding):
            return gpuBufferBinding.jsValue
        case let .gpuExternalTexture(gpuExternalTexture):
            return gpuExternalTexture.jsValue
        case let .gpuSampler(gpuSampler):
            return gpuSampler.jsValue
        case let .gpuTextureView(gpuTextureView):
            return gpuTextureView.jsValue
        }
    }
}

public enum GPUColor: JSValueCompatible {
    case gpuColorDict(GPUColorDict)
    case seq_of_Double([Double])

    public static func construct(from value: JSValue) -> Self? {
        if let gpuColorDict: GPUColorDict = value.fromJSValue() {
            return .gpuColorDict(gpuColorDict)
        }
        if let seq_of_Double: [Double] = value.fromJSValue() {
            return .seq_of_Double(seq_of_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuColorDict(gpuColorDict):
            return gpuColorDict.jsValue
        case let .seq_of_Double(seq_of_Double):
            return seq_of_Double.jsValue
        }
    }
}

public enum GPUExtent3D: JSValueCompatible {
    case gpuExtent3DDict(GPUExtent3DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    public static func construct(from value: JSValue) -> Self? {
        if let gpuExtent3DDict: GPUExtent3DDict = value.fromJSValue() {
            return .gpuExtent3DDict(gpuExtent3DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuExtent3DDict(gpuExtent3DDict):
            return gpuExtent3DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public enum GPUImageCopyExternalImageSource: JSValueCompatible {
    case htmlCanvasElement(HTMLCanvasElement)
    case htmlVideoElement(HTMLVideoElement)
    case imageBitmap(ImageBitmap)
    case offscreenCanvas(OffscreenCanvas)
    case videoFrame(VideoFrame)

    public static func construct(from value: JSValue) -> Self? {
        if let htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if let htmlVideoElement: HTMLVideoElement = value.fromJSValue() {
            return .htmlVideoElement(htmlVideoElement)
        }
        if let imageBitmap: ImageBitmap = value.fromJSValue() {
            return .imageBitmap(imageBitmap)
        }
        if let offscreenCanvas: OffscreenCanvas = value.fromJSValue() {
            return .offscreenCanvas(offscreenCanvas)
        }
        if let videoFrame: VideoFrame = value.fromJSValue() {
            return .videoFrame(videoFrame)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlCanvasElement(htmlCanvasElement):
            return htmlCanvasElement.jsValue
        case let .htmlVideoElement(htmlVideoElement):
            return htmlVideoElement.jsValue
        case let .imageBitmap(imageBitmap):
            return imageBitmap.jsValue
        case let .offscreenCanvas(offscreenCanvas):
            return offscreenCanvas.jsValue
        case let .videoFrame(videoFrame):
            return videoFrame.jsValue
        }
    }
}

public enum GPUOrigin2D: JSValueCompatible {
    case gpuOrigin2DDict(GPUOrigin2DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    public static func construct(from value: JSValue) -> Self? {
        if let gpuOrigin2DDict: GPUOrigin2DDict = value.fromJSValue() {
            return .gpuOrigin2DDict(gpuOrigin2DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuOrigin2DDict(gpuOrigin2DDict):
            return gpuOrigin2DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public enum GPUOrigin3D: JSValueCompatible {
    case gpuOrigin3DDict(GPUOrigin3DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    public static func construct(from value: JSValue) -> Self? {
        if let gpuOrigin3DDict: GPUOrigin3DDict = value.fromJSValue() {
            return .gpuOrigin3DDict(gpuOrigin3DDict)
        }
        if let seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .gpuOrigin3DDict(gpuOrigin3DDict):
            return gpuOrigin3DDict.jsValue
        case let .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate):
            return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}

public enum HTMLVideoElement_or_VideoFrame: JSValueCompatible {
    case htmlVideoElement(HTMLVideoElement)
    case videoFrame(VideoFrame)

    public static func construct(from value: JSValue) -> Self? {
        if let htmlVideoElement: HTMLVideoElement = value.fromJSValue() {
            return .htmlVideoElement(htmlVideoElement)
        }
        if let videoFrame: VideoFrame = value.fromJSValue() {
            return .videoFrame(videoFrame)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .htmlVideoElement(htmlVideoElement):
            return htmlVideoElement.jsValue
        case let .videoFrame(videoFrame):
            return videoFrame.jsValue
        }
    }
}
