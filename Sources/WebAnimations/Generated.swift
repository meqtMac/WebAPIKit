// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptEventLoop
import JavaScriptKit
import WebAPIBase
import WebAudio

public protocol Animatable: JSBridgedClass {}
public extension Animatable {
    @inlinable func animate(keyframes: JSObject?, options: Double_or_KeyframeAnimationOptions? = nil) -> Animation {
        return jsObject["animate"].function!(this: jsObject, arguments: [_toJSValue(keyframes), _toJSValue(options)]).fromJSValue()!
    }

    @inlinable func getAnimations(options: GetAnimationsOptions? = nil) -> [Animation] {
        return jsObject["getAnimations"].function!(this: jsObject, arguments: [_toJSValue(options)]).fromJSValue()!
    }
}

extension Element: Animatable {}

public class Animation: EventTarget {
    @inlinable override public class var constructor: JSFunction? { JSObject.global["Animation"].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _id = ReadWriteAttribute(jsObject: jsObject, name: "id")
        _effect = ReadWriteAttribute(jsObject: jsObject, name: "effect")
        _timeline = ReadWriteAttribute(jsObject: jsObject, name: "timeline")
        _playbackRate = ReadWriteAttribute(jsObject: jsObject, name: "playbackRate")
        _playState = ReadonlyAttribute(jsObject: jsObject, name: "playState")
        _replaceState = ReadonlyAttribute(jsObject: jsObject, name: "replaceState")
        _pending = ReadonlyAttribute(jsObject: jsObject, name: "pending")
        _ready = ReadonlyAttribute(jsObject: jsObject, name: "ready")
        _finished = ReadonlyAttribute(jsObject: jsObject, name: "finished")
        _onfinish = ClosureAttribute1Optional(jsObject: jsObject, name: "onfinish")
        _oncancel = ClosureAttribute1Optional(jsObject: jsObject, name: "oncancel")
        _onremove = ClosureAttribute1Optional(jsObject: jsObject, name: "onremove")
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(effect: AnimationEffect? = nil, timeline: AnimationTimeline? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(effect), _toJSValue(timeline)]))
    }

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var effect: AnimationEffect?

    @ReadWriteAttribute
    public var timeline: AnimationTimeline?

    @ReadWriteAttribute
    public var playbackRate: Double

    @ReadonlyAttribute
    public var playState: AnimationPlayState

    @ReadonlyAttribute
    public var replaceState: AnimationReplaceState

    @ReadonlyAttribute
    public var pending: Bool

    @ReadonlyAttribute
    public var ready: JSPromise

    @ReadonlyAttribute
    public var finished: JSPromise

    @ClosureAttribute1Optional
    public var onfinish: EventHandler

    @ClosureAttribute1Optional
    public var oncancel: EventHandler

    @ClosureAttribute1Optional
    public var onremove: EventHandler

    @inlinable public func cancel() {
        _ = jsObject["cancel"].function!(this: jsObject, arguments: [])
    }

    @inlinable public func finish() {
        _ = jsObject["finish"].function!(this: jsObject, arguments: [])
    }

    @inlinable public func play() {
        _ = jsObject["play"].function!(this: jsObject, arguments: [])
    }

    @inlinable public func pause() {
        _ = jsObject["pause"].function!(this: jsObject, arguments: [])
    }

    @inlinable public func updatePlaybackRate(playbackRate: Double) {
        _ = jsObject["updatePlaybackRate"].function!(this: jsObject, arguments: [_toJSValue(playbackRate)])
    }

    @inlinable public func reverse() {
        _ = jsObject["reverse"].function!(this: jsObject, arguments: [])
    }

    @inlinable public func persist() {
        _ = jsObject["persist"].function!(this: jsObject, arguments: [])
    }

    @inlinable public func commitStyles() {
        _ = jsObject["commitStyles"].function!(this: jsObject, arguments: [])
    }
}

public class AnimationEffect: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global["AnimationEffect"].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

    @inlinable public func getTiming() -> EffectTiming {
        return jsObject["getTiming"].function!(this: jsObject, arguments: []).fromJSValue()!
    }

    @inlinable public func getComputedTiming() -> ComputedEffectTiming {
        return jsObject["getComputedTiming"].function!(this: jsObject, arguments: []).fromJSValue()!
    }

    @inlinable public func updateTiming(timing: OptionalEffectTiming? = nil) {
        _ = jsObject["updateTiming"].function!(this: jsObject, arguments: [_toJSValue(timing)])
    }
}

public enum AnimationPlayState: JSString, JSValueCompatible {
    case idle = "idle"
    case running = "running"
    case paused = "paused"
    case finished = "finished"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum AnimationReplaceState: JSString, JSValueCompatible {
    case active = "active"
    case removed = "removed"
    case persisted = "persisted"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class AnimationTimeline: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global["AnimationTimeline"].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
}

public class BaseComputedKeyframe: BridgedDictionary {
    public convenience init(offset: Double?, computedOffset: Double, easing: String, composite: CompositeOperationOrAuto) {
        let object = JSObject.global["Object"].function!.new()
        object["offset"] = _toJSValue(offset)
        object["computedOffset"] = _toJSValue(computedOffset)
        object["easing"] = _toJSValue(easing)
        object["composite"] = _toJSValue(composite)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: "offset")
        _computedOffset = ReadWriteAttribute(jsObject: object, name: "computedOffset")
        _easing = ReadWriteAttribute(jsObject: object, name: "easing")
        _composite = ReadWriteAttribute(jsObject: object, name: "composite")
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: Double?

    @ReadWriteAttribute
    public var computedOffset: Double

    @ReadWriteAttribute
    public var easing: String

    @ReadWriteAttribute
    public var composite: CompositeOperationOrAuto
}

public class BaseKeyframe: BridgedDictionary {
    public convenience init(offset: Double?, easing: String, composite: CompositeOperationOrAuto) {
        let object = JSObject.global["Object"].function!.new()
        object["offset"] = _toJSValue(offset)
        object["easing"] = _toJSValue(easing)
        object["composite"] = _toJSValue(composite)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: "offset")
        _easing = ReadWriteAttribute(jsObject: object, name: "easing")
        _composite = ReadWriteAttribute(jsObject: object, name: "composite")
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: Double?

    @ReadWriteAttribute
    public var easing: String

    @ReadWriteAttribute
    public var composite: CompositeOperationOrAuto
}

public class BasePropertyIndexedKeyframe: BridgedDictionary {
    public convenience init(offset: nullable_Double_or_seq_of_nullable_Double, easing: String_or_seq_of_String, composite: CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto) {
        let object = JSObject.global["Object"].function!.new()
        object["offset"] = _toJSValue(offset)
        object["easing"] = _toJSValue(easing)
        object["composite"] = _toJSValue(composite)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _offset = ReadWriteAttribute(jsObject: object, name: "offset")
        _easing = ReadWriteAttribute(jsObject: object, name: "easing")
        _composite = ReadWriteAttribute(jsObject: object, name: "composite")
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var offset: nullable_Double_or_seq_of_nullable_Double

    @ReadWriteAttribute
    public var easing: String_or_seq_of_String

    @ReadWriteAttribute
    public var composite: CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto
}

public enum CompositeOperation: JSString, JSValueCompatible {
    case replace = "replace"
    case add = "add"
    case accumulate = "accumulate"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CompositeOperationOrAuto: JSString, JSValueCompatible {
    case replace = "replace"
    case add = "add"
    case accumulate = "accumulate"
    case auto = "auto"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class ComputedEffectTiming: BridgedDictionary {
    public convenience init(progress: Double?, currentIteration: Double?) {
        let object = JSObject.global["Object"].function!.new()
        object["progress"] = _toJSValue(progress)
        object["currentIteration"] = _toJSValue(currentIteration)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _progress = ReadWriteAttribute(jsObject: object, name: "progress")
        _currentIteration = ReadWriteAttribute(jsObject: object, name: "currentIteration")
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var progress: Double?

    @ReadWriteAttribute
    public var currentIteration: Double?
}

public extension DocumentOrShadowRoot {
    @inlinable func getAnimations() -> [Animation] {
        return jsObject["getAnimations"].function!(this: jsObject, arguments: []).fromJSValue()!
    }
}

public class DocumentTimeline: AnimationTimeline {
    @inlinable override public class var constructor: JSFunction? { JSObject.global["DocumentTimeline"].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(options: DocumentTimelineOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(options)]))
    }
}

public class DocumentTimelineOptions: BridgedDictionary {
    public convenience init(originTime: DOMHighResTimeStamp) {
        let object = JSObject.global["Object"].function!.new()
        object["originTime"] = _toJSValue(originTime)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _originTime = ReadWriteAttribute(jsObject: object, name: "originTime")
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var originTime: DOMHighResTimeStamp
}

public class EffectTiming: BridgedDictionary {
    public convenience init(fill: FillMode, iterationStart: Double, iterations: Double, direction: PlaybackDirection, easing: String) {
        let object = JSObject.global["Object"].function!.new()
        object["fill"] = _toJSValue(fill)
        object["iterationStart"] = _toJSValue(iterationStart)
        object["iterations"] = _toJSValue(iterations)
        object["direction"] = _toJSValue(direction)
        object["easing"] = _toJSValue(easing)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _fill = ReadWriteAttribute(jsObject: object, name: "fill")
        _iterationStart = ReadWriteAttribute(jsObject: object, name: "iterationStart")
        _iterations = ReadWriteAttribute(jsObject: object, name: "iterations")
        _direction = ReadWriteAttribute(jsObject: object, name: "direction")
        _easing = ReadWriteAttribute(jsObject: object, name: "easing")
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var fill: FillMode

    @ReadWriteAttribute
    public var iterationStart: Double

    @ReadWriteAttribute
    public var iterations: Double

    @ReadWriteAttribute
    public var direction: PlaybackDirection

    @ReadWriteAttribute
    public var easing: String
}

public enum FillMode: JSString, JSValueCompatible {
    case none = "none"
    case forwards = "forwards"
    case backwards = "backwards"
    case both = "both"
    case auto = "auto"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GetAnimationsOptions: BridgedDictionary {
    public convenience init(subtree: Bool) {
        let object = JSObject.global["Object"].function!.new()
        object["subtree"] = _toJSValue(subtree)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _subtree = ReadWriteAttribute(jsObject: object, name: "subtree")
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var subtree: Bool
}

public class KeyframeAnimationOptions: BridgedDictionary {
    public convenience init(id: String, timeline: AnimationTimeline?) {
        let object = JSObject.global["Object"].function!.new()
        object["id"] = _toJSValue(id)
        object["timeline"] = _toJSValue(timeline)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _id = ReadWriteAttribute(jsObject: object, name: "id")
        _timeline = ReadWriteAttribute(jsObject: object, name: "timeline")
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var id: String

    @ReadWriteAttribute
    public var timeline: AnimationTimeline?
}

public class KeyframeEffect: AnimationEffect {
    @inlinable override public class var constructor: JSFunction? { JSObject.global["KeyframeEffect"].function }

    public required init(unsafelyWrapping jsObject: JSObject) {
        _target = ReadWriteAttribute(jsObject: jsObject, name: "target")
        _pseudoElement = ReadWriteAttribute(jsObject: jsObject, name: "pseudoElement")
        _composite = ReadWriteAttribute(jsObject: jsObject, name: "composite")
        super.init(unsafelyWrapping: jsObject)
    }

    @inlinable public convenience init(target: Element?, keyframes: JSObject?, options: Double_or_KeyframeEffectOptions? = nil) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(target), _toJSValue(keyframes), _toJSValue(options)]))
    }

    @inlinable public convenience init(source: KeyframeEffect) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(source)]))
    }

    @ReadWriteAttribute
    public var target: Element?

    @ReadWriteAttribute
    public var pseudoElement: String?

    @ReadWriteAttribute
    public var composite: CompositeOperation

    @inlinable public func getKeyframes() -> [JSObject] {
        return jsObject["getKeyframes"].function!(this: jsObject, arguments: []).fromJSValue()!
    }

    @inlinable public func setKeyframes(keyframes: JSObject?) {
        _ = jsObject["setKeyframes"].function!(this: jsObject, arguments: [_toJSValue(keyframes)])
    }
}

public class KeyframeEffectOptions: BridgedDictionary {
    public convenience init(composite: CompositeOperation, pseudoElement: String?) {
        let object = JSObject.global["Object"].function!.new()
        object["composite"] = _toJSValue(composite)
        object["pseudoElement"] = _toJSValue(pseudoElement)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _composite = ReadWriteAttribute(jsObject: object, name: "composite")
        _pseudoElement = ReadWriteAttribute(jsObject: object, name: "pseudoElement")
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var composite: CompositeOperation

    @ReadWriteAttribute
    public var pseudoElement: String?
}

public class OptionalEffectTiming: BridgedDictionary {
    public convenience init(delay: Double, endDelay: Double, fill: FillMode, iterationStart: Double, iterations: Double, duration: Double_or_String, direction: PlaybackDirection, easing: String) {
        let object = JSObject.global["Object"].function!.new()
        object["delay"] = _toJSValue(delay)
        object["endDelay"] = _toJSValue(endDelay)
        object["fill"] = _toJSValue(fill)
        object["iterationStart"] = _toJSValue(iterationStart)
        object["iterations"] = _toJSValue(iterations)
        object["duration"] = _toJSValue(duration)
        object["direction"] = _toJSValue(direction)
        object["easing"] = _toJSValue(easing)
        self.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) {
        _delay = ReadWriteAttribute(jsObject: object, name: "delay")
        _endDelay = ReadWriteAttribute(jsObject: object, name: "endDelay")
        _fill = ReadWriteAttribute(jsObject: object, name: "fill")
        _iterationStart = ReadWriteAttribute(jsObject: object, name: "iterationStart")
        _iterations = ReadWriteAttribute(jsObject: object, name: "iterations")
        _duration = ReadWriteAttribute(jsObject: object, name: "duration")
        _direction = ReadWriteAttribute(jsObject: object, name: "direction")
        _easing = ReadWriteAttribute(jsObject: object, name: "easing")
        super.init(unsafelyWrapping: object)
    }

    @ReadWriteAttribute
    public var delay: Double

    @ReadWriteAttribute
    public var endDelay: Double

    @ReadWriteAttribute
    public var fill: FillMode

    @ReadWriteAttribute
    public var iterationStart: Double

    @ReadWriteAttribute
    public var iterations: Double

    @ReadWriteAttribute
    public var duration: Double_or_String

    @ReadWriteAttribute
    public var direction: PlaybackDirection

    @ReadWriteAttribute
    public var easing: String
}

public enum PlaybackDirection: JSString, JSValueCompatible {
    case normal = "normal"
    case reverse = "reverse"
    case alternate = "alternate"
    case alternateReverse = "alternate-reverse"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum CompositeOperationOrAuto_or_seq_of_CompositeOperationOrAuto: JSValueCompatible {
    case compositeOperationOrAuto(CompositeOperationOrAuto)
    case seq_of_CompositeOperationOrAuto([CompositeOperationOrAuto])

    public static func construct(from value: JSValue) -> Self? {
        if let compositeOperationOrAuto: CompositeOperationOrAuto = value.fromJSValue() {
            return .compositeOperationOrAuto(compositeOperationOrAuto)
        }
        if let seq_of_CompositeOperationOrAuto: [CompositeOperationOrAuto] = value.fromJSValue() {
            return .seq_of_CompositeOperationOrAuto(seq_of_CompositeOperationOrAuto)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .compositeOperationOrAuto(compositeOperationOrAuto):
            return compositeOperationOrAuto.jsValue
        case let .seq_of_CompositeOperationOrAuto(seq_of_CompositeOperationOrAuto):
            return seq_of_CompositeOperationOrAuto.jsValue
        }
    }
}

public enum Double_or_KeyframeAnimationOptions: JSValueCompatible {
    case double(Double)
    case keyframeAnimationOptions(KeyframeAnimationOptions)

    public static func construct(from value: JSValue) -> Self? {
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let keyframeAnimationOptions: KeyframeAnimationOptions = value.fromJSValue() {
            return .keyframeAnimationOptions(keyframeAnimationOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .double(double):
            return double.jsValue
        case let .keyframeAnimationOptions(keyframeAnimationOptions):
            return keyframeAnimationOptions.jsValue
        }
    }
}

public enum Double_or_KeyframeEffectOptions: JSValueCompatible {
    case double(Double)
    case keyframeEffectOptions(KeyframeEffectOptions)

    public static func construct(from value: JSValue) -> Self? {
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let keyframeEffectOptions: KeyframeEffectOptions = value.fromJSValue() {
            return .keyframeEffectOptions(keyframeEffectOptions)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .double(double):
            return double.jsValue
        case let .keyframeEffectOptions(keyframeEffectOptions):
            return keyframeEffectOptions.jsValue
        }
    }
}

public enum Double_or_String: JSValueCompatible {
    case double(Double)
    case string(String)

    public static func construct(from value: JSValue) -> Self? {
        if let double: Double = value.fromJSValue() {
            return .double(double)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .double(double):
            return double.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}

public enum String_or_seq_of_String: JSValueCompatible {
    case string(String)
    case seq_of_String([String])

    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_String: [String] = value.fromJSValue() {
            return .seq_of_String(seq_of_String)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .seq_of_String(seq_of_String):
            return seq_of_String.jsValue
        }
    }
}

public enum nullable_Double_or_seq_of_nullable_Double: JSValueCompatible  {
    case nullable_Double(Double?)
    case seq_of_nullable_Double([Double?])

    public static func construct(from value: JSValue) -> Self? {
        if let nullable_Double: Double? = value.fromJSValue() {
            return .nullable_Double(nullable_Double)
        }
        if let seq_of_nullable_Double: [Double?] = value.fromJSValue() {
            return .seq_of_nullable_Double(seq_of_nullable_Double)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch self {
        case let .nullable_Double(nullable_Double):
            return nullable_Double.jsValue
        case let .seq_of_nullable_Double(seq_of_nullable_Double):
            return seq_of_nullable_Double.jsValue
        }
    }
}
