// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptKit
import JavaScriptEventLoop
import WebAPIBase

public class Gamepad: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.Gamepad].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }

public var id: String {
jsObject[.id].fromJSValue()!
    }

public var index: Int32 {
jsObject[.index].fromJSValue()!
    }

public var connected: Bool {
jsObject[.connected].fromJSValue()!
    }

public var timestamp: DOMHighResTimeStamp {
jsObject[.timestamp].fromJSValue()!
    }

public var mapping: GamepadMappingType {
jsObject[.mapping].fromJSValue()!
    }

public var axes: [Double] {
jsObject[.axes].fromJSValue()!
    }

public var buttons: [GamepadButton] {
jsObject[.buttons].fromJSValue()!
    }

public var hand: GamepadHand {
jsObject[.hand].fromJSValue()!
    }

public var hapticActuators: [GamepadHapticActuator] {
jsObject[.hapticActuators].fromJSValue()!
    }

public var pose: GamepadPose? {
jsObject[.pose].fromJSValue()
    }

public var touchEvents: [GamepadTouch]? {
jsObject[.touchEvents].fromJSValue()
    }

public var vibrationActuator: GamepadHapticActuator? {
jsObject[.vibrationActuator].fromJSValue()
    }
}

public class GamepadButton: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GamepadButton].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }

public var pressed: Bool {
jsObject[.pressed].fromJSValue()!
    }

public var touched: Bool {
jsObject[.touched].fromJSValue()!
    }

public var value: Double {
jsObject[.value].fromJSValue()!
    }
}

public class GamepadEffectParameters: BridgedDictionary {
    public convenience init(duration: Double, startDelay: Double, strongMagnitude: Double, weakMagnitude: Double) {
        let object = JSObject.global[.Object].function!.new()
        object[.duration] = _toJSValue(duration)
        object[.startDelay] = _toJSValue(startDelay)
        object[.strongMagnitude] = _toJSValue(strongMagnitude)
        object[.weakMagnitude] = _toJSValue(weakMagnitude)
        self.init(unsafelyWrapping: object)
    }

    public var duration: Double {
        get { jsObject[.duration].fromJSValue()!}
        set { jsObject[.duration] = newValue.jsValue }
    }

    public var startDelay: Double {
        get { jsObject[.startDelay].fromJSValue()!}
        set { jsObject[.startDelay] = newValue.jsValue }
    }

    public var strongMagnitude: Double {
        get { jsObject[.strongMagnitude].fromJSValue()!}
        set { jsObject[.strongMagnitude] = newValue.jsValue }
    }

    public var weakMagnitude: Double {
        get { jsObject[.weakMagnitude].fromJSValue()!}
        set { jsObject[.weakMagnitude] = newValue.jsValue }
    }
}

public class GamepadEvent: Event {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.GamepadEvent].function }

    @inlinable public convenience init(type: String, eventInitDict: GamepadEventInit) {
        self.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

public var gamepad: Gamepad {
jsObject[.gamepad].fromJSValue()!
    }
}

public class GamepadEventInit: BridgedDictionary {
    public convenience init(gamepad: Gamepad) {
        let object = JSObject.global[.Object].function!.new()
        object[.gamepad] = _toJSValue(gamepad)
        self.init(unsafelyWrapping: object)
    }

    public var gamepad: Gamepad {
        get { jsObject[.gamepad].fromJSValue()!}
        set { jsObject[.gamepad] = newValue.jsValue }
    }
}

public enum GamepadHand: JSString, JSValueCompatible {
    case _empty = ""
    case left = "left"
    case right = "right"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GamepadHapticActuator: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GamepadHapticActuator].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }

public var type: GamepadHapticActuatorType {
jsObject[.type].fromJSValue()!
    }

    @inlinable public func canPlayEffectType(type: GamepadHapticEffectType) -> Bool {
        let this = jsObject
        return this[.canPlayEffectType].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    @inlinable public func playEffect(type: GamepadHapticEffectType, params: GamepadEffectParameters? = nil) async throws -> GamepadHapticsResult {
        let this = jsObject
        let _promise: JSPromise = this[.playEffect].function!(this: this, arguments: [_toJSValue(type), _toJSValue(params)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func pulse(value: Double, duration: Double) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[.pulse].function!(this: this, arguments: [_toJSValue(value), _toJSValue(duration)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }

    @inlinable public func reset() async throws -> GamepadHapticsResult {
        let this = jsObject
        let _promise: JSPromise = this[.reset].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public enum GamepadHapticActuatorType: JSString, JSValueCompatible {
    case vibration = "vibration"
    case dualRumble = "dual-rumble"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GamepadHapticEffectType: JSString, JSValueCompatible {
    case dualRumble = "dual-rumble"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GamepadHapticsResult: JSString, JSValueCompatible {
    case complete = "complete"
    case preempted = "preempted"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum GamepadMappingType: JSString, JSValueCompatible {
    case _empty = ""
    case standard = "standard"
    case xrStandard = "xr-standard"

    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }

    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class GamepadPose: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GamepadPose].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }

public var hasOrientation: Bool {
jsObject[.hasOrientation].fromJSValue()!
    }

public var hasPosition: Bool {
jsObject[.hasPosition].fromJSValue()!
    }

public var position: Float32Array? {
jsObject[.position].fromJSValue()
    }

public var linearVelocity: Float32Array? {
jsObject[.linearVelocity].fromJSValue()
    }

public var linearAcceleration: Float32Array? {
jsObject[.linearAcceleration].fromJSValue()
    }

public var orientation: Float32Array? {
jsObject[.orientation].fromJSValue()
    }

public var angularVelocity: Float32Array? {
jsObject[.angularVelocity].fromJSValue()
    }

public var angularAcceleration: Float32Array? {
jsObject[.angularAcceleration].fromJSValue()
    }
}

public class GamepadTouch: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.GamepadTouch].function }

    public let jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) {
       self.jsObject = jsObject
    }

public var touchId: UInt32 {
jsObject[.touchId].fromJSValue()!
    }

public var surfaceId: UInt8 {
jsObject[.surfaceId].fromJSValue()!
    }

public var position: Float32Array {
jsObject[.position].fromJSValue()!
    }

public var surfaceDimensions: Uint32Array? {
jsObject[.surfaceDimensions].fromJSValue()
    }
}

public extension Navigator {
    @inlinable func getGamepads() -> [Gamepad?] {
        let this = jsObject
        return this[.getGamepads].function!(this: this, arguments: []).fromJSValue()!
    }
}

public extension WindowEventHandlers {
    @inlinable var ongamepadconnected: EventHandler {
        get { ClosureAttribute1Optional[.ongamepadconnected, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ongamepadconnected, in: jsObject] = newValue }
    }

    @inlinable var ongamepaddisconnected: EventHandler {
        get { ClosureAttribute1Optional[.ongamepaddisconnected, in: jsObject] }
        nonmutating set { ClosureAttribute1Optional[.ongamepaddisconnected, in: jsObject] = newValue }
    }
}

