// This file was auto-generated by WebIDLToSwift. DO NOT EDIT!

import DOM
import ECMAScript
import JavaScriptBigIntSupport
import JavaScriptEventLoop
import JavaScriptKit
import WebAPIBase

public class DirectoryPickerOptions: BridgedDictionary {
    public convenience init(id: String, startIn: StartInDirectory, mode: FileSystemPermissionMode) {
        let object = JSObject.global[.Object].function!.new()
        object[.id] = _toJSValue(id)
        object[.startIn] = _toJSValue(startIn)
        object[.mode] = _toJSValue(mode)
        self.init(unsafelyWrapping: object)
    }
    
    public var id: String {
        get { jsObject[.id].fromJSValue()!}
        set { jsObject[.id] = newValue.jsValue }
    }
    
    public var startIn: StartInDirectory {
        get { jsObject[.startIn].fromJSValue()!}
        set { jsObject[.startIn] = newValue.jsValue }
    }
    
    public var mode: FileSystemPermissionMode {
        get { jsObject[.mode].fromJSValue()!}
        set { jsObject[.mode] = newValue.jsValue }
    }
}

public class FilePickerAcceptType: BridgedDictionary {
    public convenience init(description: String, accept: [String: String_or_seq_of_String]) {
        let object = JSObject.global[.Object].function!.new()
        object[.description] = _toJSValue(description)
        object[.accept] = _toJSValue(accept)
        self.init(unsafelyWrapping: object)
    }
    
    public var description: String {
        get { jsObject[.description].fromJSValue()!}
        set { jsObject[.description] = newValue.jsValue }
    }
    
    public var accept: [String: String_or_seq_of_String] {
        get { jsObject[.accept].fromJSValue()!}
        set { jsObject[.accept] = newValue.jsValue }
    }
}

public class FilePickerOptions: BridgedDictionary {
    public convenience init(types: [FilePickerAcceptType], excludeAcceptAllOption: Bool, id: String, startIn: StartInDirectory) {
        let object = JSObject.global[.Object].function!.new()
        object[.types] = _toJSValue(types)
        object[.excludeAcceptAllOption] = _toJSValue(excludeAcceptAllOption)
        object[.id] = _toJSValue(id)
        object[.startIn] = _toJSValue(startIn)
        self.init(unsafelyWrapping: object)
    }
    
    public var types: [FilePickerAcceptType] {
        get { jsObject[.types].fromJSValue()!}
        set { jsObject[.types] = newValue.jsValue }
    }
    
    public var excludeAcceptAllOption: Bool {
        get { jsObject[.excludeAcceptAllOption].fromJSValue()!}
        set { jsObject[.excludeAcceptAllOption] = newValue.jsValue }
    }
    
    public var id: String {
        get { jsObject[.id].fromJSValue()!}
        set { jsObject[.id] = newValue.jsValue }
    }
    
    public var startIn: StartInDirectory {
        get { jsObject[.startIn].fromJSValue()!}
        set { jsObject[.startIn] = newValue.jsValue }
    }
}

public class FileSystemCreateWritableOptions: BridgedDictionary {
    public convenience init(keepExistingData: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.keepExistingData] = _toJSValue(keepExistingData)
        self.init(unsafelyWrapping: object)
    }
    
    public var keepExistingData: Bool {
        get { jsObject[.keepExistingData].fromJSValue()!}
        set { jsObject[.keepExistingData] = newValue.jsValue }
    }
}

public class FileSystemDirectoryHandle: FileSystemHandle, AsyncSequence {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.FileSystemDirectoryHandle].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    public typealias Element = String
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func makeAsyncIterator() -> ValueIterableAsyncIterator<FileSystemDirectoryHandle> {
        ValueIterableAsyncIterator(sequence: self)
    }
    
    @inlinable public func getFileHandle(name: String, options: FileSystemGetFileOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.getFileHandle].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getFileHandle(name: String, options: FileSystemGetFileOptions? = nil) async throws -> FileSystemFileHandle {
        let this = jsObject
        let _promise: JSPromise = this[.getFileHandle].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
    
    @inlinable public func getDirectoryHandle(name: String, options: FileSystemGetDirectoryOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.getDirectoryHandle].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getDirectoryHandle(name: String, options: FileSystemGetDirectoryOptions? = nil) async throws -> FileSystemDirectoryHandle {
        let this = jsObject
        let _promise: JSPromise = this[.getDirectoryHandle].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
    
    @inlinable public func removeEntry(name: String, options: FileSystemRemoveOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.removeEntry].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func removeEntry(name: String, options: FileSystemRemoveOptions? = nil) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.removeEntry].function!(this: this, arguments: [_toJSValue(name), _toJSValue(options)]).fromJSValue()!
        _ = try await _promise.value
    }
    
    @inlinable public func resolve(possibleDescendant: FileSystemHandle) -> JSPromise {
        let this = jsObject
        return this[.resolve].function!(this: this, arguments: [_toJSValue(possibleDescendant)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func resolve(possibleDescendant: FileSystemHandle) async throws -> [String]? {
        let this = jsObject
        let _promise: JSPromise = this[.resolve].function!(this: this, arguments: [_toJSValue(possibleDescendant)]).fromJSValue()!
        return try await _promise.value.fromJSValue()
    }
}

public class FileSystemFileHandle: FileSystemHandle {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.FileSystemFileHandle].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public func getFile() -> JSPromise {
        let this = jsObject
        return this[.getFile].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getFile() async throws -> File {
        let this = jsObject
        let _promise: JSPromise = this[.getFile].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
    
    @inlinable public func createWritable(options: FileSystemCreateWritableOptions? = nil) -> JSPromise {
        let this = jsObject
        return this[.createWritable].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func createWritable(options: FileSystemCreateWritableOptions? = nil) async throws -> FileSystemWritableFileStream {
        let this = jsObject
        let _promise: JSPromise = this[.createWritable].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
    
    // XXX: member 'createSyncAccessHandle' is ignored
    
    // XXX: member 'createSyncAccessHandle' is ignored
}

public class FileSystemGetDirectoryOptions: BridgedDictionary {
    public convenience init(create: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.create] = _toJSValue(create)
        self.init(unsafelyWrapping: object)
    }
    
    public var create: Bool {
        get { jsObject[.create].fromJSValue()!}
        set { jsObject[.create] = newValue.jsValue }
    }
}

public class FileSystemGetFileOptions: BridgedDictionary {
    public convenience init(create: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.create] = _toJSValue(create)
        self.init(unsafelyWrapping: object)
    }
    
    public var create: Bool {
        get { jsObject[.create].fromJSValue()!}
        set { jsObject[.create] = newValue.jsValue }
    }
}

public class FileSystemHandle: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.FileSystemHandle].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    public var kind: FileSystemHandleKind {
        jsObject[.kind].fromJSValue()!
    }
    
    public var name: String {
        jsObject[.name].fromJSValue()!
    }
    
    @inlinable public func isSameEntry(other: FileSystemHandle) -> JSPromise {
        let this = jsObject
        return this[.isSameEntry].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func isSameEntry(other: FileSystemHandle) async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[.isSameEntry].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
    
    @inlinable public func queryPermission(descriptor: FileSystemHandlePermissionDescriptor? = nil) -> JSPromise {
        let this = jsObject
        return this[.queryPermission].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func queryPermission(descriptor: FileSystemHandlePermissionDescriptor? = nil) async throws -> PermissionState {
        let this = jsObject
        let _promise: JSPromise = this[.queryPermission].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
    
    @inlinable public func requestPermission(descriptor: FileSystemHandlePermissionDescriptor? = nil) -> JSPromise {
        let this = jsObject
        return this[.requestPermission].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func requestPermission(descriptor: FileSystemHandlePermissionDescriptor? = nil) async throws -> PermissionState {
        let this = jsObject
        let _promise: JSPromise = this[.requestPermission].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public enum FileSystemHandleKind: JSString, JSValueCompatible {
    case file = "file"
    case directory = "directory"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class FileSystemHandlePermissionDescriptor: BridgedDictionary {
    public convenience init(mode: FileSystemPermissionMode) {
        let object = JSObject.global[.Object].function!.new()
        object[.mode] = _toJSValue(mode)
        self.init(unsafelyWrapping: object)
    }
    
    public var mode: FileSystemPermissionMode {
        get { jsObject[.mode].fromJSValue()!}
        set { jsObject[.mode] = newValue.jsValue }
    }
}

public class FileSystemPermissionDescriptor: BridgedDictionary {
    public convenience init(handle: FileSystemHandle, mode: FileSystemPermissionMode) {
        let object = JSObject.global[.Object].function!.new()
        object[.handle] = _toJSValue(handle)
        object[.mode] = _toJSValue(mode)
        self.init(unsafelyWrapping: object)
    }
    
    public var handle: FileSystemHandle {
        get { jsObject[.handle].fromJSValue()!}
        set { jsObject[.handle] = newValue.jsValue }
    }
    
    public var mode: FileSystemPermissionMode {
        get { jsObject[.mode].fromJSValue()!}
        set { jsObject[.mode] = newValue.jsValue }
    }
}

public enum FileSystemPermissionMode: JSString, JSValueCompatible {
    case read = "read"
    case readwrite = "readwrite"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class FileSystemReadWriteOptions: BridgedDictionary {
    public convenience init(at: UInt64) {
        let object = JSObject.global[.Object].function!.new()
        object[.at] = _toJSValue(at)
        self.init(unsafelyWrapping: object)
    }
    
    public var at: UInt64 {
        get { jsObject[.at].fromJSValue()!}
        set { jsObject[.at] = newValue.jsValue }
    }
}

public class FileSystemRemoveOptions: BridgedDictionary {
    public convenience init(recursive: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.recursive] = _toJSValue(recursive)
        self.init(unsafelyWrapping: object)
    }
    
    public var recursive: Bool {
        get { jsObject[.recursive].fromJSValue()!}
        set { jsObject[.recursive] = newValue.jsValue }
    }
}

public class FileSystemWritableFileStream: WritableStream {
    @inlinable override public class var constructor: JSFunction? { JSObject.global[.FileSystemWritableFileStream].function }
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        super.init(unsafelyWrapping: jsObject)
    }
    
    @inlinable public func write(data blob: Blob) async throws {
        let _promise: JSPromise = jsObject[.write].function!(this: jsObject, arguments: [_toJSValue(blob)]).fromJSValue()!
        _ = try await _promise.value
    }
    @inlinable public func write(data bufferSource: BufferSource) async throws {
        let _promise: JSPromise = jsObject[.write].function!(this: jsObject, arguments: [_toJSValue(bufferSource)]).fromJSValue()!
        _ = try await _promise.value
    }
    @inlinable public func write(data string: String) async throws {
        let _promise: JSPromise = jsObject[.write].function!(this: jsObject, arguments: [_toJSValue(string)]).fromJSValue()!
        _ = try await _promise.value
    }
    @inlinable public func write(data writeParams: WriteParams) async throws {
        let _promise: JSPromise = jsObject[.write].function!(this: jsObject, arguments: [_toJSValue(writeParams)]).fromJSValue()!
        _ = try await _promise.value
    }
    
    
    
    @inlinable public func seek(position: UInt64) -> JSPromise {
        let this = jsObject
        return this[.seek].function!(this: this, arguments: [_toJSValue(position)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func seek(position: UInt64) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.seek].function!(this: this, arguments: [_toJSValue(position)]).fromJSValue()!
        _ = try await _promise.value
    }
    
    @inlinable public func truncate(size: UInt64) -> JSPromise {
        let this = jsObject
        return this[.truncate].function!(this: this, arguments: [_toJSValue(size)]).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func truncate(size: UInt64) async throws {
        let this = jsObject
        let _promise: JSPromise = this[.truncate].function!(this: this, arguments: [_toJSValue(size)]).fromJSValue()!
        _ = try await _promise.value
    }
}

public protocol NavigatorStorage: JSBridgedClass {}
public extension NavigatorStorage {
    @inlinable var storage: StorageManager { jsObject[.storage].fromJSValue()! }
}

extension Navigator: NavigatorStorage {}

public class OpenFilePickerOptions: BridgedDictionary {
    public convenience init(multiple: Bool) {
        let object = JSObject.global[.Object].function!.new()
        object[.multiple] = _toJSValue(multiple)
        self.init(unsafelyWrapping: object)
    }
    
    public var multiple: Bool {
        get { jsObject[.multiple].fromJSValue()!}
        set { jsObject[.multiple] = newValue.jsValue }
    }
}

public class SaveFilePickerOptions: BridgedDictionary {
    public convenience init(suggestedName: String?) {
        let object = JSObject.global[.Object].function!.new()
        object[.suggestedName] = _toJSValue(suggestedName)
        self.init(unsafelyWrapping: object)
    }
    
    public var suggestedName: String? {
        get { jsObject[.suggestedName].fromJSValue()}
        set { jsObject[.suggestedName] = newValue.jsValue }
    }
}

public class StorageEstimate: BridgedDictionary {
    public convenience init(usage: UInt64, quota: UInt64) {
        let object = JSObject.global[.Object].function!.new()
        object[.usage] = _toJSValue(usage)
        object[.quota] = _toJSValue(quota)
        self.init(unsafelyWrapping: object)
    }
    
    public var usage: UInt64 {
        get { jsObject[.usage].fromJSValue()!}
        set { jsObject[.usage] = newValue.jsValue }
    }
    
    public var quota: UInt64 {
        get { jsObject[.quota].fromJSValue()!}
        set { jsObject[.quota] = newValue.jsValue }
    }
}

public class StorageManager: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[.StorageManager].function }
    
    public let jsObject: JSObject
    
    public required init(unsafelyWrapping jsObject: JSObject) {
        self.jsObject = jsObject
    }
    
    @inlinable public func getDirectory() -> JSPromise {
        let this = jsObject
        return this[.getDirectory].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func getDirectory() async throws -> FileSystemDirectoryHandle {
        let this = jsObject
        let _promise: JSPromise = this[.getDirectory].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
    
    @inlinable public func persisted() -> JSPromise {
        let this = jsObject
        return this[.persisted].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func persisted() async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[.persisted].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
    
    @inlinable public func persist() -> JSPromise {
        let this = jsObject
        return this[.persist].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func persist() async throws -> Bool {
        let this = jsObject
        let _promise: JSPromise = this[.persist].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
    
    @inlinable public func estimate() -> JSPromise {
        let this = jsObject
        return this[.estimate].function!(this: this, arguments: []).fromJSValue()!
    }
    
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public func estimate() async throws -> StorageEstimate {
        let this = jsObject
        let _promise: JSPromise = this[.estimate].function!(this: this, arguments: []).fromJSValue()!
        return try await _promise.value.fromJSValue()!
    }
}

public enum WellKnownDirectory: JSString, JSValueCompatible {
    case desktop = "desktop"
    case documents = "documents"
    case downloads = "downloads"
    case music = "music"
    case pictures = "pictures"
    case videos = "videos"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public enum WriteCommandType: JSString, JSValueCompatible {
    case write = "write"
    case seek = "seek"
    case truncate = "truncate"
    
    @inlinable public static func construct(from jsValue: JSValue) -> Self? {
        if let string = jsValue.jsString {
            return Self(rawValue: string)
        }
        return nil
    }
    
    @inlinable public init?(string: String) {
        self.init(rawValue: JSString(string))
    }
    
    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}

public class WriteParams: BridgedDictionary {
    public convenience init(type: WriteCommandType, size: UInt64?, position: UInt64?, data: Blob_or_BufferSource_or_String?) {
        let object = JSObject.global[.Object].function!.new()
        object[.type] = _toJSValue(type)
        object[.size] = _toJSValue(size)
        object[.position] = _toJSValue(position)
        object[.data] = _toJSValue(data)
        self.init(unsafelyWrapping: object)
    }
    
    public var type: WriteCommandType {
        get { jsObject[.type].fromJSValue()!}
        set { jsObject[.type] = newValue.jsValue }
    }
    
    public var size: UInt64? {
        get { jsObject[.size].fromJSValue()}
        set { jsObject[.size] = newValue.jsValue }
    }
    
    public var position: UInt64? {
        get { jsObject[.position].fromJSValue()}
        set { jsObject[.position] = newValue.jsValue }
    }
    
    public var data: Blob_or_BufferSource_or_String? {
        get { jsObject[.data].fromJSValue()}
        set { jsObject[.data] = newValue.jsValue }
    }
}

public protocol Any_Blob_or_BufferSource_or_String: ConvertibleToJSValue {}
extension Blob: Any_Blob_or_BufferSource_or_String {}
extension BufferSource: Any_Blob_or_BufferSource_or_String {}
extension String: Any_Blob_or_BufferSource_or_String {}

public enum Blob_or_BufferSource_or_String: JSValueCompatible, Any_Blob_or_BufferSource_or_String {
    case blob(Blob)
    case bufferSource(BufferSource)
    case string(String)
    
    init(_ blob: Blob) {
        let val: Blob_or_BufferSource_or_String = .blob(blob)
        self = val
    }
    
    init(_ bufferSource: BufferSource) {
        let val: Blob_or_BufferSource_or_String = .bufferSource(bufferSource)
        self = val
    }
    
    init(_ arrayBuffer: ArrayBuffer) {
        let val: BufferSource = .arrayBuffer(arrayBuffer)
        self = .init(val)
    }
    
    init(_ arrayBufferView: ArrayBufferView) {
        let val: BufferSource = .arrayBufferView(arrayBufferView)
        self = .init(val)
    }
    
    init(_ string: String) {
        let val: Blob_or_BufferSource_or_String = .string(string)
        self = val
    }
    
    public var blob: Blob? {
        switch self {
        case let .blob(blob): return blob
        default: return nil
        }
    }
    
    public var bufferSource: BufferSource? {
        switch self {
        case let .bufferSource(bufferSource): return bufferSource
        default: return nil
        }
    }
    
    public var string: String? {
        switch self {
        case let .string(string): return string
        default: return nil
        }
    }
    
    public static func construct(from value: JSValue) -> Self? {
        if let blob: Blob = value.fromJSValue() {
            return .blob(blob)
        }
        if let bufferSource: BufferSource = value.fromJSValue() {
            return .bufferSource(bufferSource)
        }
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .blob(blob):
            return blob.jsValue
        case let .bufferSource(bufferSource):
            return bufferSource.jsValue
        case let .string(string):
            return string.jsValue
        }
    }
}


public protocol Any_StartInDirectory: ConvertibleToJSValue {}
extension FileSystemHandle: Any_StartInDirectory {}
extension WellKnownDirectory: Any_StartInDirectory {}

public enum StartInDirectory: JSValueCompatible, Any_StartInDirectory {
    case fileSystemHandle(FileSystemHandle)
    case wellKnownDirectory(WellKnownDirectory)
    
    public static func construct(from value: JSValue) -> Self? {
        if let fileSystemHandle: FileSystemHandle = value.fromJSValue() {
            return .fileSystemHandle(fileSystemHandle)
        }
        if let wellKnownDirectory: WellKnownDirectory = value.fromJSValue() {
            return .wellKnownDirectory(wellKnownDirectory)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .fileSystemHandle(fileSystemHandle):
            return fileSystemHandle.jsValue
        case let .wellKnownDirectory(wellKnownDirectory):
            return wellKnownDirectory.jsValue
        }
    }
}

public enum String_or_seq_of_String: JSValueCompatible {
    case string(String)
    case seq_of_String([String])
    
    public static func construct(from value: JSValue) -> Self? {
        if let string: String = value.fromJSValue() {
            return .string(string)
        }
        if let seq_of_String: [String] = value.fromJSValue() {
            return .seq_of_String(seq_of_String)
        }
        return nil
    }
    
    public var jsValue: JSValue {
        switch self {
        case let .string(string):
            return string.jsValue
        case let .seq_of_String(seq_of_String):
            return seq_of_String.jsValue
        }
    }
}
